{"map":"{\"version\":3,\"sources\":[\"webpack/bootstrap\"],\"names\":[\"installedModules\",\"__webpack_require__\",\"moduleId\",\"exports\",\"module\",\"i\",\"l\",\"modules\",\"call\",\"m\",\"c\",\"d\",\"name\",\"getter\",\"o\",\"Object\",\"defineProperty\",\"enumerable\",\"get\",\"r\",\"Symbol\",\"toStringTag\",\"value\",\"t\",\"mode\",\"__esModule\",\"ns\",\"create\",\"key\",\"bind\",\"n\",\"object\",\"property\",\"prototype\",\"hasOwnProperty\",\"p\",\"s\"],\"mappings\":\"aACA,IAAAA,KAGA,SAAAC,EAAAC,GAGA,GAAAF,EAAAE,GACA,OAAAF,EAAAE,GAAAC,QAGA,IAAAC,EAAAJ,EAAAE,IACAG,EAAAH,EACAI,GAAA,EACAH,YAUA,OANAI,EAAAL,GAAAM,KAAAJ,EAAAD,QAAAC,EAAAA,EAAAD,QAAAF,GAGAG,EAAAE,GAAA,EAGAF,EAAAD,QAKAF,EAAAQ,EAAAF,EAGAN,EAAAS,EAAAV,EAGAC,EAAAU,EAAA,SAAAR,EAAAS,EAAAC,GACAZ,EAAAa,EAAAX,EAAAS,IACAG,OAAAC,eAAAb,EAAAS,GAA0CK,YAAA,EAAAC,IAAAL,KAK1CZ,EAAAkB,EAAA,SAAAhB,GACA,oBAAAiB,QAAAA,OAAAC,aACAN,OAAAC,eAAAb,EAAAiB,OAAAC,aAAwDC,MAAA,WAExDP,OAAAC,eAAAb,EAAA,cAAiDmB,OAAA,KAQjDrB,EAAAsB,EAAA,SAAAD,EAAAE,GAEA,GADA,EAAAA,IAAAF,EAAArB,EAAAqB,IACA,EAAAE,EAAA,OAAAF,EACA,GAAA,EAAAE,GAAA,iBAAAF,GAAAA,GAAAA,EAAAG,WAAA,OAAAH,EACA,IAAAI,EAAAX,OAAAY,OAAA,MAGA,GAFA1B,EAAAkB,EAAAO,GACAX,OAAAC,eAAAU,EAAA,WAAyCT,YAAA,EAAAK,MAAAA,IACzC,EAAAE,GAAA,iBAAAF,EAAA,IAAA,IAAAM,KAAAN,EAAArB,EAAAU,EAAAe,EAAAE,EAAA,SAAAA,GAAgH,OAAAN,EAAAM,IAAqBC,KAAA,KAAAD,IACrI,OAAAF,GAIAzB,EAAA6B,EAAA,SAAA1B,GACA,IAAAS,EAAAT,GAAAA,EAAAqB,WACA,WAA2B,OAAArB,EAAA,SAC3B,WAAiC,OAAAA,GAEjC,OADAH,EAAAU,EAAAE,EAAA,IAAAA,GACAA,GAIAZ,EAAAa,EAAA,SAAAiB,EAAAC,GAAsD,OAAAjB,OAAAkB,UAAAC,eAAA1B,KAAAuB,EAAAC,IAGtD/B,EAAAkC,EAAA,QAIAlC,EAAAA,EAAAmC,EAAA\",\"sourcesContent\":[\" \\t// The module cache\\n \\tvar installedModules = {};\\n\\n \\t// The require function\\n \\tfunction __webpack_require__(moduleId) {\\n\\n \\t\\t// Check if module is in cache\\n \\t\\tif(installedModules[moduleId]) {\\n \\t\\t\\treturn installedModules[moduleId].exports;\\n \\t\\t}\\n \\t\\t// Create a new module (and put it into the cache)\\n \\t\\tvar module = installedModules[moduleId] = {\\n \\t\\t\\ti: moduleId,\\n \\t\\t\\tl: false,\\n \\t\\t\\texports: {}\\n \\t\\t};\\n\\n \\t\\t// Execute the module function\\n \\t\\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\\n\\n \\t\\t// Flag the module as loaded\\n \\t\\tmodule.l = true;\\n\\n \\t\\t// Return the exports of the module\\n \\t\\treturn module.exports;\\n \\t}\\n\\n\\n \\t// expose the modules object (__webpack_modules__)\\n \\t__webpack_require__.m = modules;\\n\\n \\t// expose the module cache\\n \\t__webpack_require__.c = installedModules;\\n\\n \\t// define getter function for harmony exports\\n \\t__webpack_require__.d = function(exports, name, getter) {\\n \\t\\tif(!__webpack_require__.o(exports, name)) {\\n \\t\\t\\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\\n \\t\\t}\\n \\t};\\n\\n \\t// define __esModule on exports\\n \\t__webpack_require__.r = function(exports) {\\n \\t\\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\\n \\t\\t\\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\\n \\t\\t}\\n \\t\\tObject.defineProperty(exports, '__esModule', { value: true });\\n \\t};\\n\\n \\t// create a fake namespace object\\n \\t// mode & 1: value is a module id, require it\\n \\t// mode & 2: merge all properties of value into the ns\\n \\t// mode & 4: return value when already ns object\\n \\t// mode & 8|1: behave like require\\n \\t__webpack_require__.t = function(value, mode) {\\n \\t\\tif(mode & 1) value = __webpack_require__(value);\\n \\t\\tif(mode & 8) return value;\\n \\t\\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\\n \\t\\tvar ns = Object.create(null);\\n \\t\\t__webpack_require__.r(ns);\\n \\t\\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\\n \\t\\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\\n \\t\\treturn ns;\\n \\t};\\n\\n \\t// getDefaultExport function for compatibility with non-harmony modules\\n \\t__webpack_require__.n = function(module) {\\n \\t\\tvar getter = module && module.__esModule ?\\n \\t\\t\\tfunction getDefault() { return module['default']; } :\\n \\t\\t\\tfunction getModuleExports() { return module; };\\n \\t\\t__webpack_require__.d(getter, 'a', getter);\\n \\t\\treturn getter;\\n \\t};\\n\\n \\t// Object.prototype.hasOwnProperty.call\\n \\t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\\n\\n \\t// __webpack_public_path__\\n \\t__webpack_require__.p = \\\"dist/\\\";\\n\\n\\n \\t// Load entry module and return exports\\n \\treturn __webpack_require__(__webpack_require__.s = 2);\\n\"]}","code":"!function(Q){var B={};function F(U){if(B[U])return B[U].exports;var c=B[U]={i:U,l:!1,exports:{}};return Q[U].call(c.exports,c,c.exports,F),c.l=!0,c.exports}F.m=Q,F.c=B,F.d=function(Q,B,U){F.o(Q,B)||Object.defineProperty(Q,B,{enumerable:!0,get:U})},F.r=function(Q){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(Q,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(Q,\"__esModule\",{value:!0})},F.t=function(Q,B){if(1&B&&(Q=F(Q)),8&B)return Q;if(4&B&&\"object\"==typeof Q&&Q&&Q.__esModule)return Q;var U=Object.create(null);if(F.r(U),Object.defineProperty(U,\"default\",{enumerable:!0,value:Q}),2&B&&\"string\"!=typeof Q)for(var c in Q)F.d(U,c,function(B){return Q[B]}.bind(null,c));return U},F.n=function(Q){var B=Q&&Q.__esModule?function(){return Q.default}:function(){return Q};return F.d(B,\"a\",B),B},F.o=function(Q,B){return Object.prototype.hasOwnProperty.call(Q,B)},F.p=\"dist/\",F(F.s=2)}([function(module,exports){eval('var g;\\n\\n// This works in non-strict mode\\ng = function () {\\n\\treturn this;\\n}();\\n\\ntry {\\n\\t// This works if eval is allowed (see CSP)\\n\\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\\n} catch (e) {\\n\\t// This works if the window reference is available\\n\\tif (typeof window === \"object\") g = window;\\n}\\n\\n// g can still be undefined, but nothing to do about it...\\n// We return undefined, instead of nothing here, so it\\'s\\n// easier to handle this case. if(!global) { ...}\\n\\nmodule.exports = g;//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzP2NkMDAiXSwibmFtZXMiOlsiZyIsIkZ1bmN0aW9uIiwiZXZhbCIsImUiLCJ3aW5kb3ciLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiQUFBQSxJQUFJQSxDQUFKOztBQUVBO0FBQ0FBLElBQUssWUFBVztBQUNmLFFBQU8sSUFBUDtBQUNBLENBRkcsRUFBSjs7QUFJQSxJQUFJO0FBQ0g7QUFDQUEsS0FBSUEsS0FBS0MsU0FBUyxhQUFULEdBQUwsSUFBa0MsQ0FBQyxHQUFHQyxJQUFKLEVBQVUsTUFBVixDQUF0QztBQUNBLENBSEQsQ0FHRSxPQUFPQyxDQUFQLEVBQVU7QUFDWDtBQUNBLEtBQUksT0FBT0MsTUFBUCxLQUFrQixRQUF0QixFQUFnQ0osSUFBSUksTUFBSjtBQUNoQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUFDLE9BQU9DLE9BQVAsR0FBaUJOLENBQWpCIiwiZmlsZSI6IjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSwgZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoIChlKSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcclxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcclxufVxyXG5cclxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxyXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xyXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGc7XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///0\\n')},,function(Q,B,F){F(3),Q.exports=F(25)},function(module,exports,__webpack_require__){\"use strict\";eval(\"/* WEBPACK VAR INJECTION */(function(__resourceQuery) {\\n\\n/* global __resourceQuery WorkerGlobalScope self */\\n/* eslint prefer-destructuring: off */\\n\\nvar url = __webpack_require__(4);\\nvar stripAnsi = __webpack_require__(11);\\nvar log = __webpack_require__(13).getLogger('webpack-dev-server');\\nvar socket = __webpack_require__(14);\\nvar overlay = __webpack_require__(16);\\n\\nfunction getCurrentScriptSource() {\\n  // `document.currentScript` is the most accurate way to find the current script,\\n  // but is not supported in all browsers.\\n  if (document.currentScript) {\\n    return document.currentScript.getAttribute('src');\\n  }\\n  // Fall back to getting all scripts in the document.\\n  var scriptElements = document.scripts || [];\\n  var currentScript = scriptElements[scriptElements.length - 1];\\n  if (currentScript) {\\n    return currentScript.getAttribute('src');\\n  }\\n  // Fail as there was no script to use.\\n  throw new Error('[WDS] Failed to get current script source.');\\n}\\n\\nvar urlParts = void 0;\\nvar hotReload = true;\\nif (typeof window !== 'undefined') {\\n  var qs = window.location.search.toLowerCase();\\n  hotReload = qs.indexOf('hotreload=false') === -1;\\n}\\nif (true) {\\n  // If this bundle is inlined, use the resource query to get the correct url.\\n  urlParts = url.parse(__resourceQuery.substr(1));\\n} else { var scriptHost; }\\n\\nif (!urlParts.port || urlParts.port === '0') {\\n  urlParts.port = self.location.port;\\n}\\n\\nvar _hot = false;\\nvar initial = true;\\nvar currentHash = '';\\nvar useWarningOverlay = false;\\nvar useErrorOverlay = false;\\nvar useProgress = false;\\n\\nvar INFO = 'info';\\nvar WARNING = 'warning';\\nvar ERROR = 'error';\\nvar NONE = 'none';\\n\\n// Set the default log level\\nlog.setDefaultLevel(INFO);\\n\\n// Send messages to the outside, so plugins can consume it.\\nfunction sendMsg(type, data) {\\n  if (typeof self !== 'undefined' && (typeof WorkerGlobalScope === 'undefined' || !(self instanceof WorkerGlobalScope))) {\\n    self.postMessage({\\n      type: 'webpack' + type,\\n      data: data\\n    }, '*');\\n  }\\n}\\n\\nvar onSocketMsg = {\\n  hot: function hot() {\\n    _hot = true;\\n    log.info('[WDS] Hot Module Replacement enabled.');\\n  },\\n  invalid: function invalid() {\\n    log.info('[WDS] App updated. Recompiling...');\\n    // fixes #1042. overlay doesn't clear if errors are fixed but warnings remain.\\n    if (useWarningOverlay || useErrorOverlay) overlay.clear();\\n    sendMsg('Invalid');\\n  },\\n  hash: function hash(_hash) {\\n    currentHash = _hash;\\n  },\\n\\n  'still-ok': function stillOk() {\\n    log.info('[WDS] Nothing changed.');\\n    if (useWarningOverlay || useErrorOverlay) overlay.clear();\\n    sendMsg('StillOk');\\n  },\\n  'log-level': function logLevel(level) {\\n    var hotCtx = __webpack_require__(21);\\n    if (hotCtx.keys().indexOf('./log') !== -1) {\\n      hotCtx('./log').setLogLevel(level);\\n    }\\n    switch (level) {\\n      case INFO:\\n      case ERROR:\\n        log.setLevel(level);\\n        break;\\n      case WARNING:\\n        // loglevel's warning name is different from webpack's\\n        log.setLevel('warn');\\n        break;\\n      case NONE:\\n        log.disableAll();\\n        break;\\n      default:\\n        log.error('[WDS] Unknown clientLogLevel \\\\'' + level + '\\\\'');\\n    }\\n  },\\n  overlay: function overlay(value) {\\n    if (typeof document !== 'undefined') {\\n      if (typeof value === 'boolean') {\\n        useWarningOverlay = false;\\n        useErrorOverlay = value;\\n      } else if (value) {\\n        useWarningOverlay = value.warnings;\\n        useErrorOverlay = value.errors;\\n      }\\n    }\\n  },\\n  progress: function progress(_progress) {\\n    if (typeof document !== 'undefined') {\\n      useProgress = _progress;\\n    }\\n  },\\n\\n  'progress-update': function progressUpdate(data) {\\n    if (useProgress) log.info('[WDS] ' + data.percent + '% - ' + data.msg + '.');\\n    sendMsg('Progress', data);\\n  },\\n  ok: function ok() {\\n    sendMsg('Ok');\\n    if (useWarningOverlay || useErrorOverlay) overlay.clear();\\n    if (initial) return initial = false; // eslint-disable-line no-return-assign\\n    reloadApp();\\n  },\\n\\n  'content-changed': function contentChanged() {\\n    log.info('[WDS] Content base changed. Reloading...');\\n    self.location.reload();\\n  },\\n  warnings: function warnings(_warnings) {\\n    log.warn('[WDS] Warnings while compiling.');\\n    var strippedWarnings = _warnings.map(function (warning) {\\n      return stripAnsi(warning);\\n    });\\n    sendMsg('Warnings', strippedWarnings);\\n    for (var i = 0; i < strippedWarnings.length; i++) {\\n      log.warn(strippedWarnings[i]);\\n    }\\n    if (useWarningOverlay) overlay.showMessage(_warnings);\\n\\n    if (initial) return initial = false; // eslint-disable-line no-return-assign\\n    reloadApp();\\n  },\\n  errors: function errors(_errors) {\\n    log.error('[WDS] Errors while compiling. Reload prevented.');\\n    var strippedErrors = _errors.map(function (error) {\\n      return stripAnsi(error);\\n    });\\n    sendMsg('Errors', strippedErrors);\\n    for (var i = 0; i < strippedErrors.length; i++) {\\n      log.error(strippedErrors[i]);\\n    }\\n    if (useErrorOverlay) overlay.showMessage(_errors);\\n    initial = false;\\n  },\\n  error: function error(_error) {\\n    log.error(_error);\\n  },\\n  close: function close() {\\n    log.error('[WDS] Disconnected!');\\n    sendMsg('Close');\\n  }\\n};\\n\\nvar hostname = urlParts.hostname;\\nvar protocol = urlParts.protocol;\\n\\n// check ipv4 and ipv6 `all hostname`\\nif (hostname === '0.0.0.0' || hostname === '::') {\\n  // why do we need this check?\\n  // hostname n/a for file protocol (example, when using electron, ionic)\\n  // see: https://github.com/webpack/webpack-dev-server/pull/384\\n  // eslint-disable-next-line no-bitwise\\n  if (self.location.hostname && !!~self.location.protocol.indexOf('http')) {\\n    hostname = self.location.hostname;\\n  }\\n}\\n\\n// `hostname` can be empty when the script path is relative. In that case, specifying\\n// a protocol would result in an invalid URL.\\n// When https is used in the app, secure websockets are always necessary\\n// because the browser doesn't accept non-secure websockets.\\nif (hostname && (self.location.protocol === 'https:' || urlParts.hostname === '0.0.0.0')) {\\n  protocol = self.location.protocol;\\n}\\n\\nvar socketUrl = url.format({\\n  protocol: protocol,\\n  auth: urlParts.auth,\\n  hostname: hostname,\\n  port: urlParts.port,\\n  pathname: urlParts.path == null || urlParts.path === '/' ? '/sockjs-node' : urlParts.path\\n});\\n\\nsocket(socketUrl, onSocketMsg);\\n\\nvar isUnloading = false;\\nself.addEventListener('beforeunload', function () {\\n  isUnloading = true;\\n});\\n\\nfunction reloadApp() {\\n  if (isUnloading || !hotReload) {\\n    return;\\n  }\\n  if (_hot) {\\n    log.info('[WDS] App hot update...');\\n    // eslint-disable-next-line global-require\\n    var hotEmitter = __webpack_require__(23);\\n    hotEmitter.emit('webpackHotUpdate', currentHash);\\n    if (typeof self !== 'undefined' && self.window) {\\n      // broadcast update to window\\n      self.postMessage('webpackHotUpdate' + currentHash, '*');\\n    }\\n  } else {\\n    var rootWindow = self;\\n    // use parent window for reload (in case we're in an iframe with no valid src)\\n    var intervalId = self.setInterval(function () {\\n      if (rootWindow.location.protocol !== 'about:') {\\n        // reload immediately if protocol is valid\\n        applyReload(rootWindow, intervalId);\\n      } else {\\n        rootWindow = rootWindow.parent;\\n        if (rootWindow.parent === rootWindow) {\\n          // if parent equals current window we've reached the root which would continue forever, so trigger a reload anyways\\n          applyReload(rootWindow, intervalId);\\n        }\\n      }\\n    });\\n  }\\n\\n  function applyReload(rootWindow, intervalId) {\\n    clearInterval(intervalId);\\n    log.info('[WDS] App updated. Reloading...');\\n    rootWindow.location.reload();\\n  }\\n}\\n/* WEBPACK VAR INJECTION */}.call(this, \\\"?http://localhost:8081\\\"))//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvY2xpZW50L2luZGV4LmpzPzg5ODYiXSwibmFtZXMiOlsidXJsIiwicmVxdWlyZSIsInN0cmlwQW5zaSIsImxvZyIsImdldExvZ2dlciIsInNvY2tldCIsIm92ZXJsYXkiLCJnZXRDdXJyZW50U2NyaXB0U291cmNlIiwiZG9jdW1lbnQiLCJjdXJyZW50U2NyaXB0IiwiZ2V0QXR0cmlidXRlIiwic2NyaXB0RWxlbWVudHMiLCJzY3JpcHRzIiwibGVuZ3RoIiwiRXJyb3IiLCJ1cmxQYXJ0cyIsImhvdFJlbG9hZCIsIndpbmRvdyIsInFzIiwibG9jYXRpb24iLCJzZWFyY2giLCJ0b0xvd2VyQ2FzZSIsImluZGV4T2YiLCJwYXJzZSIsIl9fcmVzb3VyY2VRdWVyeSIsInN1YnN0ciIsInBvcnQiLCJzZWxmIiwiX2hvdCIsImluaXRpYWwiLCJjdXJyZW50SGFzaCIsInVzZVdhcm5pbmdPdmVybGF5IiwidXNlRXJyb3JPdmVybGF5IiwidXNlUHJvZ3Jlc3MiLCJJTkZPIiwiV0FSTklORyIsIkVSUk9SIiwiTk9ORSIsInNldERlZmF1bHRMZXZlbCIsInNlbmRNc2ciLCJ0eXBlIiwiZGF0YSIsIldvcmtlckdsb2JhbFNjb3BlIiwicG9zdE1lc3NhZ2UiLCJvblNvY2tldE1zZyIsImhvdCIsImluZm8iLCJpbnZhbGlkIiwiY2xlYXIiLCJoYXNoIiwiX2hhc2giLCJzdGlsbE9rIiwibG9nTGV2ZWwiLCJsZXZlbCIsImhvdEN0eCIsImtleXMiLCJzZXRMb2dMZXZlbCIsInNldExldmVsIiwiZGlzYWJsZUFsbCIsImVycm9yIiwidmFsdWUiLCJ3YXJuaW5ncyIsImVycm9ycyIsInByb2dyZXNzIiwiX3Byb2dyZXNzIiwicHJvZ3Jlc3NVcGRhdGUiLCJwZXJjZW50IiwibXNnIiwib2siLCJyZWxvYWRBcHAiLCJjb250ZW50Q2hhbmdlZCIsInJlbG9hZCIsIl93YXJuaW5ncyIsIndhcm4iLCJzdHJpcHBlZFdhcm5pbmdzIiwibWFwIiwid2FybmluZyIsImkiLCJzaG93TWVzc2FnZSIsIl9lcnJvcnMiLCJzdHJpcHBlZEVycm9ycyIsIl9lcnJvciIsImNsb3NlIiwiaG9zdG5hbWUiLCJwcm90b2NvbCIsInNvY2tldFVybCIsImZvcm1hdCIsImF1dGgiLCJwYXRobmFtZSIsInBhdGgiLCJpc1VubG9hZGluZyIsImFkZEV2ZW50TGlzdGVuZXIiLCJob3RFbWl0dGVyIiwiZW1pdCIsInJvb3RXaW5kb3ciLCJpbnRlcnZhbElkIiwic2V0SW50ZXJ2YWwiLCJhcHBseVJlbG9hZCIsInBhcmVudCIsImNsZWFySW50ZXJ2YWwiXSwibWFwcGluZ3MiOiJBQUFBLHVEQUFhOztBQUViO0FBQ0E7O0FBRUEsSUFBSUEsTUFBTUMsbUJBQU9BLENBQUMsQ0FBUixDQUFWO0FBQ0EsSUFBSUMsWUFBWUQsbUJBQU9BLENBQUMsRUFBUixDQUFoQjtBQUNBLElBQUlFLE1BQU1GLG1CQUFPQSxDQUFDLEVBQVIsRUFBb0JHLFNBQXBCLENBQThCLG9CQUE5QixDQUFWO0FBQ0EsSUFBSUMsU0FBU0osbUJBQU9BLENBQUMsRUFBUixDQUFiO0FBQ0EsSUFBSUssVUFBVUwsbUJBQU9BLENBQUMsRUFBUixDQUFkOztBQUVBLFNBQVNNLHNCQUFULEdBQWtDO0FBQ2hDO0FBQ0E7QUFDQSxNQUFJQyxTQUFTQyxhQUFiLEVBQTRCO0FBQzFCLFdBQU9ELFNBQVNDLGFBQVQsQ0FBdUJDLFlBQXZCLENBQW9DLEtBQXBDLENBQVA7QUFDRDtBQUNEO0FBQ0EsTUFBSUMsaUJBQWlCSCxTQUFTSSxPQUFULElBQW9CLEVBQXpDO0FBQ0EsTUFBSUgsZ0JBQWdCRSxlQUFlQSxlQUFlRSxNQUFmLEdBQXdCLENBQXZDLENBQXBCO0FBQ0EsTUFBSUosYUFBSixFQUFtQjtBQUNqQixXQUFPQSxjQUFjQyxZQUFkLENBQTJCLEtBQTNCLENBQVA7QUFDRDtBQUNEO0FBQ0EsUUFBTSxJQUFJSSxLQUFKLENBQVUsNENBQVYsQ0FBTjtBQUNEOztBQUVELElBQUlDLFdBQVcsS0FBSyxDQUFwQjtBQUNBLElBQUlDLFlBQVksSUFBaEI7QUFDQSxJQUFJLE9BQU9DLE1BQVAsS0FBa0IsV0FBdEIsRUFBbUM7QUFDakMsTUFBSUMsS0FBS0QsT0FBT0UsUUFBUCxDQUFnQkMsTUFBaEIsQ0FBdUJDLFdBQXZCLEVBQVQ7QUFDQUwsY0FBWUUsR0FBR0ksT0FBSCxDQUFXLGlCQUFYLE1BQWtDLENBQUMsQ0FBL0M7QUFDRDtBQUNELElBQUksSUFBSixFQUE0RDtBQUMxRDtBQUNBUCxhQUFXZixJQUFJdUIsS0FBSixDQUFVQyxnQkFBZ0JDLE1BQWhCLENBQXVCLENBQXZCLENBQVYsQ0FBWDtBQUNELENBSEQsTUFHTyxtQkFNTjs7QUFFRCxJQUFJLENBQUNWLFNBQVNXLElBQVYsSUFBa0JYLFNBQVNXLElBQVQsS0FBa0IsR0FBeEMsRUFBNkM7QUFDM0NYLFdBQVNXLElBQVQsR0FBZ0JDLEtBQUtSLFFBQUwsQ0FBY08sSUFBOUI7QUFDRDs7QUFFRCxJQUFJRSxPQUFPLEtBQVg7QUFDQSxJQUFJQyxVQUFVLElBQWQ7QUFDQSxJQUFJQyxjQUFjLEVBQWxCO0FBQ0EsSUFBSUMsb0JBQW9CLEtBQXhCO0FBQ0EsSUFBSUMsa0JBQWtCLEtBQXRCO0FBQ0EsSUFBSUMsY0FBYyxLQUFsQjs7QUFFQSxJQUFJQyxPQUFPLE1BQVg7QUFDQSxJQUFJQyxVQUFVLFNBQWQ7QUFDQSxJQUFJQyxRQUFRLE9BQVo7QUFDQSxJQUFJQyxPQUFPLE1BQVg7O0FBRUE7QUFDQWxDLElBQUltQyxlQUFKLENBQW9CSixJQUFwQjs7QUFFQTtBQUNBLFNBQVNLLE9BQVQsQ0FBaUJDLElBQWpCLEVBQXVCQyxJQUF2QixFQUE2QjtBQUMzQixNQUFJLE9BQU9kLElBQVAsS0FBZ0IsV0FBaEIsS0FBZ0MsT0FBT2UsaUJBQVAsS0FBNkIsV0FBN0IsSUFBNEMsRUFBRWYsZ0JBQWdCZSxpQkFBbEIsQ0FBNUUsQ0FBSixFQUF1SDtBQUNySGYsU0FBS2dCLFdBQUwsQ0FBaUI7QUFDZkgsWUFBTSxZQUFZQSxJQURIO0FBRWZDLFlBQU1BO0FBRlMsS0FBakIsRUFHRyxHQUhIO0FBSUQ7QUFDRjs7QUFFRCxJQUFJRyxjQUFjO0FBQ2hCQyxPQUFLLFNBQVNBLEdBQVQsR0FBZTtBQUNsQmpCLFdBQU8sSUFBUDtBQUNBekIsUUFBSTJDLElBQUosQ0FBUyx1Q0FBVDtBQUNELEdBSmU7QUFLaEJDLFdBQVMsU0FBU0EsT0FBVCxHQUFtQjtBQUMxQjVDLFFBQUkyQyxJQUFKLENBQVMsbUNBQVQ7QUFDQTtBQUNBLFFBQUlmLHFCQUFxQkMsZUFBekIsRUFBMEMxQixRQUFRMEMsS0FBUjtBQUMxQ1QsWUFBUSxTQUFSO0FBQ0QsR0FWZTtBQVdoQlUsUUFBTSxTQUFTQSxJQUFULENBQWNDLEtBQWQsRUFBcUI7QUFDekJwQixrQkFBY29CLEtBQWQ7QUFDRCxHQWJlOztBQWVoQixjQUFZLFNBQVNDLE9BQVQsR0FBbUI7QUFDN0JoRCxRQUFJMkMsSUFBSixDQUFTLHdCQUFUO0FBQ0EsUUFBSWYscUJBQXFCQyxlQUF6QixFQUEwQzFCLFFBQVEwQyxLQUFSO0FBQzFDVCxZQUFRLFNBQVI7QUFDRCxHQW5CZTtBQW9CaEIsZUFBYSxTQUFTYSxRQUFULENBQWtCQyxLQUFsQixFQUF5QjtBQUNwQyxRQUFJQyxTQUFTckQsdUJBQWI7QUFDQSxRQUFJcUQsT0FBT0MsSUFBUCxHQUFjakMsT0FBZCxDQUFzQixPQUF0QixNQUFtQyxDQUFDLENBQXhDLEVBQTJDO0FBQ3pDZ0MsYUFBTyxPQUFQLEVBQWdCRSxXQUFoQixDQUE0QkgsS0FBNUI7QUFDRDtBQUNELFlBQVFBLEtBQVI7QUFDRSxXQUFLbkIsSUFBTDtBQUNBLFdBQUtFLEtBQUw7QUFDRWpDLFlBQUlzRCxRQUFKLENBQWFKLEtBQWI7QUFDQTtBQUNGLFdBQUtsQixPQUFMO0FBQ0U7QUFDQWhDLFlBQUlzRCxRQUFKLENBQWEsTUFBYjtBQUNBO0FBQ0YsV0FBS3BCLElBQUw7QUFDRWxDLFlBQUl1RCxVQUFKO0FBQ0E7QUFDRjtBQUNFdkQsWUFBSXdELEtBQUosQ0FBVSxvQ0FBb0NOLEtBQXBDLEdBQTRDLElBQXREO0FBYko7QUFlRCxHQXhDZTtBQXlDaEIvQyxXQUFTLFNBQVNBLE9BQVQsQ0FBaUJzRCxLQUFqQixFQUF3QjtBQUMvQixRQUFJLE9BQU9wRCxRQUFQLEtBQW9CLFdBQXhCLEVBQXFDO0FBQ25DLFVBQUksT0FBT29ELEtBQVAsS0FBaUIsU0FBckIsRUFBZ0M7QUFDOUI3Qiw0QkFBb0IsS0FBcEI7QUFDQUMsMEJBQWtCNEIsS0FBbEI7QUFDRCxPQUhELE1BR08sSUFBSUEsS0FBSixFQUFXO0FBQ2hCN0IsNEJBQW9CNkIsTUFBTUMsUUFBMUI7QUFDQTdCLDBCQUFrQjRCLE1BQU1FLE1BQXhCO0FBQ0Q7QUFDRjtBQUNGLEdBbkRlO0FBb0RoQkMsWUFBVSxTQUFTQSxRQUFULENBQWtCQyxTQUFsQixFQUE2QjtBQUNyQyxRQUFJLE9BQU94RCxRQUFQLEtBQW9CLFdBQXhCLEVBQXFDO0FBQ25DeUIsb0JBQWMrQixTQUFkO0FBQ0Q7QUFDRixHQXhEZTs7QUEwRGhCLHFCQUFtQixTQUFTQyxjQUFULENBQXdCeEIsSUFBeEIsRUFBOEI7QUFDL0MsUUFBSVIsV0FBSixFQUFpQjlCLElBQUkyQyxJQUFKLENBQVMsV0FBV0wsS0FBS3lCLE9BQWhCLEdBQTBCLE1BQTFCLEdBQW1DekIsS0FBSzBCLEdBQXhDLEdBQThDLEdBQXZEO0FBQ2pCNUIsWUFBUSxVQUFSLEVBQW9CRSxJQUFwQjtBQUNELEdBN0RlO0FBOERoQjJCLE1BQUksU0FBU0EsRUFBVCxHQUFjO0FBQ2hCN0IsWUFBUSxJQUFSO0FBQ0EsUUFBSVIscUJBQXFCQyxlQUF6QixFQUEwQzFCLFFBQVEwQyxLQUFSO0FBQzFDLFFBQUluQixPQUFKLEVBQWEsT0FBT0EsVUFBVSxLQUFqQixDQUhHLENBR3FCO0FBQ3JDd0M7QUFDRCxHQW5FZTs7QUFxRWhCLHFCQUFtQixTQUFTQyxjQUFULEdBQTBCO0FBQzNDbkUsUUFBSTJDLElBQUosQ0FBUywwQ0FBVDtBQUNBbkIsU0FBS1IsUUFBTCxDQUFjb0QsTUFBZDtBQUNELEdBeEVlO0FBeUVoQlYsWUFBVSxTQUFTQSxRQUFULENBQWtCVyxTQUFsQixFQUE2QjtBQUNyQ3JFLFFBQUlzRSxJQUFKLENBQVMsaUNBQVQ7QUFDQSxRQUFJQyxtQkFBbUJGLFVBQVVHLEdBQVYsQ0FBYyxVQUFVQyxPQUFWLEVBQW1CO0FBQ3RELGFBQU8xRSxVQUFVMEUsT0FBVixDQUFQO0FBQ0QsS0FGc0IsQ0FBdkI7QUFHQXJDLFlBQVEsVUFBUixFQUFvQm1DLGdCQUFwQjtBQUNBLFNBQUssSUFBSUcsSUFBSSxDQUFiLEVBQWdCQSxJQUFJSCxpQkFBaUI3RCxNQUFyQyxFQUE2Q2dFLEdBQTdDLEVBQWtEO0FBQ2hEMUUsVUFBSXNFLElBQUosQ0FBU0MsaUJBQWlCRyxDQUFqQixDQUFUO0FBQ0Q7QUFDRCxRQUFJOUMsaUJBQUosRUFBdUJ6QixRQUFRd0UsV0FBUixDQUFvQk4sU0FBcEI7O0FBRXZCLFFBQUkzQyxPQUFKLEVBQWEsT0FBT0EsVUFBVSxLQUFqQixDQVh3QixDQVdBO0FBQ3JDd0M7QUFDRCxHQXRGZTtBQXVGaEJQLFVBQVEsU0FBU0EsTUFBVCxDQUFnQmlCLE9BQWhCLEVBQXlCO0FBQy9CNUUsUUFBSXdELEtBQUosQ0FBVSxpREFBVjtBQUNBLFFBQUlxQixpQkFBaUJELFFBQVFKLEdBQVIsQ0FBWSxVQUFVaEIsS0FBVixFQUFpQjtBQUNoRCxhQUFPekQsVUFBVXlELEtBQVYsQ0FBUDtBQUNELEtBRm9CLENBQXJCO0FBR0FwQixZQUFRLFFBQVIsRUFBa0J5QyxjQUFsQjtBQUNBLFNBQUssSUFBSUgsSUFBSSxDQUFiLEVBQWdCQSxJQUFJRyxlQUFlbkUsTUFBbkMsRUFBMkNnRSxHQUEzQyxFQUFnRDtBQUM5QzFFLFVBQUl3RCxLQUFKLENBQVVxQixlQUFlSCxDQUFmLENBQVY7QUFDRDtBQUNELFFBQUk3QyxlQUFKLEVBQXFCMUIsUUFBUXdFLFdBQVIsQ0FBb0JDLE9BQXBCO0FBQ3JCbEQsY0FBVSxLQUFWO0FBQ0QsR0FsR2U7QUFtR2hCOEIsU0FBTyxTQUFTQSxLQUFULENBQWVzQixNQUFmLEVBQXVCO0FBQzVCOUUsUUFBSXdELEtBQUosQ0FBVXNCLE1BQVY7QUFDRCxHQXJHZTtBQXNHaEJDLFNBQU8sU0FBU0EsS0FBVCxHQUFpQjtBQUN0Qi9FLFFBQUl3RCxLQUFKLENBQVUscUJBQVY7QUFDQXBCLFlBQVEsT0FBUjtBQUNEO0FBekdlLENBQWxCOztBQTRHQSxJQUFJNEMsV0FBV3BFLFNBQVNvRSxRQUF4QjtBQUNBLElBQUlDLFdBQVdyRSxTQUFTcUUsUUFBeEI7O0FBRUE7QUFDQSxJQUFJRCxhQUFhLFNBQWIsSUFBMEJBLGFBQWEsSUFBM0MsRUFBaUQ7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFJeEQsS0FBS1IsUUFBTCxDQUFjZ0UsUUFBZCxJQUEwQixDQUFDLENBQUMsQ0FBQ3hELEtBQUtSLFFBQUwsQ0FBY2lFLFFBQWQsQ0FBdUI5RCxPQUF2QixDQUErQixNQUEvQixDQUFqQyxFQUF5RTtBQUN2RTZELGVBQVd4RCxLQUFLUixRQUFMLENBQWNnRSxRQUF6QjtBQUNEO0FBQ0Y7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJQSxhQUFheEQsS0FBS1IsUUFBTCxDQUFjaUUsUUFBZCxLQUEyQixRQUEzQixJQUF1Q3JFLFNBQVNvRSxRQUFULEtBQXNCLFNBQTFFLENBQUosRUFBMEY7QUFDeEZDLGFBQVd6RCxLQUFLUixRQUFMLENBQWNpRSxRQUF6QjtBQUNEOztBQUVELElBQUlDLFlBQVlyRixJQUFJc0YsTUFBSixDQUFXO0FBQ3pCRixZQUFVQSxRQURlO0FBRXpCRyxRQUFNeEUsU0FBU3dFLElBRlU7QUFHekJKLFlBQVVBLFFBSGU7QUFJekJ6RCxRQUFNWCxTQUFTVyxJQUpVO0FBS3pCOEQsWUFBVXpFLFNBQVMwRSxJQUFULElBQWlCLElBQWpCLElBQXlCMUUsU0FBUzBFLElBQVQsS0FBa0IsR0FBM0MsR0FBaUQsY0FBakQsR0FBa0UxRSxTQUFTMEU7QUFMNUQsQ0FBWCxDQUFoQjs7QUFRQXBGLE9BQU9nRixTQUFQLEVBQWtCekMsV0FBbEI7O0FBRUEsSUFBSThDLGNBQWMsS0FBbEI7QUFDQS9ELEtBQUtnRSxnQkFBTCxDQUFzQixjQUF0QixFQUFzQyxZQUFZO0FBQ2hERCxnQkFBYyxJQUFkO0FBQ0QsQ0FGRDs7QUFJQSxTQUFTckIsU0FBVCxHQUFxQjtBQUNuQixNQUFJcUIsZUFBZSxDQUFDMUUsU0FBcEIsRUFBK0I7QUFDN0I7QUFDRDtBQUNELE1BQUlZLElBQUosRUFBVTtBQUNSekIsUUFBSTJDLElBQUosQ0FBUyx5QkFBVDtBQUNBO0FBQ0EsUUFBSThDLGFBQWEzRixtQkFBT0EsQ0FBQyxFQUFSLENBQWpCO0FBQ0EyRixlQUFXQyxJQUFYLENBQWdCLGtCQUFoQixFQUFvQy9ELFdBQXBDO0FBQ0EsUUFBSSxPQUFPSCxJQUFQLEtBQWdCLFdBQWhCLElBQStCQSxLQUFLVixNQUF4QyxFQUFnRDtBQUM5QztBQUNBVSxXQUFLZ0IsV0FBTCxDQUFpQixxQkFBcUJiLFdBQXRDLEVBQW1ELEdBQW5EO0FBQ0Q7QUFDRixHQVRELE1BU087QUFDTCxRQUFJZ0UsYUFBYW5FLElBQWpCO0FBQ0E7QUFDQSxRQUFJb0UsYUFBYXBFLEtBQUtxRSxXQUFMLENBQWlCLFlBQVk7QUFDNUMsVUFBSUYsV0FBVzNFLFFBQVgsQ0FBb0JpRSxRQUFwQixLQUFpQyxRQUFyQyxFQUErQztBQUM3QztBQUNBYSxvQkFBWUgsVUFBWixFQUF3QkMsVUFBeEI7QUFDRCxPQUhELE1BR087QUFDTEQscUJBQWFBLFdBQVdJLE1BQXhCO0FBQ0EsWUFBSUosV0FBV0ksTUFBWCxLQUFzQkosVUFBMUIsRUFBc0M7QUFDcEM7QUFDQUcsc0JBQVlILFVBQVosRUFBd0JDLFVBQXhCO0FBQ0Q7QUFDRjtBQUNGLEtBWGdCLENBQWpCO0FBWUQ7O0FBRUQsV0FBU0UsV0FBVCxDQUFxQkgsVUFBckIsRUFBaUNDLFVBQWpDLEVBQTZDO0FBQzNDSSxrQkFBY0osVUFBZDtBQUNBNUYsUUFBSTJDLElBQUosQ0FBUyxpQ0FBVDtBQUNBZ0QsZUFBVzNFLFFBQVgsQ0FBb0JvRCxNQUFwQjtBQUNEO0FBQ0YsQyIsImZpbGUiOiIzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxuLyogZ2xvYmFsIF9fcmVzb3VyY2VRdWVyeSBXb3JrZXJHbG9iYWxTY29wZSBzZWxmICovXHJcbi8qIGVzbGludCBwcmVmZXItZGVzdHJ1Y3R1cmluZzogb2ZmICovXHJcblxyXG52YXIgdXJsID0gcmVxdWlyZSgndXJsJyk7XHJcbnZhciBzdHJpcEFuc2kgPSByZXF1aXJlKCdzdHJpcC1hbnNpJyk7XHJcbnZhciBsb2cgPSByZXF1aXJlKCdsb2dsZXZlbCcpLmdldExvZ2dlcignd2VicGFjay1kZXYtc2VydmVyJyk7XHJcbnZhciBzb2NrZXQgPSByZXF1aXJlKCcuL3NvY2tldCcpO1xyXG52YXIgb3ZlcmxheSA9IHJlcXVpcmUoJy4vb3ZlcmxheScpO1xyXG5cclxuZnVuY3Rpb24gZ2V0Q3VycmVudFNjcmlwdFNvdXJjZSgpIHtcclxuICAvLyBgZG9jdW1lbnQuY3VycmVudFNjcmlwdGAgaXMgdGhlIG1vc3QgYWNjdXJhdGUgd2F5IHRvIGZpbmQgdGhlIGN1cnJlbnQgc2NyaXB0LFxyXG4gIC8vIGJ1dCBpcyBub3Qgc3VwcG9ydGVkIGluIGFsbCBicm93c2Vycy5cclxuICBpZiAoZG9jdW1lbnQuY3VycmVudFNjcmlwdCkge1xyXG4gICAgcmV0dXJuIGRvY3VtZW50LmN1cnJlbnRTY3JpcHQuZ2V0QXR0cmlidXRlKCdzcmMnKTtcclxuICB9XHJcbiAgLy8gRmFsbCBiYWNrIHRvIGdldHRpbmcgYWxsIHNjcmlwdHMgaW4gdGhlIGRvY3VtZW50LlxyXG4gIHZhciBzY3JpcHRFbGVtZW50cyA9IGRvY3VtZW50LnNjcmlwdHMgfHwgW107XHJcbiAgdmFyIGN1cnJlbnRTY3JpcHQgPSBzY3JpcHRFbGVtZW50c1tzY3JpcHRFbGVtZW50cy5sZW5ndGggLSAxXTtcclxuICBpZiAoY3VycmVudFNjcmlwdCkge1xyXG4gICAgcmV0dXJuIGN1cnJlbnRTY3JpcHQuZ2V0QXR0cmlidXRlKCdzcmMnKTtcclxuICB9XHJcbiAgLy8gRmFpbCBhcyB0aGVyZSB3YXMgbm8gc2NyaXB0IHRvIHVzZS5cclxuICB0aHJvdyBuZXcgRXJyb3IoJ1tXRFNdIEZhaWxlZCB0byBnZXQgY3VycmVudCBzY3JpcHQgc291cmNlLicpO1xyXG59XHJcblxyXG52YXIgdXJsUGFydHMgPSB2b2lkIDA7XHJcbnZhciBob3RSZWxvYWQgPSB0cnVlO1xyXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICB2YXIgcXMgPSB3aW5kb3cubG9jYXRpb24uc2VhcmNoLnRvTG93ZXJDYXNlKCk7XHJcbiAgaG90UmVsb2FkID0gcXMuaW5kZXhPZignaG90cmVsb2FkPWZhbHNlJykgPT09IC0xO1xyXG59XHJcbmlmICh0eXBlb2YgX19yZXNvdXJjZVF1ZXJ5ID09PSAnc3RyaW5nJyAmJiBfX3Jlc291cmNlUXVlcnkpIHtcclxuICAvLyBJZiB0aGlzIGJ1bmRsZSBpcyBpbmxpbmVkLCB1c2UgdGhlIHJlc291cmNlIHF1ZXJ5IHRvIGdldCB0aGUgY29ycmVjdCB1cmwuXHJcbiAgdXJsUGFydHMgPSB1cmwucGFyc2UoX19yZXNvdXJjZVF1ZXJ5LnN1YnN0cigxKSk7XHJcbn0gZWxzZSB7XHJcbiAgLy8gRWxzZSwgZ2V0IHRoZSB1cmwgZnJvbSB0aGUgPHNjcmlwdD4gdGhpcyBmaWxlIHdhcyBjYWxsZWQgd2l0aC5cclxuICB2YXIgc2NyaXB0SG9zdCA9IGdldEN1cnJlbnRTY3JpcHRTb3VyY2UoKTtcclxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1lc2NhcGVcclxuICBzY3JpcHRIb3N0ID0gc2NyaXB0SG9zdC5yZXBsYWNlKC9cXC9bXlxcL10rJC8sICcnKTtcclxuICB1cmxQYXJ0cyA9IHVybC5wYXJzZShzY3JpcHRIb3N0IHx8ICcvJywgZmFsc2UsIHRydWUpO1xyXG59XHJcblxyXG5pZiAoIXVybFBhcnRzLnBvcnQgfHwgdXJsUGFydHMucG9ydCA9PT0gJzAnKSB7XHJcbiAgdXJsUGFydHMucG9ydCA9IHNlbGYubG9jYXRpb24ucG9ydDtcclxufVxyXG5cclxudmFyIF9ob3QgPSBmYWxzZTtcclxudmFyIGluaXRpYWwgPSB0cnVlO1xyXG52YXIgY3VycmVudEhhc2ggPSAnJztcclxudmFyIHVzZVdhcm5pbmdPdmVybGF5ID0gZmFsc2U7XHJcbnZhciB1c2VFcnJvck92ZXJsYXkgPSBmYWxzZTtcclxudmFyIHVzZVByb2dyZXNzID0gZmFsc2U7XHJcblxyXG52YXIgSU5GTyA9ICdpbmZvJztcclxudmFyIFdBUk5JTkcgPSAnd2FybmluZyc7XHJcbnZhciBFUlJPUiA9ICdlcnJvcic7XHJcbnZhciBOT05FID0gJ25vbmUnO1xyXG5cclxuLy8gU2V0IHRoZSBkZWZhdWx0IGxvZyBsZXZlbFxyXG5sb2cuc2V0RGVmYXVsdExldmVsKElORk8pO1xyXG5cclxuLy8gU2VuZCBtZXNzYWdlcyB0byB0aGUgb3V0c2lkZSwgc28gcGx1Z2lucyBjYW4gY29uc3VtZSBpdC5cclxuZnVuY3Rpb24gc2VuZE1zZyh0eXBlLCBkYXRhKSB7XHJcbiAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiAodHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlID09PSAndW5kZWZpbmVkJyB8fCAhKHNlbGYgaW5zdGFuY2VvZiBXb3JrZXJHbG9iYWxTY29wZSkpKSB7XHJcbiAgICBzZWxmLnBvc3RNZXNzYWdlKHtcclxuICAgICAgdHlwZTogJ3dlYnBhY2snICsgdHlwZSxcclxuICAgICAgZGF0YTogZGF0YVxyXG4gICAgfSwgJyonKTtcclxuICB9XHJcbn1cclxuXHJcbnZhciBvblNvY2tldE1zZyA9IHtcclxuICBob3Q6IGZ1bmN0aW9uIGhvdCgpIHtcclxuICAgIF9ob3QgPSB0cnVlO1xyXG4gICAgbG9nLmluZm8oJ1tXRFNdIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnQgZW5hYmxlZC4nKTtcclxuICB9LFxyXG4gIGludmFsaWQ6IGZ1bmN0aW9uIGludmFsaWQoKSB7XHJcbiAgICBsb2cuaW5mbygnW1dEU10gQXBwIHVwZGF0ZWQuIFJlY29tcGlsaW5nLi4uJyk7XHJcbiAgICAvLyBmaXhlcyAjMTA0Mi4gb3ZlcmxheSBkb2Vzbid0IGNsZWFyIGlmIGVycm9ycyBhcmUgZml4ZWQgYnV0IHdhcm5pbmdzIHJlbWFpbi5cclxuICAgIGlmICh1c2VXYXJuaW5nT3ZlcmxheSB8fCB1c2VFcnJvck92ZXJsYXkpIG92ZXJsYXkuY2xlYXIoKTtcclxuICAgIHNlbmRNc2coJ0ludmFsaWQnKTtcclxuICB9LFxyXG4gIGhhc2g6IGZ1bmN0aW9uIGhhc2goX2hhc2gpIHtcclxuICAgIGN1cnJlbnRIYXNoID0gX2hhc2g7XHJcbiAgfSxcclxuXHJcbiAgJ3N0aWxsLW9rJzogZnVuY3Rpb24gc3RpbGxPaygpIHtcclxuICAgIGxvZy5pbmZvKCdbV0RTXSBOb3RoaW5nIGNoYW5nZWQuJyk7XHJcbiAgICBpZiAodXNlV2FybmluZ092ZXJsYXkgfHwgdXNlRXJyb3JPdmVybGF5KSBvdmVybGF5LmNsZWFyKCk7XHJcbiAgICBzZW5kTXNnKCdTdGlsbE9rJyk7XHJcbiAgfSxcclxuICAnbG9nLWxldmVsJzogZnVuY3Rpb24gbG9nTGV2ZWwobGV2ZWwpIHtcclxuICAgIHZhciBob3RDdHggPSByZXF1aXJlLmNvbnRleHQoJ3dlYnBhY2svaG90JywgZmFsc2UsIC9eXFwuXFwvbG9nJC8pO1xyXG4gICAgaWYgKGhvdEN0eC5rZXlzKCkuaW5kZXhPZignLi9sb2cnKSAhPT0gLTEpIHtcclxuICAgICAgaG90Q3R4KCcuL2xvZycpLnNldExvZ0xldmVsKGxldmVsKTtcclxuICAgIH1cclxuICAgIHN3aXRjaCAobGV2ZWwpIHtcclxuICAgICAgY2FzZSBJTkZPOlxyXG4gICAgICBjYXNlIEVSUk9SOlxyXG4gICAgICAgIGxvZy5zZXRMZXZlbChsZXZlbCk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgV0FSTklORzpcclxuICAgICAgICAvLyBsb2dsZXZlbCdzIHdhcm5pbmcgbmFtZSBpcyBkaWZmZXJlbnQgZnJvbSB3ZWJwYWNrJ3NcclxuICAgICAgICBsb2cuc2V0TGV2ZWwoJ3dhcm4nKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBOT05FOlxyXG4gICAgICAgIGxvZy5kaXNhYmxlQWxsKCk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgbG9nLmVycm9yKCdbV0RTXSBVbmtub3duIGNsaWVudExvZ0xldmVsIFxcJycgKyBsZXZlbCArICdcXCcnKTtcclxuICAgIH1cclxuICB9LFxyXG4gIG92ZXJsYXk6IGZ1bmN0aW9uIG92ZXJsYXkodmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xyXG4gICAgICAgIHVzZVdhcm5pbmdPdmVybGF5ID0gZmFsc2U7XHJcbiAgICAgICAgdXNlRXJyb3JPdmVybGF5ID0gdmFsdWU7XHJcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcclxuICAgICAgICB1c2VXYXJuaW5nT3ZlcmxheSA9IHZhbHVlLndhcm5pbmdzO1xyXG4gICAgICAgIHVzZUVycm9yT3ZlcmxheSA9IHZhbHVlLmVycm9ycztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sXHJcbiAgcHJvZ3Jlc3M6IGZ1bmN0aW9uIHByb2dyZXNzKF9wcm9ncmVzcykge1xyXG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgdXNlUHJvZ3Jlc3MgPSBfcHJvZ3Jlc3M7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgJ3Byb2dyZXNzLXVwZGF0ZSc6IGZ1bmN0aW9uIHByb2dyZXNzVXBkYXRlKGRhdGEpIHtcclxuICAgIGlmICh1c2VQcm9ncmVzcykgbG9nLmluZm8oJ1tXRFNdICcgKyBkYXRhLnBlcmNlbnQgKyAnJSAtICcgKyBkYXRhLm1zZyArICcuJyk7XHJcbiAgICBzZW5kTXNnKCdQcm9ncmVzcycsIGRhdGEpO1xyXG4gIH0sXHJcbiAgb2s6IGZ1bmN0aW9uIG9rKCkge1xyXG4gICAgc2VuZE1zZygnT2snKTtcclxuICAgIGlmICh1c2VXYXJuaW5nT3ZlcmxheSB8fCB1c2VFcnJvck92ZXJsYXkpIG92ZXJsYXkuY2xlYXIoKTtcclxuICAgIGlmIChpbml0aWFsKSByZXR1cm4gaW5pdGlhbCA9IGZhbHNlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJldHVybi1hc3NpZ25cclxuICAgIHJlbG9hZEFwcCgpO1xyXG4gIH0sXHJcblxyXG4gICdjb250ZW50LWNoYW5nZWQnOiBmdW5jdGlvbiBjb250ZW50Q2hhbmdlZCgpIHtcclxuICAgIGxvZy5pbmZvKCdbV0RTXSBDb250ZW50IGJhc2UgY2hhbmdlZC4gUmVsb2FkaW5nLi4uJyk7XHJcbiAgICBzZWxmLmxvY2F0aW9uLnJlbG9hZCgpO1xyXG4gIH0sXHJcbiAgd2FybmluZ3M6IGZ1bmN0aW9uIHdhcm5pbmdzKF93YXJuaW5ncykge1xyXG4gICAgbG9nLndhcm4oJ1tXRFNdIFdhcm5pbmdzIHdoaWxlIGNvbXBpbGluZy4nKTtcclxuICAgIHZhciBzdHJpcHBlZFdhcm5pbmdzID0gX3dhcm5pbmdzLm1hcChmdW5jdGlvbiAod2FybmluZykge1xyXG4gICAgICByZXR1cm4gc3RyaXBBbnNpKHdhcm5pbmcpO1xyXG4gICAgfSk7XHJcbiAgICBzZW5kTXNnKCdXYXJuaW5ncycsIHN0cmlwcGVkV2FybmluZ3MpO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpcHBlZFdhcm5pbmdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGxvZy53YXJuKHN0cmlwcGVkV2FybmluZ3NbaV0pO1xyXG4gICAgfVxyXG4gICAgaWYgKHVzZVdhcm5pbmdPdmVybGF5KSBvdmVybGF5LnNob3dNZXNzYWdlKF93YXJuaW5ncyk7XHJcblxyXG4gICAgaWYgKGluaXRpYWwpIHJldHVybiBpbml0aWFsID0gZmFsc2U7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmV0dXJuLWFzc2lnblxyXG4gICAgcmVsb2FkQXBwKCk7XHJcbiAgfSxcclxuICBlcnJvcnM6IGZ1bmN0aW9uIGVycm9ycyhfZXJyb3JzKSB7XHJcbiAgICBsb2cuZXJyb3IoJ1tXRFNdIEVycm9ycyB3aGlsZSBjb21waWxpbmcuIFJlbG9hZCBwcmV2ZW50ZWQuJyk7XHJcbiAgICB2YXIgc3RyaXBwZWRFcnJvcnMgPSBfZXJyb3JzLm1hcChmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgcmV0dXJuIHN0cmlwQW5zaShlcnJvcik7XHJcbiAgICB9KTtcclxuICAgIHNlbmRNc2coJ0Vycm9ycycsIHN0cmlwcGVkRXJyb3JzKTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaXBwZWRFcnJvcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgbG9nLmVycm9yKHN0cmlwcGVkRXJyb3JzW2ldKTtcclxuICAgIH1cclxuICAgIGlmICh1c2VFcnJvck92ZXJsYXkpIG92ZXJsYXkuc2hvd01lc3NhZ2UoX2Vycm9ycyk7XHJcbiAgICBpbml0aWFsID0gZmFsc2U7XHJcbiAgfSxcclxuICBlcnJvcjogZnVuY3Rpb24gZXJyb3IoX2Vycm9yKSB7XHJcbiAgICBsb2cuZXJyb3IoX2Vycm9yKTtcclxuICB9LFxyXG4gIGNsb3NlOiBmdW5jdGlvbiBjbG9zZSgpIHtcclxuICAgIGxvZy5lcnJvcignW1dEU10gRGlzY29ubmVjdGVkIScpO1xyXG4gICAgc2VuZE1zZygnQ2xvc2UnKTtcclxuICB9XHJcbn07XHJcblxyXG52YXIgaG9zdG5hbWUgPSB1cmxQYXJ0cy5ob3N0bmFtZTtcclxudmFyIHByb3RvY29sID0gdXJsUGFydHMucHJvdG9jb2w7XHJcblxyXG4vLyBjaGVjayBpcHY0IGFuZCBpcHY2IGBhbGwgaG9zdG5hbWVgXHJcbmlmIChob3N0bmFtZSA9PT0gJzAuMC4wLjAnIHx8IGhvc3RuYW1lID09PSAnOjonKSB7XHJcbiAgLy8gd2h5IGRvIHdlIG5lZWQgdGhpcyBjaGVjaz9cclxuICAvLyBob3N0bmFtZSBuL2EgZm9yIGZpbGUgcHJvdG9jb2wgKGV4YW1wbGUsIHdoZW4gdXNpbmcgZWxlY3Ryb24sIGlvbmljKVxyXG4gIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2svd2VicGFjay1kZXYtc2VydmVyL3B1bGwvMzg0XHJcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcclxuICBpZiAoc2VsZi5sb2NhdGlvbi5ob3N0bmFtZSAmJiAhIX5zZWxmLmxvY2F0aW9uLnByb3RvY29sLmluZGV4T2YoJ2h0dHAnKSkge1xyXG4gICAgaG9zdG5hbWUgPSBzZWxmLmxvY2F0aW9uLmhvc3RuYW1lO1xyXG4gIH1cclxufVxyXG5cclxuLy8gYGhvc3RuYW1lYCBjYW4gYmUgZW1wdHkgd2hlbiB0aGUgc2NyaXB0IHBhdGggaXMgcmVsYXRpdmUuIEluIHRoYXQgY2FzZSwgc3BlY2lmeWluZ1xyXG4vLyBhIHByb3RvY29sIHdvdWxkIHJlc3VsdCBpbiBhbiBpbnZhbGlkIFVSTC5cclxuLy8gV2hlbiBodHRwcyBpcyB1c2VkIGluIHRoZSBhcHAsIHNlY3VyZSB3ZWJzb2NrZXRzIGFyZSBhbHdheXMgbmVjZXNzYXJ5XHJcbi8vIGJlY2F1c2UgdGhlIGJyb3dzZXIgZG9lc24ndCBhY2NlcHQgbm9uLXNlY3VyZSB3ZWJzb2NrZXRzLlxyXG5pZiAoaG9zdG5hbWUgJiYgKHNlbGYubG9jYXRpb24ucHJvdG9jb2wgPT09ICdodHRwczonIHx8IHVybFBhcnRzLmhvc3RuYW1lID09PSAnMC4wLjAuMCcpKSB7XHJcbiAgcHJvdG9jb2wgPSBzZWxmLmxvY2F0aW9uLnByb3RvY29sO1xyXG59XHJcblxyXG52YXIgc29ja2V0VXJsID0gdXJsLmZvcm1hdCh7XHJcbiAgcHJvdG9jb2w6IHByb3RvY29sLFxyXG4gIGF1dGg6IHVybFBhcnRzLmF1dGgsXHJcbiAgaG9zdG5hbWU6IGhvc3RuYW1lLFxyXG4gIHBvcnQ6IHVybFBhcnRzLnBvcnQsXHJcbiAgcGF0aG5hbWU6IHVybFBhcnRzLnBhdGggPT0gbnVsbCB8fCB1cmxQYXJ0cy5wYXRoID09PSAnLycgPyAnL3NvY2tqcy1ub2RlJyA6IHVybFBhcnRzLnBhdGhcclxufSk7XHJcblxyXG5zb2NrZXQoc29ja2V0VXJsLCBvblNvY2tldE1zZyk7XHJcblxyXG52YXIgaXNVbmxvYWRpbmcgPSBmYWxzZTtcclxuc2VsZi5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgaXNVbmxvYWRpbmcgPSB0cnVlO1xyXG59KTtcclxuXHJcbmZ1bmN0aW9uIHJlbG9hZEFwcCgpIHtcclxuICBpZiAoaXNVbmxvYWRpbmcgfHwgIWhvdFJlbG9hZCkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBpZiAoX2hvdCkge1xyXG4gICAgbG9nLmluZm8oJ1tXRFNdIEFwcCBob3QgdXBkYXRlLi4uJyk7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ2xvYmFsLXJlcXVpcmVcclxuICAgIHZhciBob3RFbWl0dGVyID0gcmVxdWlyZSgnd2VicGFjay9ob3QvZW1pdHRlcicpO1xyXG4gICAgaG90RW1pdHRlci5lbWl0KCd3ZWJwYWNrSG90VXBkYXRlJywgY3VycmVudEhhc2gpO1xyXG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmLndpbmRvdykge1xyXG4gICAgICAvLyBicm9hZGNhc3QgdXBkYXRlIHRvIHdpbmRvd1xyXG4gICAgICBzZWxmLnBvc3RNZXNzYWdlKCd3ZWJwYWNrSG90VXBkYXRlJyArIGN1cnJlbnRIYXNoLCAnKicpO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICB2YXIgcm9vdFdpbmRvdyA9IHNlbGY7XHJcbiAgICAvLyB1c2UgcGFyZW50IHdpbmRvdyBmb3IgcmVsb2FkIChpbiBjYXNlIHdlJ3JlIGluIGFuIGlmcmFtZSB3aXRoIG5vIHZhbGlkIHNyYylcclxuICAgIHZhciBpbnRlcnZhbElkID0gc2VsZi5zZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGlmIChyb290V2luZG93LmxvY2F0aW9uLnByb3RvY29sICE9PSAnYWJvdXQ6Jykge1xyXG4gICAgICAgIC8vIHJlbG9hZCBpbW1lZGlhdGVseSBpZiBwcm90b2NvbCBpcyB2YWxpZFxyXG4gICAgICAgIGFwcGx5UmVsb2FkKHJvb3RXaW5kb3csIGludGVydmFsSWQpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJvb3RXaW5kb3cgPSByb290V2luZG93LnBhcmVudDtcclxuICAgICAgICBpZiAocm9vdFdpbmRvdy5wYXJlbnQgPT09IHJvb3RXaW5kb3cpIHtcclxuICAgICAgICAgIC8vIGlmIHBhcmVudCBlcXVhbHMgY3VycmVudCB3aW5kb3cgd2UndmUgcmVhY2hlZCB0aGUgcm9vdCB3aGljaCB3b3VsZCBjb250aW51ZSBmb3JldmVyLCBzbyB0cmlnZ2VyIGEgcmVsb2FkIGFueXdheXNcclxuICAgICAgICAgIGFwcGx5UmVsb2FkKHJvb3RXaW5kb3csIGludGVydmFsSWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBhcHBseVJlbG9hZChyb290V2luZG93LCBpbnRlcnZhbElkKSB7XHJcbiAgICBjbGVhckludGVydmFsKGludGVydmFsSWQpO1xyXG4gICAgbG9nLmluZm8oJ1tXRFNdIEFwcCB1cGRhdGVkLiBSZWxvYWRpbmcuLi4nKTtcclxuICAgIHJvb3RXaW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XHJcbiAgfVxyXG59Il0sInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///3\\n\")},function(module,exports,__webpack_require__){\"use strict\";eval(\"// Copyright Joyent, Inc. and other Node contributors.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a\\n// copy of this software and associated documentation files (the\\n// \\\"Software\\\"), to deal in the Software without restriction, including\\n// without limitation the rights to use, copy, modify, merge, publish,\\n// distribute, sublicense, and/or sell copies of the Software, and to permit\\n// persons to whom the Software is furnished to do so, subject to the\\n// following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included\\n// in all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\\n\\n\\n\\nvar punycode = __webpack_require__(5);\\nvar util = __webpack_require__(7);\\n\\nexports.parse = urlParse;\\nexports.resolve = urlResolve;\\nexports.resolveObject = urlResolveObject;\\nexports.format = urlFormat;\\n\\nexports.Url = Url;\\n\\nfunction Url() {\\n  this.protocol = null;\\n  this.slashes = null;\\n  this.auth = null;\\n  this.host = null;\\n  this.port = null;\\n  this.hostname = null;\\n  this.hash = null;\\n  this.search = null;\\n  this.query = null;\\n  this.pathname = null;\\n  this.path = null;\\n  this.href = null;\\n}\\n\\n// Reference: RFC 3986, RFC 1808, RFC 2396\\n\\n// define these here so at least they only have to be\\n// compiled once on the first module load.\\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\\n    portPattern = /:[0-9]*$/,\\n\\n\\n// Special case for a simple path URL\\nsimplePathPattern = /^(\\\\/\\\\/?(?!\\\\/)[^\\\\?\\\\s]*)(\\\\?[^\\\\s]*)?$/,\\n\\n\\n// RFC 2396: characters reserved for delimiting URLs.\\n// We actually just auto-escape these.\\ndelims = ['<', '>', '\\\"', '`', ' ', '\\\\r', '\\\\n', '\\\\t'],\\n\\n\\n// RFC 2396: characters not allowed for various reasons.\\nunwise = ['{', '}', '|', '\\\\\\\\', '^', '`'].concat(delims),\\n\\n\\n// Allowed by RFCs, but cause of XSS attacks.  Always escape these.\\nautoEscape = ['\\\\''].concat(unwise),\\n\\n// Characters that are never ever allowed in a hostname.\\n// Note that any invalid chars are also handled, but these\\n// are the ones that are *expected* to be seen, so we fast-path\\n// them.\\nnonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\\n    hostEndingChars = ['/', '?', '#'],\\n    hostnameMaxLen = 255,\\n    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\\n    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\\n\\n// protocols that can allow \\\"unsafe\\\" and \\\"unwise\\\" chars.\\nunsafeProtocol = {\\n  'javascript': true,\\n  'javascript:': true\\n},\\n\\n// protocols that never have a hostname.\\nhostlessProtocol = {\\n  'javascript': true,\\n  'javascript:': true\\n},\\n\\n// protocols that always contain a // bit.\\nslashedProtocol = {\\n  'http': true,\\n  'https': true,\\n  'ftp': true,\\n  'gopher': true,\\n  'file': true,\\n  'http:': true,\\n  'https:': true,\\n  'ftp:': true,\\n  'gopher:': true,\\n  'file:': true\\n},\\n    querystring = __webpack_require__(8);\\n\\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\\n  if (url && util.isObject(url) && url instanceof Url) return url;\\n\\n  var u = new Url();\\n  u.parse(url, parseQueryString, slashesDenoteHost);\\n  return u;\\n}\\n\\nUrl.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {\\n  if (!util.isString(url)) {\\n    throw new TypeError(\\\"Parameter 'url' must be a string, not \\\" + typeof url);\\n  }\\n\\n  // Copy chrome, IE, opera backslash-handling behavior.\\n  // Back slashes before the query string get converted to forward slashes\\n  // See: https://code.google.com/p/chromium/issues/detail?id=25916\\n  var queryIndex = url.indexOf('?'),\\n      splitter = queryIndex !== -1 && queryIndex < url.indexOf('#') ? '?' : '#',\\n      uSplit = url.split(splitter),\\n      slashRegex = /\\\\\\\\/g;\\n  uSplit[0] = uSplit[0].replace(slashRegex, '/');\\n  url = uSplit.join(splitter);\\n\\n  var rest = url;\\n\\n  // trim before proceeding.\\n  // This is to support parse stuff like \\\"  http://foo.com  \\\\n\\\"\\n  rest = rest.trim();\\n\\n  if (!slashesDenoteHost && url.split('#').length === 1) {\\n    // Try fast path regexp\\n    var simplePath = simplePathPattern.exec(rest);\\n    if (simplePath) {\\n      this.path = rest;\\n      this.href = rest;\\n      this.pathname = simplePath[1];\\n      if (simplePath[2]) {\\n        this.search = simplePath[2];\\n        if (parseQueryString) {\\n          this.query = querystring.parse(this.search.substr(1));\\n        } else {\\n          this.query = this.search.substr(1);\\n        }\\n      } else if (parseQueryString) {\\n        this.search = '';\\n        this.query = {};\\n      }\\n      return this;\\n    }\\n  }\\n\\n  var proto = protocolPattern.exec(rest);\\n  if (proto) {\\n    proto = proto[0];\\n    var lowerProto = proto.toLowerCase();\\n    this.protocol = lowerProto;\\n    rest = rest.substr(proto.length);\\n  }\\n\\n  // figure out if it's got a host\\n  // user@server is *always* interpreted as a hostname, and url\\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\\n  // how the browser resolves relative URLs.\\n  if (slashesDenoteHost || proto || rest.match(/^\\\\/\\\\/[^@\\\\/]+@[^@\\\\/]+/)) {\\n    var slashes = rest.substr(0, 2) === '//';\\n    if (slashes && !(proto && hostlessProtocol[proto])) {\\n      rest = rest.substr(2);\\n      this.slashes = true;\\n    }\\n  }\\n\\n  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {\\n\\n    // there's a hostname.\\n    // the first instance of /, ?, ;, or # ends the host.\\n    //\\n    // If there is an @ in the hostname, then non-host chars *are* allowed\\n    // to the left of the last @ sign, unless some host-ending character\\n    // comes *before* the @-sign.\\n    // URLs are obnoxious.\\n    //\\n    // ex:\\n    // http://a@b@c/ => user:a@b host:c\\n    // http://a@b?@c => user:a host:c path:/?@c\\n\\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\\n    // Review our test case against browsers more comprehensively.\\n\\n    // find the first instance of any hostEndingChars\\n    var hostEnd = -1;\\n    for (var i = 0; i < hostEndingChars.length; i++) {\\n      var hec = rest.indexOf(hostEndingChars[i]);\\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;\\n    }\\n\\n    // at this point, either we have an explicit point where the\\n    // auth portion cannot go past, or the last @ char is the decider.\\n    var auth, atSign;\\n    if (hostEnd === -1) {\\n      // atSign can be anywhere.\\n      atSign = rest.lastIndexOf('@');\\n    } else {\\n      // atSign must be in auth portion.\\n      // http://a@b/c@d => host:b auth:a path:/c@d\\n      atSign = rest.lastIndexOf('@', hostEnd);\\n    }\\n\\n    // Now we have a portion which is definitely the auth.\\n    // Pull that off.\\n    if (atSign !== -1) {\\n      auth = rest.slice(0, atSign);\\n      rest = rest.slice(atSign + 1);\\n      this.auth = decodeURIComponent(auth);\\n    }\\n\\n    // the host is the remaining to the left of the first non-host char\\n    hostEnd = -1;\\n    for (var i = 0; i < nonHostChars.length; i++) {\\n      var hec = rest.indexOf(nonHostChars[i]);\\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;\\n    }\\n    // if we still have not hit it, then the entire thing is a host.\\n    if (hostEnd === -1) hostEnd = rest.length;\\n\\n    this.host = rest.slice(0, hostEnd);\\n    rest = rest.slice(hostEnd);\\n\\n    // pull out port.\\n    this.parseHost();\\n\\n    // we've indicated that there is a hostname,\\n    // so even if it's empty, it has to be present.\\n    this.hostname = this.hostname || '';\\n\\n    // if hostname begins with [ and ends with ]\\n    // assume that it's an IPv6 address.\\n    var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';\\n\\n    // validate a little.\\n    if (!ipv6Hostname) {\\n      var hostparts = this.hostname.split(/\\\\./);\\n      for (var i = 0, l = hostparts.length; i < l; i++) {\\n        var part = hostparts[i];\\n        if (!part) continue;\\n        if (!part.match(hostnamePartPattern)) {\\n          var newpart = '';\\n          for (var j = 0, k = part.length; j < k; j++) {\\n            if (part.charCodeAt(j) > 127) {\\n              // we replace non-ASCII char with a temporary placeholder\\n              // we need this to make sure size of hostname is not\\n              // broken by replacing non-ASCII by nothing\\n              newpart += 'x';\\n            } else {\\n              newpart += part[j];\\n            }\\n          }\\n          // we test again with ASCII char only\\n          if (!newpart.match(hostnamePartPattern)) {\\n            var validParts = hostparts.slice(0, i);\\n            var notHost = hostparts.slice(i + 1);\\n            var bit = part.match(hostnamePartStart);\\n            if (bit) {\\n              validParts.push(bit[1]);\\n              notHost.unshift(bit[2]);\\n            }\\n            if (notHost.length) {\\n              rest = '/' + notHost.join('.') + rest;\\n            }\\n            this.hostname = validParts.join('.');\\n            break;\\n          }\\n        }\\n      }\\n    }\\n\\n    if (this.hostname.length > hostnameMaxLen) {\\n      this.hostname = '';\\n    } else {\\n      // hostnames are always lower case.\\n      this.hostname = this.hostname.toLowerCase();\\n    }\\n\\n    if (!ipv6Hostname) {\\n      // IDNA Support: Returns a punycoded representation of \\\"domain\\\".\\n      // It only converts parts of the domain name that\\n      // have non-ASCII characters, i.e. it doesn't matter if\\n      // you call it with a domain that already is ASCII-only.\\n      this.hostname = punycode.toASCII(this.hostname);\\n    }\\n\\n    var p = this.port ? ':' + this.port : '';\\n    var h = this.hostname || '';\\n    this.host = h + p;\\n    this.href += this.host;\\n\\n    // strip [ and ] from the hostname\\n    // the host field still retains them, though\\n    if (ipv6Hostname) {\\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\\n      if (rest[0] !== '/') {\\n        rest = '/' + rest;\\n      }\\n    }\\n  }\\n\\n  // now rest is set to the post-host stuff.\\n  // chop off any delim chars.\\n  if (!unsafeProtocol[lowerProto]) {\\n\\n    // First, make 100% sure that any \\\"autoEscape\\\" chars get\\n    // escaped, even if encodeURIComponent doesn't think they\\n    // need to be.\\n    for (var i = 0, l = autoEscape.length; i < l; i++) {\\n      var ae = autoEscape[i];\\n      if (rest.indexOf(ae) === -1) continue;\\n      var esc = encodeURIComponent(ae);\\n      if (esc === ae) {\\n        esc = escape(ae);\\n      }\\n      rest = rest.split(ae).join(esc);\\n    }\\n  }\\n\\n  // chop off from the tail first.\\n  var hash = rest.indexOf('#');\\n  if (hash !== -1) {\\n    // got a fragment string.\\n    this.hash = rest.substr(hash);\\n    rest = rest.slice(0, hash);\\n  }\\n  var qm = rest.indexOf('?');\\n  if (qm !== -1) {\\n    this.search = rest.substr(qm);\\n    this.query = rest.substr(qm + 1);\\n    if (parseQueryString) {\\n      this.query = querystring.parse(this.query);\\n    }\\n    rest = rest.slice(0, qm);\\n  } else if (parseQueryString) {\\n    // no query string, but parseQueryString still requested\\n    this.search = '';\\n    this.query = {};\\n  }\\n  if (rest) this.pathname = rest;\\n  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {\\n    this.pathname = '/';\\n  }\\n\\n  //to support http.request\\n  if (this.pathname || this.search) {\\n    var p = this.pathname || '';\\n    var s = this.search || '';\\n    this.path = p + s;\\n  }\\n\\n  // finally, reconstruct the href based on what has been validated.\\n  this.href = this.format();\\n  return this;\\n};\\n\\n// format a parsed object into a url string\\nfunction urlFormat(obj) {\\n  // ensure it's an object, and not a string url.\\n  // If it's an obj, this is a no-op.\\n  // this way, you can call url_format() on strings\\n  // to clean up potentially wonky urls.\\n  if (util.isString(obj)) obj = urlParse(obj);\\n  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\\n  return obj.format();\\n}\\n\\nUrl.prototype.format = function () {\\n  var auth = this.auth || '';\\n  if (auth) {\\n    auth = encodeURIComponent(auth);\\n    auth = auth.replace(/%3A/i, ':');\\n    auth += '@';\\n  }\\n\\n  var protocol = this.protocol || '',\\n      pathname = this.pathname || '',\\n      hash = this.hash || '',\\n      host = false,\\n      query = '';\\n\\n  if (this.host) {\\n    host = auth + this.host;\\n  } else if (this.hostname) {\\n    host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');\\n    if (this.port) {\\n      host += ':' + this.port;\\n    }\\n  }\\n\\n  if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {\\n    query = querystring.stringify(this.query);\\n  }\\n\\n  var search = this.search || query && '?' + query || '';\\n\\n  if (protocol && protocol.substr(-1) !== ':') protocol += ':';\\n\\n  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\\n  // unless they had them to begin with.\\n  if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {\\n    host = '//' + (host || '');\\n    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\\n  } else if (!host) {\\n    host = '';\\n  }\\n\\n  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\\n  if (search && search.charAt(0) !== '?') search = '?' + search;\\n\\n  pathname = pathname.replace(/[?#]/g, function (match) {\\n    return encodeURIComponent(match);\\n  });\\n  search = search.replace('#', '%23');\\n\\n  return protocol + host + pathname + search + hash;\\n};\\n\\nfunction urlResolve(source, relative) {\\n  return urlParse(source, false, true).resolve(relative);\\n}\\n\\nUrl.prototype.resolve = function (relative) {\\n  return this.resolveObject(urlParse(relative, false, true)).format();\\n};\\n\\nfunction urlResolveObject(source, relative) {\\n  if (!source) return relative;\\n  return urlParse(source, false, true).resolveObject(relative);\\n}\\n\\nUrl.prototype.resolveObject = function (relative) {\\n  if (util.isString(relative)) {\\n    var rel = new Url();\\n    rel.parse(relative, false, true);\\n    relative = rel;\\n  }\\n\\n  var result = new Url();\\n  var tkeys = Object.keys(this);\\n  for (var tk = 0; tk < tkeys.length; tk++) {\\n    var tkey = tkeys[tk];\\n    result[tkey] = this[tkey];\\n  }\\n\\n  // hash is always overridden, no matter what.\\n  // even href=\\\"\\\" will remove it.\\n  result.hash = relative.hash;\\n\\n  // if the relative url is empty, then there's nothing left to do here.\\n  if (relative.href === '') {\\n    result.href = result.format();\\n    return result;\\n  }\\n\\n  // hrefs like //foo/bar always cut to the protocol.\\n  if (relative.slashes && !relative.protocol) {\\n    // take everything except the protocol from relative\\n    var rkeys = Object.keys(relative);\\n    for (var rk = 0; rk < rkeys.length; rk++) {\\n      var rkey = rkeys[rk];\\n      if (rkey !== 'protocol') result[rkey] = relative[rkey];\\n    }\\n\\n    //urlParse appends trailing / to urls like http://www.example.com\\n    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {\\n      result.path = result.pathname = '/';\\n    }\\n\\n    result.href = result.format();\\n    return result;\\n  }\\n\\n  if (relative.protocol && relative.protocol !== result.protocol) {\\n    // if it's a known url protocol, then changing\\n    // the protocol does weird things\\n    // first, if it's not file:, then we MUST have a host,\\n    // and if there was a path\\n    // to begin with, then we MUST have a path.\\n    // if it is file:, then the host is dropped,\\n    // because that's known to be hostless.\\n    // anything else is assumed to be absolute.\\n    if (!slashedProtocol[relative.protocol]) {\\n      var keys = Object.keys(relative);\\n      for (var v = 0; v < keys.length; v++) {\\n        var k = keys[v];\\n        result[k] = relative[k];\\n      }\\n      result.href = result.format();\\n      return result;\\n    }\\n\\n    result.protocol = relative.protocol;\\n    if (!relative.host && !hostlessProtocol[relative.protocol]) {\\n      var relPath = (relative.pathname || '').split('/');\\n      while (relPath.length && !(relative.host = relPath.shift()));\\n      if (!relative.host) relative.host = '';\\n      if (!relative.hostname) relative.hostname = '';\\n      if (relPath[0] !== '') relPath.unshift('');\\n      if (relPath.length < 2) relPath.unshift('');\\n      result.pathname = relPath.join('/');\\n    } else {\\n      result.pathname = relative.pathname;\\n    }\\n    result.search = relative.search;\\n    result.query = relative.query;\\n    result.host = relative.host || '';\\n    result.auth = relative.auth;\\n    result.hostname = relative.hostname || relative.host;\\n    result.port = relative.port;\\n    // to support http.request\\n    if (result.pathname || result.search) {\\n      var p = result.pathname || '';\\n      var s = result.search || '';\\n      result.path = p + s;\\n    }\\n    result.slashes = result.slashes || relative.slashes;\\n    result.href = result.format();\\n    return result;\\n  }\\n\\n  var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/',\\n      isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === '/',\\n      mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname,\\n      removeAllDots = mustEndAbs,\\n      srcPath = result.pathname && result.pathname.split('/') || [],\\n      relPath = relative.pathname && relative.pathname.split('/') || [],\\n      psychotic = result.protocol && !slashedProtocol[result.protocol];\\n\\n  // if the url is a non-slashed url, then relative\\n  // links like ../.. should be able\\n  // to crawl up to the hostname, as well.  This is strange.\\n  // result.protocol has already been set by now.\\n  // Later on, put the first path part into the host field.\\n  if (psychotic) {\\n    result.hostname = '';\\n    result.port = null;\\n    if (result.host) {\\n      if (srcPath[0] === '') srcPath[0] = result.host;else srcPath.unshift(result.host);\\n    }\\n    result.host = '';\\n    if (relative.protocol) {\\n      relative.hostname = null;\\n      relative.port = null;\\n      if (relative.host) {\\n        if (relPath[0] === '') relPath[0] = relative.host;else relPath.unshift(relative.host);\\n      }\\n      relative.host = null;\\n    }\\n    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\\n  }\\n\\n  if (isRelAbs) {\\n    // it's absolute.\\n    result.host = relative.host || relative.host === '' ? relative.host : result.host;\\n    result.hostname = relative.hostname || relative.hostname === '' ? relative.hostname : result.hostname;\\n    result.search = relative.search;\\n    result.query = relative.query;\\n    srcPath = relPath;\\n    // fall through to the dot-handling below.\\n  } else if (relPath.length) {\\n    // it's relative\\n    // throw away the existing file, and take the new path instead.\\n    if (!srcPath) srcPath = [];\\n    srcPath.pop();\\n    srcPath = srcPath.concat(relPath);\\n    result.search = relative.search;\\n    result.query = relative.query;\\n  } else if (!util.isNullOrUndefined(relative.search)) {\\n    // just pull out the search.\\n    // like href='?foo'.\\n    // Put this after the other two cases because it simplifies the booleans\\n    if (psychotic) {\\n      result.hostname = result.host = srcPath.shift();\\n      //occationaly the auth can get stuck only in host\\n      //this especially happens in cases like\\n      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\\n      var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;\\n      if (authInHost) {\\n        result.auth = authInHost.shift();\\n        result.host = result.hostname = authInHost.shift();\\n      }\\n    }\\n    result.search = relative.search;\\n    result.query = relative.query;\\n    //to support http.request\\n    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\\n      result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');\\n    }\\n    result.href = result.format();\\n    return result;\\n  }\\n\\n  if (!srcPath.length) {\\n    // no path at all.  easy.\\n    // we've already handled the other stuff above.\\n    result.pathname = null;\\n    //to support http.request\\n    if (result.search) {\\n      result.path = '/' + result.search;\\n    } else {\\n      result.path = null;\\n    }\\n    result.href = result.format();\\n    return result;\\n  }\\n\\n  // if a url ENDs in . or .., then it must get a trailing slash.\\n  // however, if it ends in anything else non-slashy,\\n  // then it must NOT get a trailing slash.\\n  var last = srcPath.slice(-1)[0];\\n  var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === '.' || last === '..') || last === '';\\n\\n  // strip single dots, resolve double dots to parent dir\\n  // if the path tries to go above the root, `up` ends up > 0\\n  var up = 0;\\n  for (var i = srcPath.length; i >= 0; i--) {\\n    last = srcPath[i];\\n    if (last === '.') {\\n      srcPath.splice(i, 1);\\n    } else if (last === '..') {\\n      srcPath.splice(i, 1);\\n      up++;\\n    } else if (up) {\\n      srcPath.splice(i, 1);\\n      up--;\\n    }\\n  }\\n\\n  // if the path is allowed to go above the root, restore leading ..s\\n  if (!mustEndAbs && !removeAllDots) {\\n    for (; up--; up) {\\n      srcPath.unshift('..');\\n    }\\n  }\\n\\n  if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\\n    srcPath.unshift('');\\n  }\\n\\n  if (hasTrailingSlash && srcPath.join('/').substr(-1) !== '/') {\\n    srcPath.push('');\\n  }\\n\\n  var isAbsolute = srcPath[0] === '' || srcPath[0] && srcPath[0].charAt(0) === '/';\\n\\n  // put the host back\\n  if (psychotic) {\\n    result.hostname = result.host = isAbsolute ? '' : srcPath.length ? srcPath.shift() : '';\\n    //occationaly the auth can get stuck only in host\\n    //this especially happens in cases like\\n    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\\n    var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;\\n    if (authInHost) {\\n      result.auth = authInHost.shift();\\n      result.host = result.hostname = authInHost.shift();\\n    }\\n  }\\n\\n  mustEndAbs = mustEndAbs || result.host && srcPath.length;\\n\\n  if (mustEndAbs && !isAbsolute) {\\n    srcPath.unshift('');\\n  }\\n\\n  if (!srcPath.length) {\\n    result.pathname = null;\\n    result.path = null;\\n  } else {\\n    result.pathname = srcPath.join('/');\\n  }\\n\\n  //to support request.http\\n  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\\n    result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');\\n  }\\n  result.auth = relative.auth || result.auth;\\n  result.slashes = result.slashes || relative.slashes;\\n  result.href = result.format();\\n  return result;\\n};\\n\\nUrl.prototype.parseHost = function () {\\n  var host = this.host;\\n  var port = portPattern.exec(host);\\n  if (port) {\\n    port = port[0];\\n    if (port !== ':') {\\n      this.port = port.substr(1);\\n    }\\n    host = host.substr(0, host.length - port.length);\\n  }\\n  if (host) this.hostname = host;\\n};//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXJsL3VybC5qcz8wYjE2Il0sIm5hbWVzIjpbInB1bnljb2RlIiwicmVxdWlyZSIsInV0aWwiLCJleHBvcnRzIiwicGFyc2UiLCJ1cmxQYXJzZSIsInJlc29sdmUiLCJ1cmxSZXNvbHZlIiwicmVzb2x2ZU9iamVjdCIsInVybFJlc29sdmVPYmplY3QiLCJmb3JtYXQiLCJ1cmxGb3JtYXQiLCJVcmwiLCJwcm90b2NvbCIsInNsYXNoZXMiLCJhdXRoIiwiaG9zdCIsInBvcnQiLCJob3N0bmFtZSIsImhhc2giLCJzZWFyY2giLCJxdWVyeSIsInBhdGhuYW1lIiwicGF0aCIsImhyZWYiLCJwcm90b2NvbFBhdHRlcm4iLCJwb3J0UGF0dGVybiIsInNpbXBsZVBhdGhQYXR0ZXJuIiwiZGVsaW1zIiwidW53aXNlIiwiY29uY2F0IiwiYXV0b0VzY2FwZSIsIm5vbkhvc3RDaGFycyIsImhvc3RFbmRpbmdDaGFycyIsImhvc3RuYW1lTWF4TGVuIiwiaG9zdG5hbWVQYXJ0UGF0dGVybiIsImhvc3RuYW1lUGFydFN0YXJ0IiwidW5zYWZlUHJvdG9jb2wiLCJob3N0bGVzc1Byb3RvY29sIiwic2xhc2hlZFByb3RvY29sIiwicXVlcnlzdHJpbmciLCJ1cmwiLCJwYXJzZVF1ZXJ5U3RyaW5nIiwic2xhc2hlc0Rlbm90ZUhvc3QiLCJpc09iamVjdCIsInUiLCJwcm90b3R5cGUiLCJpc1N0cmluZyIsIlR5cGVFcnJvciIsInF1ZXJ5SW5kZXgiLCJpbmRleE9mIiwic3BsaXR0ZXIiLCJ1U3BsaXQiLCJzcGxpdCIsInNsYXNoUmVnZXgiLCJyZXBsYWNlIiwiam9pbiIsInJlc3QiLCJ0cmltIiwibGVuZ3RoIiwic2ltcGxlUGF0aCIsImV4ZWMiLCJzdWJzdHIiLCJwcm90byIsImxvd2VyUHJvdG8iLCJ0b0xvd2VyQ2FzZSIsIm1hdGNoIiwiaG9zdEVuZCIsImkiLCJoZWMiLCJhdFNpZ24iLCJsYXN0SW5kZXhPZiIsInNsaWNlIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwicGFyc2VIb3N0IiwiaXB2Nkhvc3RuYW1lIiwiaG9zdHBhcnRzIiwibCIsInBhcnQiLCJuZXdwYXJ0IiwiaiIsImsiLCJjaGFyQ29kZUF0IiwidmFsaWRQYXJ0cyIsIm5vdEhvc3QiLCJiaXQiLCJwdXNoIiwidW5zaGlmdCIsInRvQVNDSUkiLCJwIiwiaCIsImFlIiwiZXNjIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiZXNjYXBlIiwicW0iLCJzIiwib2JqIiwiY2FsbCIsIk9iamVjdCIsImtleXMiLCJzdHJpbmdpZnkiLCJjaGFyQXQiLCJzb3VyY2UiLCJyZWxhdGl2ZSIsInJlbCIsInJlc3VsdCIsInRrZXlzIiwidGsiLCJ0a2V5IiwicmtleXMiLCJyayIsInJrZXkiLCJ2IiwicmVsUGF0aCIsInNoaWZ0IiwiaXNTb3VyY2VBYnMiLCJpc1JlbEFicyIsIm11c3RFbmRBYnMiLCJyZW1vdmVBbGxEb3RzIiwic3JjUGF0aCIsInBzeWNob3RpYyIsInBvcCIsImlzTnVsbE9yVW5kZWZpbmVkIiwiYXV0aEluSG9zdCIsImlzTnVsbCIsImxhc3QiLCJoYXNUcmFpbGluZ1NsYXNoIiwidXAiLCJzcGxpY2UiLCJpc0Fic29sdXRlIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLElBQUlBLFdBQVdDLG1CQUFPQSxDQUFDLENBQVIsQ0FBZjtBQUNBLElBQUlDLE9BQU9ELG1CQUFPQSxDQUFDLENBQVIsQ0FBWDs7QUFFQUUsUUFBUUMsS0FBUixHQUFnQkMsUUFBaEI7QUFDQUYsUUFBUUcsT0FBUixHQUFrQkMsVUFBbEI7QUFDQUosUUFBUUssYUFBUixHQUF3QkMsZ0JBQXhCO0FBQ0FOLFFBQVFPLE1BQVIsR0FBaUJDLFNBQWpCOztBQUVBUixRQUFRUyxHQUFSLEdBQWNBLEdBQWQ7O0FBRUEsU0FBU0EsR0FB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QUNDb0YsT0FBT3RGLE1BQVAsR0FBZ0JzRixPQUFPdEYsTUFBdkIsR0FBZ0MsRUFEakMsQ0FBZDtBQUVEO0FBQ0RzRixTQUFPM0YsSUFBUCxHQUFjeUYsU0FBU3pGLElBQVQsSUFBaUIyRixPQUFPM0YsSUFBdEM7QUFDQTJGLFNBQU81RixPQUFQLEdBQWlCNEYsT0FBTzVGLE9BQVAsSUFBa0IwRixTQUFTMUYsT0FBNUM7QUFDQTRGLFNBQU9sRixJQUFQLEdBQWNrRixPQUFPaEcsTUFBUCxFQUFkO0FBQ0EsU0FBT2dHLE1BQVA7QUFDRCxDQTVRRDs7QUE4UUE5RixJQUFJa0MsU0FBSixDQUFjNEIsU0FBZCxHQUEwQixZQUFXO0FBQ25DLE1BQUkxRCxPQUFPLEtBQUtBLElBQWhCO0FBQ0EsTUFBSUMsT0FBT1MsWUFBWW1DLElBQVosQ0FBaUI3QyxJQUFqQixDQUFYO0FBQ0EsTUFBSUMsSUFBSixFQUFVO0FBQ1JBLFdBQU9BLEtBQUssQ0FBTCxDQUFQO0FBQ0EsUUFBSUEsU0FBUyxHQUFiLEVBQWtCO0FBQ2hCLFdBQUtBLElBQUwsR0FBWUEsS0FBSzZDLE1BQUwsQ0FBWSxDQUFaLENBQVo7QUFDRDtBQUNEOUMsV0FBT0EsS0FBSzhDLE1BQUwsQ0FBWSxDQUFaLEVBQWU5QyxLQUFLMkMsTUFBTCxHQUFjMUMsS0FBSzBDLE1BQWxDLENBQVA7QUFDRDtBQUNELE1BQUkzQyxJQUFKLEVBQVUsS0FBS0UsUUFBTCxHQUFnQkYsSUFBaEI7QUFDWCxDQVhEIiwiZmlsZSI6IjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cclxuLy9cclxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcclxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxyXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcclxuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxyXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XHJcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxyXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuLy9cclxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcclxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcbi8vXHJcbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1NcclxuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxyXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXHJcbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxyXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1JcclxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxyXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIHB1bnljb2RlID0gcmVxdWlyZSgncHVueWNvZGUnKTtcclxudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcclxuXHJcbmV4cG9ydHMucGFyc2UgPSB1cmxQYXJzZTtcclxuZXhwb3J0cy5yZXNvbHZlID0gdXJsUmVzb2x2ZTtcclxuZXhwb3J0cy5yZXNvbHZlT2JqZWN0ID0gdXJsUmVzb2x2ZU9iamVjdDtcclxuZXhwb3J0cy5mb3JtYXQgPSB1cmxGb3JtYXQ7XHJcblxyXG5leHBvcnRzLlVybCA9IFVybDtcclxuXHJcbmZ1bmN0aW9uIFVybCgpIHtcclxuICB0aGlzLnByb3RvY29sID0gbnVsbDtcclxuICB0aGlzLnNsYXNoZXMgPSBudWxsO1xyXG4gIHRoaXMuYXV0aCA9IG51bGw7XHJcbiAgdGhpcy5ob3N0ID0gbnVsbDtcclxuICB0aGlzLnBvcnQgPSBudWxsO1xyXG4gIHRoaXMuaG9zdG5hbWUgPSBudWxsO1xyXG4gIHRoaXMuaGFzaCA9IG51bGw7XHJcbiAgdGhpcy5zZWFyY2ggPSBudWxsO1xyXG4gIHRoaXMucXVlcnkgPSBudWxsO1xyXG4gIHRoaXMucGF0aG5hbWUgPSBudWxsO1xyXG4gIHRoaXMucGF0aCA9IG51bGw7XHJcbiAgdGhpcy5ocmVmID0gbnVsbDtcclxufVxyXG5cclxuLy8gUmVmZXJlbmNlOiBSRkMgMzk4NiwgUkZDIDE4MDgsIFJGQyAyMzk2XHJcblxyXG4vLyBkZWZpbmUgdGhlc2UgaGVyZSBzbyBhdCBsZWFzdCB0aGV5IG9ubHkgaGF2ZSB0byBiZVxyXG4vLyBjb21waWxlZCBvbmNlIG9uIHRoZSBmaXJzdCBtb2R1bGUgbG9hZC5cclxudmFyIHByb3RvY29sUGF0dGVybiA9IC9eKFthLXowLTkuKy1dKzopL2ksXHJcbiAgICBwb3J0UGF0dGVybiA9IC86WzAtOV0qJC8sXHJcblxyXG4gICAgLy8gU3BlY2lhbCBjYXNlIGZvciBhIHNpbXBsZSBwYXRoIFVSTFxyXG4gICAgc2ltcGxlUGF0aFBhdHRlcm4gPSAvXihcXC9cXC8/KD8hXFwvKVteXFw/XFxzXSopKFxcP1teXFxzXSopPyQvLFxyXG5cclxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIHJlc2VydmVkIGZvciBkZWxpbWl0aW5nIFVSTHMuXHJcbiAgICAvLyBXZSBhY3R1YWxseSBqdXN0IGF1dG8tZXNjYXBlIHRoZXNlLlxyXG4gICAgZGVsaW1zID0gWyc8JywgJz4nLCAnXCInLCAnYCcsICcgJywgJ1xccicsICdcXG4nLCAnXFx0J10sXHJcblxyXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgbm90IGFsbG93ZWQgZm9yIHZhcmlvdXMgcmVhc29ucy5cclxuICAgIHVud2lzZSA9IFsneycsICd9JywgJ3wnLCAnXFxcXCcsICdeJywgJ2AnXS5jb25jYXQoZGVsaW1zKSxcclxuXHJcbiAgICAvLyBBbGxvd2VkIGJ5IFJGQ3MsIGJ1dCBjYXVzZSBvZiBYU1MgYXR0YWNrcy4gIEFsd2F5cyBlc2NhcGUgdGhlc2UuXHJcbiAgICBhdXRvRXNjYXBlID0gWydcXCcnXS5jb25jYXQodW53aXNlKSxcclxuICAgIC8vIENoYXJhY3RlcnMgdGhhdCBhcmUgbmV2ZXIgZXZlciBhbGxvd2VkIGluIGEgaG9zdG5hbWUuXHJcbiAgICAvLyBOb3RlIHRoYXQgYW55IGludmFsaWQgY2hhcnMgYXJlIGFsc28gaGFuZGxlZCwgYnV0IHRoZXNlXHJcbiAgICAvLyBhcmUgdGhlIG9uZXMgdGhhdCBhcmUgKmV4cGVjdGVkKiB0byBiZSBzZWVuLCBzbyB3ZSBmYXN0LXBhdGhcclxuICAgIC8vIHRoZW0uXHJcbiAgICBub25Ib3N0Q2hhcnMgPSBbJyUnLCAnLycsICc/JywgJzsnLCAnIyddLmNvbmNhdChhdXRvRXNjYXBlKSxcclxuICAgIGhvc3RFbmRpbmdDaGFycyA9IFsnLycsICc/JywgJyMnXSxcclxuICAgIGhvc3RuYW1lTWF4TGVuID0gMjU1LFxyXG4gICAgaG9zdG5hbWVQYXJ0UGF0dGVybiA9IC9eWythLXowLTlBLVpfLV17MCw2M30kLyxcclxuICAgIGhvc3RuYW1lUGFydFN0YXJ0ID0gL14oWythLXowLTlBLVpfLV17MCw2M30pKC4qKSQvLFxyXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgY2FuIGFsbG93IFwidW5zYWZlXCIgYW5kIFwidW53aXNlXCIgY2hhcnMuXHJcbiAgICB1bnNhZmVQcm90b2NvbCA9IHtcclxuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxyXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXHJcbiAgICB9LFxyXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgbmV2ZXIgaGF2ZSBhIGhvc3RuYW1lLlxyXG4gICAgaG9zdGxlc3NQcm90b2NvbCA9IHtcclxuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxyXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXHJcbiAgICB9LFxyXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgYWx3YXlzIGNvbnRhaW4gYSAvLyBiaXQuXHJcbiAgICBzbGFzaGVkUHJvdG9jb2wgPSB7XHJcbiAgICAgICdodHRwJzogdHJ1ZSxcclxuICAgICAgJ2h0dHBzJzogdHJ1ZSxcclxuICAgICAgJ2Z0cCc6IHRydWUsXHJcbiAgICAgICdnb3BoZXInOiB0cnVlLFxyXG4gICAgICAnZmlsZSc6IHRydWUsXHJcbiAgICAgICdodHRwOic6IHRydWUsXHJcbiAgICAgICdodHRwczonOiB0cnVlLFxyXG4gICAgICAnZnRwOic6IHRydWUsXHJcbiAgICAgICdnb3BoZXI6JzogdHJ1ZSxcclxuICAgICAgJ2ZpbGU6JzogdHJ1ZVxyXG4gICAgfSxcclxuICAgIHF1ZXJ5c3RyaW5nID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKTtcclxuXHJcbmZ1bmN0aW9uIHVybFBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcclxuICBpZiAodXJsICYmIHV0aWwuaXNPYmplY3QodXJsKSAmJiB1cmwgaW5zdGFuY2VvZiBVcmwpIHJldHVybiB1cmw7XHJcblxyXG4gIHZhciB1ID0gbmV3IFVybDtcclxuICB1LnBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpO1xyXG4gIHJldHVybiB1O1xyXG59XHJcblxyXG5VcmwucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24odXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xyXG4gIGlmICghdXRpbC5pc1N0cmluZyh1cmwpKSB7XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGFyYW1ldGVyICd1cmwnIG11c3QgYmUgYSBzdHJpbmcsIG5vdCBcIiArIHR5cGVvZiB1cmwpO1xyXG4gIH1cclxuXHJcbiAgLy8gQ29weSBjaHJvbWUsIElFLCBvcGVyYSBiYWNrc2xhc2gtaGFuZGxpbmcgYmVoYXZpb3IuXHJcbiAgLy8gQmFjayBzbGFzaGVzIGJlZm9yZSB0aGUgcXVlcnkgc3RyaW5nIGdldCBjb252ZXJ0ZWQgdG8gZm9yd2FyZCBzbGFzaGVzXHJcbiAgLy8gU2VlOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MjU5MTZcclxuICB2YXIgcXVlcnlJbmRleCA9IHVybC5pbmRleE9mKCc/JyksXHJcbiAgICAgIHNwbGl0dGVyID1cclxuICAgICAgICAgIChxdWVyeUluZGV4ICE9PSAtMSAmJiBxdWVyeUluZGV4IDwgdXJsLmluZGV4T2YoJyMnKSkgPyAnPycgOiAnIycsXHJcbiAgICAgIHVTcGxpdCA9IHVybC5zcGxpdChzcGxpdHRlciksXHJcbiAgICAgIHNsYXNoUmVnZXggPSAvXFxcXC9nO1xyXG4gIHVTcGxpdFswXSA9IHVTcGxpdFswXS5yZXBsYWNlKHNsYXNoUmVnZXgsICcvJyk7XHJcbiAgdXJsID0gdVNwbGl0LmpvaW4oc3BsaXR0ZXIpO1xyXG5cclxuICB2YXIgcmVzdCA9IHVybDtcclxuXHJcbiAgLy8gdHJpbSBiZWZvcmUgcHJvY2VlZGluZy5cclxuICAvLyBUaGlzIGlzIHRvIHN1cHBvcnQgcGFyc2Ugc3R1ZmYgbGlrZSBcIiAgaHR0cDovL2Zvby5jb20gIFxcblwiXHJcbiAgcmVzdCA9IHJlc3QudHJpbSgpO1xyXG5cclxuICBpZiAoIXNsYXNoZXNEZW5vdGVIb3N0ICYmIHVybC5zcGxpdCgnIycpLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgLy8gVHJ5IGZhc3QgcGF0aCByZWdleHBcclxuICAgIHZhciBzaW1wbGVQYXRoID0gc2ltcGxlUGF0aFBhdHRlcm4uZXhlYyhyZXN0KTtcclxuICAgIGlmIChzaW1wbGVQYXRoKSB7XHJcbiAgICAgIHRoaXMucGF0aCA9IHJlc3Q7XHJcbiAgICAgIHRoaXMuaHJlZiA9IHJlc3Q7XHJcbiAgICAgIHRoaXMucGF0aG5hbWUgPSBzaW1wbGVQYXRoWzFdO1xyXG4gICAgICBpZiAoc2ltcGxlUGF0aFsyXSkge1xyXG4gICAgICAgIHRoaXMuc2VhcmNoID0gc2ltcGxlUGF0aFsyXTtcclxuICAgICAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xyXG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMuc2VhcmNoLnN1YnN0cigxKSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRoaXMucXVlcnkgPSB0aGlzLnNlYXJjaC5zdWJzdHIoMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcclxuICAgICAgICB0aGlzLnNlYXJjaCA9ICcnO1xyXG4gICAgICAgIHRoaXMucXVlcnkgPSB7fTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHZhciBwcm90byA9IHByb3RvY29sUGF0dGVybi5leGVjKHJlc3QpO1xyXG4gIGlmIChwcm90bykge1xyXG4gICAgcHJvdG8gPSBwcm90b1swXTtcclxuICAgIHZhciBsb3dlclByb3RvID0gcHJvdG8udG9Mb3dlckNhc2UoKTtcclxuICAgIHRoaXMucHJvdG9jb2wgPSBsb3dlclByb3RvO1xyXG4gICAgcmVzdCA9IHJlc3Quc3Vic3RyKHByb3RvLmxlbmd0aCk7XHJcbiAgfVxyXG5cclxuICAvLyBmaWd1cmUgb3V0IGlmIGl0J3MgZ290IGEgaG9zdFxyXG4gIC8vIHVzZXJAc2VydmVyIGlzICphbHdheXMqIGludGVycHJldGVkIGFzIGEgaG9zdG5hbWUsIGFuZCB1cmxcclxuICAvLyByZXNvbHV0aW9uIHdpbGwgdHJlYXQgLy9mb28vYmFyIGFzIGhvc3Q9Zm9vLHBhdGg9YmFyIGJlY2F1c2UgdGhhdCdzXHJcbiAgLy8gaG93IHRoZSBicm93c2VyIHJlc29sdmVzIHJlbGF0aXZlIFVSTHMuXHJcbiAgaWYgKHNsYXNoZXNEZW5vdGVIb3N0IHx8IHByb3RvIHx8IHJlc3QubWF0Y2goL15cXC9cXC9bXkBcXC9dK0BbXkBcXC9dKy8pKSB7XHJcbiAgICB2YXIgc2xhc2hlcyA9IHJlc3Quc3Vic3RyKDAsIDIpID09PSAnLy8nO1xyXG4gICAgaWYgKHNsYXNoZXMgJiYgIShwcm90byAmJiBob3N0bGVzc1Byb3RvY29sW3Byb3RvXSkpIHtcclxuICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKDIpO1xyXG4gICAgICB0aGlzLnNsYXNoZXMgPSB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKCFob3N0bGVzc1Byb3RvY29sW3Byb3RvXSAmJlxyXG4gICAgICAoc2xhc2hlcyB8fCAocHJvdG8gJiYgIXNsYXNoZWRQcm90b2NvbFtwcm90b10pKSkge1xyXG5cclxuICAgIC8vIHRoZXJlJ3MgYSBob3N0bmFtZS5cclxuICAgIC8vIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiAvLCA/LCA7LCBvciAjIGVuZHMgdGhlIGhvc3QuXHJcbiAgICAvL1xyXG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gQCBpbiB0aGUgaG9zdG5hbWUsIHRoZW4gbm9uLWhvc3QgY2hhcnMgKmFyZSogYWxsb3dlZFxyXG4gICAgLy8gdG8gdGhlIGxlZnQgb2YgdGhlIGxhc3QgQCBzaWduLCB1bmxlc3Mgc29tZSBob3N0LWVuZGluZyBjaGFyYWN0ZXJcclxuICAgIC8vIGNvbWVzICpiZWZvcmUqIHRoZSBALXNpZ24uXHJcbiAgICAvLyBVUkxzIGFyZSBvYm5veGlvdXMuXHJcbiAgICAvL1xyXG4gICAgLy8gZXg6XHJcbiAgICAvLyBodHRwOi8vYUBiQGMvID0+IHVzZXI6YUBiIGhvc3Q6Y1xyXG4gICAgLy8gaHR0cDovL2FAYj9AYyA9PiB1c2VyOmEgaG9zdDpjIHBhdGg6Lz9AY1xyXG5cclxuICAgIC8vIHYwLjEyIFRPRE8oaXNhYWNzKTogVGhpcyBpcyBub3QgcXVpdGUgaG93IENocm9tZSBkb2VzIHRoaW5ncy5cclxuICAgIC8vIFJldmlldyBvdXIgdGVzdCBjYXNlIGFnYWluc3QgYnJvd3NlcnMgbW9yZSBjb21wcmVoZW5zaXZlbHkuXHJcblxyXG4gICAgLy8gZmluZCB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgYW55IGhvc3RFbmRpbmdDaGFyc1xyXG4gICAgdmFyIGhvc3RFbmQgPSAtMTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9zdEVuZGluZ0NoYXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2YoaG9zdEVuZGluZ0NoYXJzW2ldKTtcclxuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxyXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gYXQgdGhpcyBwb2ludCwgZWl0aGVyIHdlIGhhdmUgYW4gZXhwbGljaXQgcG9pbnQgd2hlcmUgdGhlXHJcbiAgICAvLyBhdXRoIHBvcnRpb24gY2Fubm90IGdvIHBhc3QsIG9yIHRoZSBsYXN0IEAgY2hhciBpcyB0aGUgZGVjaWRlci5cclxuICAgIHZhciBhdXRoLCBhdFNpZ247XHJcbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcclxuICAgICAgLy8gYXRTaWduIGNhbiBiZSBhbnl3aGVyZS5cclxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gYXRTaWduIG11c3QgYmUgaW4gYXV0aCBwb3J0aW9uLlxyXG4gICAgICAvLyBodHRwOi8vYUBiL2NAZCA9PiBob3N0OmIgYXV0aDphIHBhdGg6L2NAZFxyXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJywgaG9zdEVuZCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTm93IHdlIGhhdmUgYSBwb3J0aW9uIHdoaWNoIGlzIGRlZmluaXRlbHkgdGhlIGF1dGguXHJcbiAgICAvLyBQdWxsIHRoYXQgb2ZmLlxyXG4gICAgaWYgKGF0U2lnbiAhPT0gLTEpIHtcclxuICAgICAgYXV0aCA9IHJlc3Quc2xpY2UoMCwgYXRTaWduKTtcclxuICAgICAgcmVzdCA9IHJlc3Quc2xpY2UoYXRTaWduICsgMSk7XHJcbiAgICAgIHRoaXMuYXV0aCA9IGRlY29kZVVSSUNvbXBvbmVudChhdXRoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyB0aGUgaG9zdCBpcyB0aGUgcmVtYWluaW5nIHRvIHRoZSBsZWZ0IG9mIHRoZSBmaXJzdCBub24taG9zdCBjaGFyXHJcbiAgICBob3N0RW5kID0gLTE7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vbkhvc3RDaGFycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKG5vbkhvc3RDaGFyc1tpXSk7XHJcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcclxuICAgICAgICBob3N0RW5kID0gaGVjO1xyXG4gICAgfVxyXG4gICAgLy8gaWYgd2Ugc3RpbGwgaGF2ZSBub3QgaGl0IGl0LCB0aGVuIHRoZSBlbnRpcmUgdGhpbmcgaXMgYSBob3N0LlxyXG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKVxyXG4gICAgICBob3N0RW5kID0gcmVzdC5sZW5ndGg7XHJcblxyXG4gICAgdGhpcy5ob3N0ID0gcmVzdC5zbGljZSgwLCBob3N0RW5kKTtcclxuICAgIHJlc3QgPSByZXN0LnNsaWNlKGhvc3RFbmQpO1xyXG5cclxuICAgIC8vIHB1bGwgb3V0IHBvcnQuXHJcbiAgICB0aGlzLnBhcnNlSG9zdCgpO1xyXG5cclxuICAgIC8vIHdlJ3ZlIGluZGljYXRlZCB0aGF0IHRoZXJlIGlzIGEgaG9zdG5hbWUsXHJcbiAgICAvLyBzbyBldmVuIGlmIGl0J3MgZW1wdHksIGl0IGhhcyB0byBiZSBwcmVzZW50LlxyXG4gICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XHJcblxyXG4gICAgLy8gaWYgaG9zdG5hbWUgYmVnaW5zIHdpdGggWyBhbmQgZW5kcyB3aXRoIF1cclxuICAgIC8vIGFzc3VtZSB0aGF0IGl0J3MgYW4gSVB2NiBhZGRyZXNzLlxyXG4gICAgdmFyIGlwdjZIb3N0bmFtZSA9IHRoaXMuaG9zdG5hbWVbMF0gPT09ICdbJyAmJlxyXG4gICAgICAgIHRoaXMuaG9zdG5hbWVbdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAxXSA9PT0gJ10nO1xyXG5cclxuICAgIC8vIHZhbGlkYXRlIGEgbGl0dGxlLlxyXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcclxuICAgICAgdmFyIGhvc3RwYXJ0cyA9IHRoaXMuaG9zdG5hbWUuc3BsaXQoL1xcLi8pO1xyXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGhvc3RwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICB2YXIgcGFydCA9IGhvc3RwYXJ0c1tpXTtcclxuICAgICAgICBpZiAoIXBhcnQpIGNvbnRpbnVlO1xyXG4gICAgICAgIGlmICghcGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xyXG4gICAgICAgICAgdmFyIG5ld3BhcnQgPSAnJztcclxuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBrID0gcGFydC5sZW5ndGg7IGogPCBrOyBqKyspIHtcclxuICAgICAgICAgICAgaWYgKHBhcnQuY2hhckNvZGVBdChqKSA+IDEyNykge1xyXG4gICAgICAgICAgICAgIC8vIHdlIHJlcGxhY2Ugbm9uLUFTQ0lJIGNoYXIgd2l0aCBhIHRlbXBvcmFyeSBwbGFjZWhvbGRlclxyXG4gICAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhpcyB0byBtYWtlIHN1cmUgc2l6ZSBvZiBob3N0bmFtZSBpcyBub3RcclxuICAgICAgICAgICAgICAvLyBicm9rZW4gYnkgcmVwbGFjaW5nIG5vbi1BU0NJSSBieSBub3RoaW5nXHJcbiAgICAgICAgICAgICAgbmV3cGFydCArPSAneCc7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgbmV3cGFydCArPSBwYXJ0W2pdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICAvLyB3ZSB0ZXN0IGFnYWluIHdpdGggQVNDSUkgY2hhciBvbmx5XHJcbiAgICAgICAgICBpZiAoIW5ld3BhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcclxuICAgICAgICAgICAgdmFyIHZhbGlkUGFydHMgPSBob3N0cGFydHMuc2xpY2UoMCwgaSk7XHJcbiAgICAgICAgICAgIHZhciBub3RIb3N0ID0gaG9zdHBhcnRzLnNsaWNlKGkgKyAxKTtcclxuICAgICAgICAgICAgdmFyIGJpdCA9IHBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0U3RhcnQpO1xyXG4gICAgICAgICAgICBpZiAoYml0KSB7XHJcbiAgICAgICAgICAgICAgdmFsaWRQYXJ0cy5wdXNoKGJpdFsxXSk7XHJcbiAgICAgICAgICAgICAgbm90SG9zdC51bnNoaWZ0KGJpdFsyXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG5vdEhvc3QubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgcmVzdCA9ICcvJyArIG5vdEhvc3Quam9pbignLicpICsgcmVzdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gdmFsaWRQYXJ0cy5qb2luKCcuJyk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLmhvc3RuYW1lLmxlbmd0aCA+IGhvc3RuYW1lTWF4TGVuKSB7XHJcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSAnJztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIGhvc3RuYW1lcyBhcmUgYWx3YXlzIGxvd2VyIGNhc2UuXHJcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnRvTG93ZXJDYXNlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcclxuICAgICAgLy8gSUROQSBTdXBwb3J0OiBSZXR1cm5zIGEgcHVueWNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIFwiZG9tYWluXCIuXHJcbiAgICAgIC8vIEl0IG9ubHkgY29udmVydHMgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHRoYXRcclxuICAgICAgLy8gaGF2ZSBub24tQVNDSUkgY2hhcmFjdGVycywgaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZlxyXG4gICAgICAvLyB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQgYWxyZWFkeSBpcyBBU0NJSS1vbmx5LlxyXG4gICAgICB0aGlzLmhvc3RuYW1lID0gcHVueWNvZGUudG9BU0NJSSh0aGlzLmhvc3RuYW1lKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcCA9IHRoaXMucG9ydCA/ICc6JyArIHRoaXMucG9ydCA6ICcnO1xyXG4gICAgdmFyIGggPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xyXG4gICAgdGhpcy5ob3N0ID0gaCArIHA7XHJcbiAgICB0aGlzLmhyZWYgKz0gdGhpcy5ob3N0O1xyXG5cclxuICAgIC8vIHN0cmlwIFsgYW5kIF0gZnJvbSB0aGUgaG9zdG5hbWVcclxuICAgIC8vIHRoZSBob3N0IGZpZWxkIHN0aWxsIHJldGFpbnMgdGhlbSwgdGhvdWdoXHJcbiAgICBpZiAoaXB2Nkhvc3RuYW1lKSB7XHJcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnN1YnN0cigxLCB0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDIpO1xyXG4gICAgICBpZiAocmVzdFswXSAhPT0gJy8nKSB7XHJcbiAgICAgICAgcmVzdCA9ICcvJyArIHJlc3Q7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIG5vdyByZXN0IGlzIHNldCB0byB0aGUgcG9zdC1ob3N0IHN0dWZmLlxyXG4gIC8vIGNob3Agb2ZmIGFueSBkZWxpbSBjaGFycy5cclxuICBpZiAoIXVuc2FmZVByb3RvY29sW2xvd2VyUHJvdG9dKSB7XHJcblxyXG4gICAgLy8gRmlyc3QsIG1ha2UgMTAwJSBzdXJlIHRoYXQgYW55IFwiYXV0b0VzY2FwZVwiIGNoYXJzIGdldFxyXG4gICAgLy8gZXNjYXBlZCwgZXZlbiBpZiBlbmNvZGVVUklDb21wb25lbnQgZG9lc24ndCB0aGluayB0aGV5XHJcbiAgICAvLyBuZWVkIHRvIGJlLlxyXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdXRvRXNjYXBlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICB2YXIgYWUgPSBhdXRvRXNjYXBlW2ldO1xyXG4gICAgICBpZiAocmVzdC5pbmRleE9mKGFlKSA9PT0gLTEpXHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIHZhciBlc2MgPSBlbmNvZGVVUklDb21wb25lbnQoYWUpO1xyXG4gICAgICBpZiAoZXNjID09PSBhZSkge1xyXG4gICAgICAgIGVzYyA9IGVzY2FwZShhZSk7XHJcbiAgICAgIH1cclxuICAgICAgcmVzdCA9IHJlc3Quc3BsaXQoYWUpLmpvaW4oZXNjKTtcclxuICAgIH1cclxuICB9XHJcblxyXG5cclxuICAvLyBjaG9wIG9mZiBmcm9tIHRoZSB0YWlsIGZpcnN0LlxyXG4gIHZhciBoYXNoID0gcmVzdC5pbmRleE9mKCcjJyk7XHJcbiAgaWYgKGhhc2ggIT09IC0xKSB7XHJcbiAgICAvLyBnb3QgYSBmcmFnbWVudCBzdHJpbmcuXHJcbiAgICB0aGlzLmhhc2ggPSByZXN0LnN1YnN0cihoYXNoKTtcclxuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIGhhc2gpO1xyXG4gIH1cclxuICB2YXIgcW0gPSByZXN0LmluZGV4T2YoJz8nKTtcclxuICBpZiAocW0gIT09IC0xKSB7XHJcbiAgICB0aGlzLnNlYXJjaCA9IHJlc3Quc3Vic3RyKHFtKTtcclxuICAgIHRoaXMucXVlcnkgPSByZXN0LnN1YnN0cihxbSArIDEpO1xyXG4gICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcclxuICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMucXVlcnkpO1xyXG4gICAgfVxyXG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgcW0pO1xyXG4gIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xyXG4gICAgLy8gbm8gcXVlcnkgc3RyaW5nLCBidXQgcGFyc2VRdWVyeVN0cmluZyBzdGlsbCByZXF1ZXN0ZWRcclxuICAgIHRoaXMuc2VhcmNoID0gJyc7XHJcbiAgICB0aGlzLnF1ZXJ5ID0ge307XHJcbiAgfVxyXG4gIGlmIChyZXN0KSB0aGlzLnBhdGhuYW1lID0gcmVzdDtcclxuICBpZiAoc2xhc2hlZFByb3RvY29sW2xvd2VyUHJvdG9dICYmXHJcbiAgICAgIHRoaXMuaG9zdG5hbWUgJiYgIXRoaXMucGF0aG5hbWUpIHtcclxuICAgIHRoaXMucGF0aG5hbWUgPSAnLyc7XHJcbiAgfVxyXG5cclxuICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XHJcbiAgaWYgKHRoaXMucGF0aG5hbWUgfHwgdGhpcy5zZWFyY2gpIHtcclxuICAgIHZhciBwID0gdGhpcy5wYXRobmFtZSB8fCAnJztcclxuICAgIHZhciBzID0gdGhpcy5zZWFyY2ggfHwgJyc7XHJcbiAgICB0aGlzLnBhdGggPSBwICsgcztcclxuICB9XHJcblxyXG4gIC8vIGZpbmFsbHksIHJlY29uc3RydWN0IHRoZSBocmVmIGJhc2VkIG9uIHdoYXQgaGFzIGJlZW4gdmFsaWRhdGVkLlxyXG4gIHRoaXMuaHJlZiA9IHRoaXMuZm9ybWF0KCk7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vLyBmb3JtYXQgYSBwYXJzZWQgb2JqZWN0IGludG8gYSB1cmwgc3RyaW5nXHJcbmZ1bmN0aW9uIHVybEZvcm1hdChvYmopIHtcclxuICAvLyBlbnN1cmUgaXQncyBhbiBvYmplY3QsIGFuZCBub3QgYSBzdHJpbmcgdXJsLlxyXG4gIC8vIElmIGl0J3MgYW4gb2JqLCB0aGlzIGlzIGEgbm8tb3AuXHJcbiAgLy8gdGhpcyB3YXksIHlvdSBjYW4gY2FsbCB1cmxfZm9ybWF0KCkgb24gc3RyaW5nc1xyXG4gIC8vIHRvIGNsZWFuIHVwIHBvdGVudGlhbGx5IHdvbmt5IHVybHMuXHJcbiAgaWYgKHV0aWwuaXNTdHJpbmcob2JqKSkgb2JqID0gdXJsUGFyc2Uob2JqKTtcclxuICBpZiAoIShvYmogaW5zdGFuY2VvZiBVcmwpKSByZXR1cm4gVXJsLnByb3RvdHlwZS5mb3JtYXQuY2FsbChvYmopO1xyXG4gIHJldHVybiBvYmouZm9ybWF0KCk7XHJcbn1cclxuXHJcblVybC5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24oKSB7XHJcbiAgdmFyIGF1dGggPSB0aGlzLmF1dGggfHwgJyc7XHJcbiAgaWYgKGF1dGgpIHtcclxuICAgIGF1dGggPSBlbmNvZGVVUklDb21wb25lbnQoYXV0aCk7XHJcbiAgICBhdXRoID0gYXV0aC5yZXBsYWNlKC8lM0EvaSwgJzonKTtcclxuICAgIGF1dGggKz0gJ0AnO1xyXG4gIH1cclxuXHJcbiAgdmFyIHByb3RvY29sID0gdGhpcy5wcm90b2NvbCB8fCAnJyxcclxuICAgICAgcGF0aG5hbWUgPSB0aGlzLnBhdGhuYW1lIHx8ICcnLFxyXG4gICAgICBoYXNoID0gdGhpcy5oYXNoIHx8ICcnLFxyXG4gICAgICBob3N0ID0gZmFsc2UsXHJcbiAgICAgIHF1ZXJ5ID0gJyc7XHJcblxyXG4gIGlmICh0aGlzLmhvc3QpIHtcclxuICAgIGhvc3QgPSBhdXRoICsgdGhpcy5ob3N0O1xyXG4gIH0gZWxzZSBpZiAodGhpcy5ob3N0bmFtZSkge1xyXG4gICAgaG9zdCA9IGF1dGggKyAodGhpcy5ob3N0bmFtZS5pbmRleE9mKCc6JykgPT09IC0xID9cclxuICAgICAgICB0aGlzLmhvc3RuYW1lIDpcclxuICAgICAgICAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nKTtcclxuICAgIGlmICh0aGlzLnBvcnQpIHtcclxuICAgICAgaG9zdCArPSAnOicgKyB0aGlzLnBvcnQ7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZiAodGhpcy5xdWVyeSAmJlxyXG4gICAgICB1dGlsLmlzT2JqZWN0KHRoaXMucXVlcnkpICYmXHJcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMucXVlcnkpLmxlbmd0aCkge1xyXG4gICAgcXVlcnkgPSBxdWVyeXN0cmluZy5zdHJpbmdpZnkodGhpcy5xdWVyeSk7XHJcbiAgfVxyXG5cclxuICB2YXIgc2VhcmNoID0gdGhpcy5zZWFyY2ggfHwgKHF1ZXJ5ICYmICgnPycgKyBxdWVyeSkpIHx8ICcnO1xyXG5cclxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuc3Vic3RyKC0xKSAhPT0gJzonKSBwcm90b2NvbCArPSAnOic7XHJcblxyXG4gIC8vIG9ubHkgdGhlIHNsYXNoZWRQcm90b2NvbHMgZ2V0IHRoZSAvLy4gIE5vdCBtYWlsdG86LCB4bXBwOiwgZXRjLlxyXG4gIC8vIHVubGVzcyB0aGV5IGhhZCB0aGVtIHRvIGJlZ2luIHdpdGguXHJcbiAgaWYgKHRoaXMuc2xhc2hlcyB8fFxyXG4gICAgICAoIXByb3RvY29sIHx8IHNsYXNoZWRQcm90b2NvbFtwcm90b2NvbF0pICYmIGhvc3QgIT09IGZhbHNlKSB7XHJcbiAgICBob3N0ID0gJy8vJyArIChob3N0IHx8ICcnKTtcclxuICAgIGlmIChwYXRobmFtZSAmJiBwYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykgcGF0aG5hbWUgPSAnLycgKyBwYXRobmFtZTtcclxuICB9IGVsc2UgaWYgKCFob3N0KSB7XHJcbiAgICBob3N0ID0gJyc7XHJcbiAgfVxyXG5cclxuICBpZiAoaGFzaCAmJiBoYXNoLmNoYXJBdCgwKSAhPT0gJyMnKSBoYXNoID0gJyMnICsgaGFzaDtcclxuICBpZiAoc2VhcmNoICYmIHNlYXJjaC5jaGFyQXQoMCkgIT09ICc/Jykgc2VhcmNoID0gJz8nICsgc2VhcmNoO1xyXG5cclxuICBwYXRobmFtZSA9IHBhdGhuYW1lLnJlcGxhY2UoL1s/I10vZywgZnVuY3Rpb24obWF0Y2gpIHtcclxuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQobWF0Y2gpO1xyXG4gIH0pO1xyXG4gIHNlYXJjaCA9IHNlYXJjaC5yZXBsYWNlKCcjJywgJyUyMycpO1xyXG5cclxuICByZXR1cm4gcHJvdG9jb2wgKyBob3N0ICsgcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gdXJsUmVzb2x2ZShzb3VyY2UsIHJlbGF0aXZlKSB7XHJcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmUocmVsYXRpdmUpO1xyXG59XHJcblxyXG5VcmwucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xyXG4gIHJldHVybiB0aGlzLnJlc29sdmVPYmplY3QodXJsUGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKSkuZm9ybWF0KCk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiB1cmxSZXNvbHZlT2JqZWN0KHNvdXJjZSwgcmVsYXRpdmUpIHtcclxuICBpZiAoIXNvdXJjZSkgcmV0dXJuIHJlbGF0aXZlO1xyXG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlT2JqZWN0KHJlbGF0aXZlKTtcclxufVxyXG5cclxuVXJsLnByb3RvdHlwZS5yZXNvbHZlT2JqZWN0ID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcclxuICBpZiAodXRpbC5pc1N0cmluZyhyZWxhdGl2ZSkpIHtcclxuICAgIHZhciByZWwgPSBuZXcgVXJsKCk7XHJcbiAgICByZWwucGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKTtcclxuICAgIHJlbGF0aXZlID0gcmVsO1xyXG4gIH1cclxuXHJcbiAgdmFyIHJlc3VsdCA9IG5ldyBVcmwoKTtcclxuICB2YXIgdGtleXMgPSBPYmplY3Qua2V5cyh0aGlzKTtcclxuICBmb3IgKHZhciB0ayA9IDA7IHRrIDwgdGtleXMubGVuZ3RoOyB0aysrKSB7XHJcbiAgICB2YXIgdGtleSA9IHRrZXlzW3RrXTtcclxuICAgIHJlc3VsdFt0a2V5XSA9IHRoaXNbdGtleV07XHJcbiAgfVxyXG5cclxuICAvLyBoYXNoIGlzIGFsd2F5cyBvdmVycmlkZGVuLCBubyBtYXR0ZXIgd2hhdC5cclxuICAvLyBldmVuIGhyZWY9XCJcIiB3aWxsIHJlbW92ZSBpdC5cclxuICByZXN1bHQuaGFzaCA9IHJlbGF0aXZlLmhhc2g7XHJcblxyXG4gIC8vIGlmIHRoZSByZWxhdGl2ZSB1cmwgaXMgZW1wdHksIHRoZW4gdGhlcmUncyBub3RoaW5nIGxlZnQgdG8gZG8gaGVyZS5cclxuICBpZiAocmVsYXRpdmUuaHJlZiA9PT0gJycpIHtcclxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcblxyXG4gIC8vIGhyZWZzIGxpa2UgLy9mb28vYmFyIGFsd2F5cyBjdXQgdG8gdGhlIHByb3RvY29sLlxyXG4gIGlmIChyZWxhdGl2ZS5zbGFzaGVzICYmICFyZWxhdGl2ZS5wcm90b2NvbCkge1xyXG4gICAgLy8gdGFrZSBldmVyeXRoaW5nIGV4Y2VwdCB0aGUgcHJvdG9jb2wgZnJvbSByZWxhdGl2ZVxyXG4gICAgdmFyIHJrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xyXG4gICAgZm9yICh2YXIgcmsgPSAwOyByayA8IHJrZXlzLmxlbmd0aDsgcmsrKykge1xyXG4gICAgICB2YXIgcmtleSA9IHJrZXlzW3JrXTtcclxuICAgICAgaWYgKHJrZXkgIT09ICdwcm90b2NvbCcpXHJcbiAgICAgICAgcmVzdWx0W3JrZXldID0gcmVsYXRpdmVbcmtleV07XHJcbiAgICB9XHJcblxyXG4gICAgLy91cmxQYXJzZSBhcHBlbmRzIHRyYWlsaW5nIC8gdG8gdXJscyBsaWtlIGh0dHA6Ly93d3cuZXhhbXBsZS5jb21cclxuICAgIGlmIChzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXSAmJlxyXG4gICAgICAgIHJlc3VsdC5ob3N0bmFtZSAmJiAhcmVzdWx0LnBhdGhuYW1lKSB7XHJcbiAgICAgIHJlc3VsdC5wYXRoID0gcmVzdWx0LnBhdGhuYW1lID0gJy8nO1xyXG4gICAgfVxyXG5cclxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcblxyXG4gIGlmIChyZWxhdGl2ZS5wcm90b2NvbCAmJiByZWxhdGl2ZS5wcm90b2NvbCAhPT0gcmVzdWx0LnByb3RvY29sKSB7XHJcbiAgICAvLyBpZiBpdCdzIGEga25vd24gdXJsIHByb3RvY29sLCB0aGVuIGNoYW5naW5nXHJcbiAgICAvLyB0aGUgcHJvdG9jb2wgZG9lcyB3ZWlyZCB0aGluZ3NcclxuICAgIC8vIGZpcnN0LCBpZiBpdCdzIG5vdCBmaWxlOiwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBob3N0LFxyXG4gICAgLy8gYW5kIGlmIHRoZXJlIHdhcyBhIHBhdGhcclxuICAgIC8vIHRvIGJlZ2luIHdpdGgsIHRoZW4gd2UgTVVTVCBoYXZlIGEgcGF0aC5cclxuICAgIC8vIGlmIGl0IGlzIGZpbGU6LCB0aGVuIHRoZSBob3N0IGlzIGRyb3BwZWQsXHJcbiAgICAvLyBiZWNhdXNlIHRoYXQncyBrbm93biB0byBiZSBob3N0bGVzcy5cclxuICAgIC8vIGFueXRoaW5nIGVsc2UgaXMgYXNzdW1lZCB0byBiZSBhYnNvbHV0ZS5cclxuICAgIGlmICghc2xhc2hlZFByb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xyXG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTtcclxuICAgICAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XHJcbiAgICAgICAgdmFyIGsgPSBrZXlzW3ZdO1xyXG4gICAgICAgIHJlc3VsdFtrXSA9IHJlbGF0aXZlW2tdO1xyXG4gICAgICB9XHJcbiAgICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIHJlc3VsdC5wcm90b2NvbCA9IHJlbGF0aXZlLnByb3RvY29sO1xyXG4gICAgaWYgKCFyZWxhdGl2ZS5ob3N0ICYmICFob3N0bGVzc1Byb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xyXG4gICAgICB2YXIgcmVsUGF0aCA9IChyZWxhdGl2ZS5wYXRobmFtZSB8fCAnJykuc3BsaXQoJy8nKTtcclxuICAgICAgd2hpbGUgKHJlbFBhdGgubGVuZ3RoICYmICEocmVsYXRpdmUuaG9zdCA9IHJlbFBhdGguc2hpZnQoKSkpO1xyXG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3QpIHJlbGF0aXZlLmhvc3QgPSAnJztcclxuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0bmFtZSkgcmVsYXRpdmUuaG9zdG5hbWUgPSAnJztcclxuICAgICAgaWYgKHJlbFBhdGhbMF0gIT09ICcnKSByZWxQYXRoLnVuc2hpZnQoJycpO1xyXG4gICAgICBpZiAocmVsUGF0aC5sZW5ndGggPCAyKSByZWxQYXRoLnVuc2hpZnQoJycpO1xyXG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxQYXRoLmpvaW4oJy8nKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbGF0aXZlLnBhdGhuYW1lO1xyXG4gICAgfVxyXG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcclxuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xyXG4gICAgcmVzdWx0Lmhvc3QgPSByZWxhdGl2ZS5ob3N0IHx8ICcnO1xyXG4gICAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoO1xyXG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdDtcclxuICAgIHJlc3VsdC5wb3J0ID0gcmVsYXRpdmUucG9ydDtcclxuICAgIC8vIHRvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XHJcbiAgICBpZiAocmVzdWx0LnBhdGhuYW1lIHx8IHJlc3VsdC5zZWFyY2gpIHtcclxuICAgICAgdmFyIHAgPSByZXN1bHQucGF0aG5hbWUgfHwgJyc7XHJcbiAgICAgIHZhciBzID0gcmVzdWx0LnNlYXJjaCB8fCAnJztcclxuICAgICAgcmVzdWx0LnBhdGggPSBwICsgcztcclxuICAgIH1cclxuICAgIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcclxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcblxyXG4gIHZhciBpc1NvdXJjZUFicyA9IChyZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nKSxcclxuICAgICAgaXNSZWxBYnMgPSAoXHJcbiAgICAgICAgICByZWxhdGl2ZS5ob3N0IHx8XHJcbiAgICAgICAgICByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJ1xyXG4gICAgICApLFxyXG4gICAgICBtdXN0RW5kQWJzID0gKGlzUmVsQWJzIHx8IGlzU291cmNlQWJzIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5ob3N0ICYmIHJlbGF0aXZlLnBhdGhuYW1lKSksXHJcbiAgICAgIHJlbW92ZUFsbERvdHMgPSBtdXN0RW5kQWJzLFxyXG4gICAgICBzcmNQYXRoID0gcmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxyXG4gICAgICByZWxQYXRoID0gcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcclxuICAgICAgcHN5Y2hvdGljID0gcmVzdWx0LnByb3RvY29sICYmICFzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXTtcclxuXHJcbiAgLy8gaWYgdGhlIHVybCBpcyBhIG5vbi1zbGFzaGVkIHVybCwgdGhlbiByZWxhdGl2ZVxyXG4gIC8vIGxpbmtzIGxpa2UgLi4vLi4gc2hvdWxkIGJlIGFibGVcclxuICAvLyB0byBjcmF3bCB1cCB0byB0aGUgaG9zdG5hbWUsIGFzIHdlbGwuICBUaGlzIGlzIHN0cmFuZ2UuXHJcbiAgLy8gcmVzdWx0LnByb3RvY29sIGhhcyBhbHJlYWR5IGJlZW4gc2V0IGJ5IG5vdy5cclxuICAvLyBMYXRlciBvbiwgcHV0IHRoZSBmaXJzdCBwYXRoIHBhcnQgaW50byB0aGUgaG9zdCBmaWVsZC5cclxuICBpZiAocHN5Y2hvdGljKSB7XHJcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAnJztcclxuICAgIHJlc3VsdC5wb3J0ID0gbnVsbDtcclxuICAgIGlmIChyZXN1bHQuaG9zdCkge1xyXG4gICAgICBpZiAoc3JjUGF0aFswXSA9PT0gJycpIHNyY1BhdGhbMF0gPSByZXN1bHQuaG9zdDtcclxuICAgICAgZWxzZSBzcmNQYXRoLnVuc2hpZnQocmVzdWx0Lmhvc3QpO1xyXG4gICAgfVxyXG4gICAgcmVzdWx0Lmhvc3QgPSAnJztcclxuICAgIGlmIChyZWxhdGl2ZS5wcm90b2NvbCkge1xyXG4gICAgICByZWxhdGl2ZS5ob3N0bmFtZSA9IG51bGw7XHJcbiAgICAgIHJlbGF0aXZlLnBvcnQgPSBudWxsO1xyXG4gICAgICBpZiAocmVsYXRpdmUuaG9zdCkge1xyXG4gICAgICAgIGlmIChyZWxQYXRoWzBdID09PSAnJykgcmVsUGF0aFswXSA9IHJlbGF0aXZlLmhvc3Q7XHJcbiAgICAgICAgZWxzZSByZWxQYXRoLnVuc2hpZnQocmVsYXRpdmUuaG9zdCk7XHJcbiAgICAgIH1cclxuICAgICAgcmVsYXRpdmUuaG9zdCA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyAmJiAocmVsUGF0aFswXSA9PT0gJycgfHwgc3JjUGF0aFswXSA9PT0gJycpO1xyXG4gIH1cclxuXHJcbiAgaWYgKGlzUmVsQWJzKSB7XHJcbiAgICAvLyBpdCdzIGFic29sdXRlLlxyXG4gICAgcmVzdWx0Lmhvc3QgPSAocmVsYXRpdmUuaG9zdCB8fCByZWxhdGl2ZS5ob3N0ID09PSAnJykgP1xyXG4gICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0IDogcmVzdWx0Lmhvc3Q7XHJcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAocmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdG5hbWUgPT09ICcnKSA/XHJcbiAgICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0bmFtZSA6IHJlc3VsdC5ob3N0bmFtZTtcclxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XHJcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcclxuICAgIHNyY1BhdGggPSByZWxQYXRoO1xyXG4gICAgLy8gZmFsbCB0aHJvdWdoIHRvIHRoZSBkb3QtaGFuZGxpbmcgYmVsb3cuXHJcbiAgfSBlbHNlIGlmIChyZWxQYXRoLmxlbmd0aCkge1xyXG4gICAgLy8gaXQncyByZWxhdGl2ZVxyXG4gICAgLy8gdGhyb3cgYXdheSB0aGUgZXhpc3RpbmcgZmlsZSwgYW5kIHRha2UgdGhlIG5ldyBwYXRoIGluc3RlYWQuXHJcbiAgICBpZiAoIXNyY1BhdGgpIHNyY1BhdGggPSBbXTtcclxuICAgIHNyY1BhdGgucG9wKCk7XHJcbiAgICBzcmNQYXRoID0gc3JjUGF0aC5jb25jYXQocmVsUGF0aCk7XHJcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xyXG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XHJcbiAgfSBlbHNlIGlmICghdXRpbC5pc051bGxPclVuZGVmaW5lZChyZWxhdGl2ZS5zZWFyY2gpKSB7XHJcbiAgICAvLyBqdXN0IHB1bGwgb3V0IHRoZSBzZWFyY2guXHJcbiAgICAvLyBsaWtlIGhyZWY9Jz9mb28nLlxyXG4gICAgLy8gUHV0IHRoaXMgYWZ0ZXIgdGhlIG90aGVyIHR3byBjYXNlcyBiZWNhdXNlIGl0IHNpbXBsaWZpZXMgdGhlIGJvb2xlYW5zXHJcbiAgICBpZiAocHN5Y2hvdGljKSB7XHJcbiAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gc3JjUGF0aC5zaGlmdCgpO1xyXG4gICAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XHJcbiAgICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxyXG4gICAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxyXG4gICAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcclxuICAgICAgaWYgKGF1dGhJbkhvc3QpIHtcclxuICAgICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcclxuICAgICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcclxuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xyXG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxyXG4gICAgaWYgKCF1dGlsLmlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICF1dGlsLmlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xyXG4gICAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xyXG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcclxuICAgIH1cclxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcblxyXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcclxuICAgIC8vIG5vIHBhdGggYXQgYWxsLiAgZWFzeS5cclxuICAgIC8vIHdlJ3ZlIGFscmVhZHkgaGFuZGxlZCB0aGUgb3RoZXIgc3R1ZmYgYWJvdmUuXHJcbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xyXG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxyXG4gICAgaWYgKHJlc3VsdC5zZWFyY2gpIHtcclxuICAgICAgcmVzdWx0LnBhdGggPSAnLycgKyByZXN1bHQuc2VhcmNoO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmVzdWx0LnBhdGggPSBudWxsO1xyXG4gICAgfVxyXG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxuXHJcbiAgLy8gaWYgYSB1cmwgRU5EcyBpbiAuIG9yIC4uLCB0aGVuIGl0IG11c3QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXHJcbiAgLy8gaG93ZXZlciwgaWYgaXQgZW5kcyBpbiBhbnl0aGluZyBlbHNlIG5vbi1zbGFzaHksXHJcbiAgLy8gdGhlbiBpdCBtdXN0IE5PVCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cclxuICB2YXIgbGFzdCA9IHNyY1BhdGguc2xpY2UoLTEpWzBdO1xyXG4gIHZhciBoYXNUcmFpbGluZ1NsYXNoID0gKFxyXG4gICAgICAocmVzdWx0Lmhvc3QgfHwgcmVsYXRpdmUuaG9zdCB8fCBzcmNQYXRoLmxlbmd0aCA+IDEpICYmXHJcbiAgICAgIChsYXN0ID09PSAnLicgfHwgbGFzdCA9PT0gJy4uJykgfHwgbGFzdCA9PT0gJycpO1xyXG5cclxuICAvLyBzdHJpcCBzaW5nbGUgZG90cywgcmVzb2x2ZSBkb3VibGUgZG90cyB0byBwYXJlbnQgZGlyXHJcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcclxuICB2YXIgdXAgPSAwO1xyXG4gIGZvciAodmFyIGkgPSBzcmNQYXRoLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcclxuICAgIGxhc3QgPSBzcmNQYXRoW2ldO1xyXG4gICAgaWYgKGxhc3QgPT09ICcuJykge1xyXG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcclxuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xyXG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcclxuICAgICAgdXArKztcclxuICAgIH0gZWxzZSBpZiAodXApIHtcclxuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XHJcbiAgICAgIHVwLS07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXHJcbiAgaWYgKCFtdXN0RW5kQWJzICYmICFyZW1vdmVBbGxEb3RzKSB7XHJcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcclxuICAgICAgc3JjUGF0aC51bnNoaWZ0KCcuLicpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKG11c3RFbmRBYnMgJiYgc3JjUGF0aFswXSAhPT0gJycgJiZcclxuICAgICAgKCFzcmNQYXRoWzBdIHx8IHNyY1BhdGhbMF0uY2hhckF0KDApICE9PSAnLycpKSB7XHJcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xyXG4gIH1cclxuXHJcbiAgaWYgKGhhc1RyYWlsaW5nU2xhc2ggJiYgKHNyY1BhdGguam9pbignLycpLnN1YnN0cigtMSkgIT09ICcvJykpIHtcclxuICAgIHNyY1BhdGgucHVzaCgnJyk7XHJcbiAgfVxyXG5cclxuICB2YXIgaXNBYnNvbHV0ZSA9IHNyY1BhdGhbMF0gPT09ICcnIHx8XHJcbiAgICAgIChzcmNQYXRoWzBdICYmIHNyY1BhdGhbMF0uY2hhckF0KDApID09PSAnLycpO1xyXG5cclxuICAvLyBwdXQgdGhlIGhvc3QgYmFja1xyXG4gIGlmIChwc3ljaG90aWMpIHtcclxuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gaXNBYnNvbHV0ZSA/ICcnIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjUGF0aC5sZW5ndGggPyBzcmNQYXRoLnNoaWZ0KCkgOiAnJztcclxuICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcclxuICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxyXG4gICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcclxuICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XHJcbiAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcclxuICAgIGlmIChhdXRoSW5Ib3N0KSB7XHJcbiAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xyXG4gICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzIHx8IChyZXN1bHQuaG9zdCAmJiBzcmNQYXRoLmxlbmd0aCk7XHJcblxyXG4gIGlmIChtdXN0RW5kQWJzICYmICFpc0Fic29sdXRlKSB7XHJcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xyXG4gIH1cclxuXHJcbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xyXG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcclxuICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcclxuICB9IGVsc2Uge1xyXG4gICAgcmVzdWx0LnBhdGhuYW1lID0gc3JjUGF0aC5qb2luKCcvJyk7XHJcbiAgfVxyXG5cclxuICAvL3RvIHN1cHBvcnQgcmVxdWVzdC5odHRwXHJcbiAgaWYgKCF1dGlsLmlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICF1dGlsLmlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xyXG4gICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcclxuICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xyXG4gIH1cclxuICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGggfHwgcmVzdWx0LmF1dGg7XHJcbiAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xyXG4gIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xyXG4gIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG5VcmwucHJvdG90eXBlLnBhcnNlSG9zdCA9IGZ1bmN0aW9uKCkge1xyXG4gIHZhciBob3N0ID0gdGhpcy5ob3N0O1xyXG4gIHZhciBwb3J0ID0gcG9ydFBhdHRlcm4uZXhlYyhob3N0KTtcclxuICBpZiAocG9ydCkge1xyXG4gICAgcG9ydCA9IHBvcnRbMF07XHJcbiAgICBpZiAocG9ydCAhPT0gJzonKSB7XHJcbiAgICAgIHRoaXMucG9ydCA9IHBvcnQuc3Vic3RyKDEpO1xyXG4gICAgfVxyXG4gICAgaG9zdCA9IGhvc3Quc3Vic3RyKDAsIGhvc3QubGVuZ3RoIC0gcG9ydC5sZW5ndGgpO1xyXG4gIH1cclxuICBpZiAoaG9zdCkgdGhpcy5ob3N0bmFtZSA9IGhvc3Q7XHJcbn07XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///4\\n\")},function(module,exports){eval(\"throw new Error(\\\"Module build failed (from ./node_modules/babel-loader/lib/index.js):\\\\nError: ENOENT: no such file or directory, open 'C:\\\\\\\\Users\\\\\\\\DENN_\\\\\\\\OneDrive\\\\\\\\\\\\\\\\GitHub\\\\\\\\JavaScript2\\\\\\\\Dz-7\\\\\\\\node_modules\\\\\\\\node-libs-browser\\\\\\\\node_modules\\\\\\\\punycode\\\\\\\\package.json'\\\\n    at Object.fs.openSync (fs.js:646:18)\\\\n    at Object.fs.readFileSync (fs.js:551:33)\\\\n    at ConfigChainBuilder.addConfig (C:\\\\\\\\Users\\\\\\\\DENN_\\\\\\\\OneDrive\\\\\\\\\\\\\\\\GitHub\\\\\\\\JavaScript2\\\\\\\\Dz-7\\\\\\\\node_modules\\\\\\\\babel-core\\\\\\\\lib\\\\\\\\transformation\\\\\\\\file\\\\\\\\options\\\\\\\\build-config-chain.js:146:32)\\\\n    at ConfigChainBuilder.findConfigs (C:\\\\\\\\Users\\\\\\\\DENN_\\\\\\\\OneDrive\\\\\\\\\\\\\\\\GitHub\\\\\\\\JavaScript2\\\\\\\\Dz-7\\\\\\\\node_modules\\\\\\\\babel-core\\\\\\\\lib\\\\\\\\transformation\\\\\\\\file\\\\\\\\options\\\\\\\\build-config-chain.js:102:30)\\\\n    at buildConfigChain (C:\\\\\\\\Users\\\\\\\\DENN_\\\\\\\\OneDrive\\\\\\\\\\\\\\\\GitHub\\\\\\\\JavaScript2\\\\\\\\Dz-7\\\\\\\\node_modules\\\\\\\\babel-core\\\\\\\\lib\\\\\\\\transformation\\\\\\\\file\\\\\\\\options\\\\\\\\build-config-chain.js:61:13)\\\\n    at OptionManager.init (C:\\\\\\\\Users\\\\\\\\DENN_\\\\\\\\OneDrive\\\\\\\\\\\\\\\\GitHub\\\\\\\\JavaScript2\\\\\\\\Dz-7\\\\\\\\node_modules\\\\\\\\babel-core\\\\\\\\lib\\\\\\\\transformation\\\\\\\\file\\\\\\\\options\\\\\\\\option-manager.js:354:58)\\\\n    at File.initOptions (C:\\\\\\\\Users\\\\\\\\DENN_\\\\\\\\OneDrive\\\\\\\\\\\\\\\\GitHub\\\\\\\\JavaScript2\\\\\\\\Dz-7\\\\\\\\node_modules\\\\\\\\babel-core\\\\\\\\lib\\\\\\\\transformation\\\\\\\\file\\\\\\\\index.js:212:65)\\\\n    at new File (C:\\\\\\\\Users\\\\\\\\DENN_\\\\\\\\OneDrive\\\\\\\\\\\\\\\\GitHub\\\\\\\\JavaScript2\\\\\\\\Dz-7\\\\\\\\node_modules\\\\\\\\babel-core\\\\\\\\lib\\\\\\\\transformation\\\\\\\\file\\\\\\\\index.js:135:24)\\\\n    at Pipeline.transform (C:\\\\\\\\Users\\\\\\\\DENN_\\\\\\\\OneDrive\\\\\\\\\\\\\\\\GitHub\\\\\\\\JavaScript2\\\\\\\\Dz-7\\\\\\\\node_modules\\\\\\\\babel-core\\\\\\\\lib\\\\\\\\transformation\\\\\\\\pipeline.js:46:16)\\\\n    at transpile (C:\\\\\\\\Users\\\\\\\\DENN_\\\\\\\\OneDrive\\\\\\\\\\\\\\\\GitHub\\\\\\\\JavaScript2\\\\\\\\Dz-7\\\\\\\\node_modules\\\\\\\\babel-loader\\\\\\\\lib\\\\\\\\index.js:50:20)\\\\n    at Object.module.exports (C:\\\\\\\\Users\\\\\\\\DENN_\\\\\\\\OneDrive\\\\\\\\\\\\\\\\GitHub\\\\\\\\JavaScript2\\\\\\\\Dz-7\\\\\\\\node_modules\\\\\\\\babel-loader\\\\\\\\lib\\\\\\\\index.js:173:20)\\\");//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiI1LmpzIiwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///5\\n\")},,function(module,exports,__webpack_require__){\"use strict\";eval(\"\\n\\nmodule.exports = {\\n  isString: function (arg) {\\n    return typeof arg === 'string';\\n  },\\n  isObject: function (arg) {\\n    return typeof arg === 'object' && arg !== null;\\n  },\\n  isNull: function (arg) {\\n    return arg === null;\\n  },\\n  isNullOrUndefined: function (arg) {\\n    return arg == null;\\n  }\\n};//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXJsL3V0aWwuanM/MzVlOCJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiaXNTdHJpbmciLCJhcmciLCJpc09iamVjdCIsImlzTnVsbCIsImlzTnVsbE9yVW5kZWZpbmVkIl0sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYkEsT0FBT0MsT0FBUCxHQUFpQjtBQUNmQyxZQUFVLFVBQVNDLEdBQVQsRUFBYztBQUN0QixXQUFPLE9BQU9BLEdBQVAsS0FBZ0IsUUFBdkI7QUFDRCxHQUhjO0FBSWZDLFlBQVUsVUFBU0QsR0FBVCxFQUFjO0FBQ3RCLFdBQU8sT0FBT0EsR0FBUCxLQUFnQixRQUFoQixJQUE0QkEsUUFBUSxJQUEzQztBQUNELEdBTmM7QUFPZkUsVUFBUSxVQUFTRixHQUFULEVBQWM7QUFDcEIsV0FBT0EsUUFBUSxJQUFmO0FBQ0QsR0FUYztBQVVmRyxxQkFBbUIsVUFBU0gsR0FBVCxFQUFjO0FBQy9CLFdBQU9BLE9BQU8sSUFBZDtBQUNEO0FBWmMsQ0FBakIiLCJmaWxlIjoiNy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gIGlzU3RyaW5nOiBmdW5jdGlvbihhcmcpIHtcclxuICAgIHJldHVybiB0eXBlb2YoYXJnKSA9PT0gJ3N0cmluZyc7XHJcbiAgfSxcclxuICBpc09iamVjdDogZnVuY3Rpb24oYXJnKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mKGFyZykgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcclxuICB9LFxyXG4gIGlzTnVsbDogZnVuY3Rpb24oYXJnKSB7XHJcbiAgICByZXR1cm4gYXJnID09PSBudWxsO1xyXG4gIH0sXHJcbiAgaXNOdWxsT3JVbmRlZmluZWQ6IGZ1bmN0aW9uKGFyZykge1xyXG4gICAgcmV0dXJuIGFyZyA9PSBudWxsO1xyXG4gIH1cclxufTtcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///7\\n\")},function(module,exports){eval(\"throw new Error(\\\"Module build failed (from ./node_modules/babel-loader/lib/index.js):\\\\nError: ENOENT: no such file or directory, open 'C:\\\\\\\\Users\\\\\\\\DENN_\\\\\\\\OneDrive\\\\\\\\\\\\\\\\GitHub\\\\\\\\JavaScript2\\\\\\\\Dz-7\\\\\\\\node_modules\\\\\\\\querystring-es3\\\\\\\\index.js'\\\");//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiI4LmpzIiwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///8\\n\")},,,function(module,exports,__webpack_require__){\"use strict\";eval(\"\\n\\nvar ansiRegex = __webpack_require__(12)();\\n\\nmodule.exports = function (str) {\\n\\treturn typeof str === 'string' ? str.replace(ansiRegex, '') : str;\\n};//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvbm9kZV9tb2R1bGVzL3N0cmlwLWFuc2kvaW5kZXguanM/OTc1MSJdLCJuYW1lcyI6WyJhbnNpUmVnZXgiLCJyZXF1aXJlIiwibW9kdWxlIiwiZXhwb3J0cyIsInN0ciIsInJlcGxhY2UiXSwibWFwcGluZ3MiOiJBQUFhOztBQUNiLElBQUlBLFlBQVlDLG1CQUFPQSxDQUFDLEVBQVIsR0FBaEI7O0FBRUFDLE9BQU9DLE9BQVAsR0FBaUIsVUFBVUMsR0FBVixFQUFlO0FBQy9CLFFBQU8sT0FBT0EsR0FBUCxLQUFlLFFBQWYsR0FBMEJBLElBQUlDLE9BQUosQ0FBWUwsU0FBWixFQUF1QixFQUF2QixDQUExQixHQUF1REksR0FBOUQ7QUFDQSxDQUZEIiwiZmlsZSI6IjExLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG52YXIgYW5zaVJlZ2V4ID0gcmVxdWlyZSgnYW5zaS1yZWdleCcpKCk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHIpIHtcclxuXHRyZXR1cm4gdHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgPyBzdHIucmVwbGFjZShhbnNpUmVnZXgsICcnKSA6IHN0cjtcclxufTtcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///11\\n\")},function(module,exports,__webpack_require__){\"use strict\";eval(\"\\n\\nmodule.exports = function () {\\n\\treturn (/[\\\\u001b\\\\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]/g\\n\\t);\\n};//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvbm9kZV9tb2R1bGVzL2Fuc2ktcmVnZXgvaW5kZXguanM/MzQ5NCJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiQUFBYTs7QUFDYkEsT0FBT0MsT0FBUCxHQUFpQixZQUFZO0FBQzVCLFFBQU87QUFBUDtBQUNBLENBRkQiLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xyXG5cdHJldHVybiAvW1xcdTAwMWJcXHUwMDliXVtbKCkjOz9dKig/OlswLTldezEsNH0oPzo7WzAtOV17MCw0fSkqKT9bMC05QS1QUlpjZi1ucXJ5PT48XS9nO1xyXG59O1xyXG4iXSwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///12\\n\")},function(module,exports){eval(\"throw new Error(\\\"Module build failed (from ./node_modules/babel-loader/lib/index.js):\\\\nError: ENOENT: no such file or directory, open 'C:\\\\\\\\Users\\\\\\\\DENN_\\\\\\\\OneDrive\\\\\\\\\\\\\\\\GitHub\\\\\\\\JavaScript2\\\\\\\\Dz-7\\\\\\\\node_modules\\\\\\\\loglevel\\\\\\\\package.json'\\\\n    at Object.fs.openSync (fs.js:646:18)\\\\n    at Object.fs.readFileSync (fs.js:551:33)\\\\n    at ConfigChainBuilder.addConfig (C:\\\\\\\\Users\\\\\\\\DENN_\\\\\\\\OneDrive\\\\\\\\\\\\\\\\GitHub\\\\\\\\JavaScript2\\\\\\\\Dz-7\\\\\\\\node_modules\\\\\\\\babel-core\\\\\\\\lib\\\\\\\\transformation\\\\\\\\file\\\\\\\\options\\\\\\\\build-config-chain.js:146:32)\\\\n    at ConfigChainBuilder.findConfigs (C:\\\\\\\\Users\\\\\\\\DENN_\\\\\\\\OneDrive\\\\\\\\\\\\\\\\GitHub\\\\\\\\JavaScript2\\\\\\\\Dz-7\\\\\\\\node_modules\\\\\\\\babel-core\\\\\\\\lib\\\\\\\\transformation\\\\\\\\file\\\\\\\\options\\\\\\\\build-config-chain.js:102:30)\\\\n    at buildConfigChain (C:\\\\\\\\Users\\\\\\\\DENN_\\\\\\\\OneDrive\\\\\\\\\\\\\\\\GitHub\\\\\\\\JavaScript2\\\\\\\\Dz-7\\\\\\\\node_modules\\\\\\\\babel-core\\\\\\\\lib\\\\\\\\transformation\\\\\\\\file\\\\\\\\options\\\\\\\\build-config-chain.js:61:13)\\\\n    at OptionManager.init (C:\\\\\\\\Users\\\\\\\\DENN_\\\\\\\\OneDrive\\\\\\\\\\\\\\\\GitHub\\\\\\\\JavaScript2\\\\\\\\Dz-7\\\\\\\\node_modules\\\\\\\\babel-core\\\\\\\\lib\\\\\\\\transformation\\\\\\\\file\\\\\\\\options\\\\\\\\option-manager.js:354:58)\\\\n    at File.initOptions (C:\\\\\\\\Users\\\\\\\\DENN_\\\\\\\\OneDrive\\\\\\\\\\\\\\\\GitHub\\\\\\\\JavaScript2\\\\\\\\Dz-7\\\\\\\\node_modules\\\\\\\\babel-core\\\\\\\\lib\\\\\\\\transformation\\\\\\\\file\\\\\\\\index.js:212:65)\\\\n    at new File (C:\\\\\\\\Users\\\\\\\\DENN_\\\\\\\\OneDrive\\\\\\\\\\\\\\\\GitHub\\\\\\\\JavaScript2\\\\\\\\Dz-7\\\\\\\\node_modules\\\\\\\\babel-core\\\\\\\\lib\\\\\\\\transformation\\\\\\\\file\\\\\\\\index.js:135:24)\\\\n    at Pipeline.transform (C:\\\\\\\\Users\\\\\\\\DENN_\\\\\\\\OneDrive\\\\\\\\\\\\\\\\GitHub\\\\\\\\JavaScript2\\\\\\\\Dz-7\\\\\\\\node_modules\\\\\\\\babel-core\\\\\\\\lib\\\\\\\\transformation\\\\\\\\pipeline.js:46:16)\\\\n    at transpile (C:\\\\\\\\Users\\\\\\\\DENN_\\\\\\\\OneDrive\\\\\\\\\\\\\\\\GitHub\\\\\\\\JavaScript2\\\\\\\\Dz-7\\\\\\\\node_modules\\\\\\\\babel-loader\\\\\\\\lib\\\\\\\\index.js:50:20)\\\\n    at Object.module.exports (C:\\\\\\\\Users\\\\\\\\DENN_\\\\\\\\OneDrive\\\\\\\\\\\\\\\\GitHub\\\\\\\\JavaScript2\\\\\\\\Dz-7\\\\\\\\node_modules\\\\\\\\babel-loader\\\\\\\\lib\\\\\\\\index.js:173:20)\\\");//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiIxMy5qcyIsInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///13\\n\")},function(module,exports,__webpack_require__){\"use strict\";eval(\"\\n\\nvar SockJS = __webpack_require__(15);\\n\\nvar retries = 0;\\nvar sock = null;\\n\\nvar socket = function initSocket(url, handlers) {\\n  sock = new SockJS(url);\\n\\n  sock.onopen = function onopen() {\\n    retries = 0;\\n  };\\n\\n  sock.onclose = function onclose() {\\n    if (retries === 0) {\\n      handlers.close();\\n    }\\n\\n    // Try to reconnect.\\n    sock = null;\\n\\n    // After 10 retries stop trying, to prevent logspam.\\n    if (retries <= 10) {\\n      // Exponentially increase timeout to reconnect.\\n      // Respectfully copied from the package `got`.\\n      // eslint-disable-next-line no-mixed-operators, no-restricted-properties\\n      var retryInMs = 1000 * Math.pow(2, retries) + Math.random() * 100;\\n      retries += 1;\\n\\n      setTimeout(function () {\\n        socket(url, handlers);\\n      }, retryInMs);\\n    }\\n  };\\n\\n  sock.onmessage = function onmessage(e) {\\n    // This assumes that all data sent via the websocket is JSON.\\n    var msg = JSON.parse(e.data);\\n    if (handlers[msg.type]) {\\n      handlers[msg.type](msg.data);\\n    }\\n  };\\n};\\n\\nmodule.exports = socket;//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvY2xpZW50L3NvY2tldC5qcz9lMjljIl0sIm5hbWVzIjpbIlNvY2tKUyIsInJlcXVpcmUiLCJyZXRyaWVzIiwic29jayIsInNvY2tldCIsImluaXRTb2NrZXQiLCJ1cmwiLCJoYW5kbGVycyIsIm9ub3BlbiIsIm9uY2xvc2UiLCJjbG9zZSIsInJldHJ5SW5NcyIsIk1hdGgiLCJwb3ciLCJyYW5kb20iLCJzZXRUaW1lb3V0Iiwib25tZXNzYWdlIiwiZSIsIm1zZyIsIkpTT04iLCJwYXJzZSIsImRhdGEiLCJ0eXBlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsSUFBSUEsU0FBU0MsbUJBQU9BLENBQUMsRUFBUixDQUFiOztBQUVBLElBQUlDLFVBQVUsQ0FBZDtBQUNBLElBQUlDLE9BQU8sSUFBWDs7QUFFQSxJQUFJQyxTQUFTLFNBQVNDLFVBQVQsQ0FBb0JDLEdBQXBCLEVBQXlCQyxRQUF6QixFQUFtQztBQUM5Q0osU0FBTyxJQUFJSCxNQUFKLENBQVdNLEdBQVgsQ0FBUDs7QUFFQUgsT0FBS0ssTUFBTCxHQUFjLFNBQVNBLE1BQVQsR0FBa0I7QUFDOUJOLGNBQVUsQ0FBVjtBQUNELEdBRkQ7O0FBSUFDLE9BQUtNLE9BQUwsR0FBZSxTQUFTQSxPQUFULEdBQW1CO0FBQ2hDLFFBQUlQLFlBQVksQ0FBaEIsRUFBbUI7QUFDakJLLGVBQVNHLEtBQVQ7QUFDRDs7QUFFRDtBQUNBUCxXQUFPLElBQVA7O0FBRUE7QUFDQSxRQUFJRCxXQUFXLEVBQWYsRUFBbUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsVUFBSVMsWUFBWSxPQUFPQyxLQUFLQyxHQUFMLENBQVMsQ0FBVCxFQUFZWCxPQUFaLENBQVAsR0FBOEJVLEtBQUtFLE1BQUwsS0FBZ0IsR0FBOUQ7QUFDQVosaUJBQVcsQ0FBWDs7QUFFQWEsaUJBQVcsWUFBWTtBQUNyQlgsZUFBT0UsR0FBUCxFQUFZQyxRQUFaO0FBQ0QsT0FGRCxFQUVHSSxTQUZIO0FBR0Q7QUFDRixHQXBCRDs7QUFzQkFSLE9BQUthLFNBQUwsR0FBaUIsU0FBU0EsU0FBVCxDQUFtQkMsQ0FBbkIsRUFBc0I7QUFDckM7QUFDQSxRQUFJQyxNQUFNQyxLQUFLQyxLQUFMLENBQVdILEVBQUVJLElBQWIsQ0FBVjtBQUNBLFFBQUlkLFNBQVNXLElBQUlJLElBQWIsQ0FBSixFQUF3QjtBQUN0QmYsZUFBU1csSUFBSUksSUFBYixFQUFtQkosSUFBSUcsSUFBdkI7QUFDRDtBQUNGLEdBTkQ7QUFPRCxDQXBDRDs7QUFzQ0FFLE9BQU9DLE9BQVAsR0FBaUJwQixNQUFqQiIsImZpbGUiOiIxNC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBTb2NrSlMgPSByZXF1aXJlKCdzb2NranMtY2xpZW50L2Rpc3Qvc29ja2pzJyk7XHJcblxyXG52YXIgcmV0cmllcyA9IDA7XHJcbnZhciBzb2NrID0gbnVsbDtcclxuXHJcbnZhciBzb2NrZXQgPSBmdW5jdGlvbiBpbml0U29ja2V0KHVybCwgaGFuZGxlcnMpIHtcclxuICBzb2NrID0gbmV3IFNvY2tKUyh1cmwpO1xyXG5cclxuICBzb2NrLm9ub3BlbiA9IGZ1bmN0aW9uIG9ub3BlbigpIHtcclxuICAgIHJldHJpZXMgPSAwO1xyXG4gIH07XHJcblxyXG4gIHNvY2sub25jbG9zZSA9IGZ1bmN0aW9uIG9uY2xvc2UoKSB7XHJcbiAgICBpZiAocmV0cmllcyA9PT0gMCkge1xyXG4gICAgICBoYW5kbGVycy5jbG9zZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRyeSB0byByZWNvbm5lY3QuXHJcbiAgICBzb2NrID0gbnVsbDtcclxuXHJcbiAgICAvLyBBZnRlciAxMCByZXRyaWVzIHN0b3AgdHJ5aW5nLCB0byBwcmV2ZW50IGxvZ3NwYW0uXHJcbiAgICBpZiAocmV0cmllcyA8PSAxMCkge1xyXG4gICAgICAvLyBFeHBvbmVudGlhbGx5IGluY3JlYXNlIHRpbWVvdXQgdG8gcmVjb25uZWN0LlxyXG4gICAgICAvLyBSZXNwZWN0ZnVsbHkgY29waWVkIGZyb20gdGhlIHBhY2thZ2UgYGdvdGAuXHJcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1taXhlZC1vcGVyYXRvcnMsIG5vLXJlc3RyaWN0ZWQtcHJvcGVydGllc1xyXG4gICAgICB2YXIgcmV0cnlJbk1zID0gMTAwMCAqIE1hdGgucG93KDIsIHJldHJpZXMpICsgTWF0aC5yYW5kb20oKSAqIDEwMDtcclxuICAgICAgcmV0cmllcyArPSAxO1xyXG5cclxuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgc29ja2V0KHVybCwgaGFuZGxlcnMpO1xyXG4gICAgICB9LCByZXRyeUluTXMpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHNvY2sub25tZXNzYWdlID0gZnVuY3Rpb24gb25tZXNzYWdlKGUpIHtcclxuICAgIC8vIFRoaXMgYXNzdW1lcyB0aGF0IGFsbCBkYXRhIHNlbnQgdmlhIHRoZSB3ZWJzb2NrZXQgaXMgSlNPTi5cclxuICAgIHZhciBtc2cgPSBKU09OLnBhcnNlKGUuZGF0YSk7XHJcbiAgICBpZiAoaGFuZGxlcnNbbXNnLnR5cGVdKSB7XHJcbiAgICAgIGhhbmRsZXJzW21zZy50eXBlXShtc2cuZGF0YSk7XHJcbiAgICB9XHJcbiAgfTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gc29ja2V0OyJdLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///14\\n\")},function(module,exports,__webpack_require__){eval(\"/* WEBPACK VAR INJECTION */(function(global) {var require;var require;/* sockjs-client v1.1.5 | http://sockjs.org | MIT license */\\n(function (f) {\\n  if (true) {\\n    module.exports = f();\\n  } else { var g; }\\n})(function () {\\n  var define, module, exports;return function () {\\n    function r(e, n, t) {\\n      function o(i, f) {\\n        if (!n[i]) {\\n          if (!e[i]) {\\n            var c = \\\"function\\\" == typeof require && require;if (!f && c) return require(i, !0);if (u) return u(i, !0);var a = new Error(\\\"Cannot find module '\\\" + i + \\\"'\\\");throw a.code = \\\"MODULE_NOT_FOUND\\\", a;\\n          }var p = n[i] = { exports: {} };e[i][0].call(p.exports, function (r) {\\n            var n = e[i][1][r];return o(n || r);\\n          }, p, p.exports, r, e, n, t);\\n        }return n[i].exports;\\n      }for (var u = \\\"function\\\" == typeof require && require, i = 0; i < t.length; i++) o(t[i]);return o;\\n    }return r;\\n  }()({ 1: [function (require, module, exports) {\\n      (function (global) {\\n        'use strict';\\n\\n        var transportList = require('./transport-list');\\n\\n        module.exports = require('./main')(transportList);\\n\\n        // TODO can't get rid of this until all servers do\\n        if ('_sockjs_onload' in global) {\\n          setTimeout(global._sockjs_onload, 1);\\n        }\\n      }).call(this, typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {});\\n    }, { \\\"./main\\\": 14, \\\"./transport-list\\\": 16 }], 2: [function (require, module, exports) {\\n      'use strict';\\n\\n      var inherits = require('inherits'),\\n          Event = require('./event');\\n\\n      function CloseEvent() {\\n        Event.call(this);\\n        this.initEvent('close', false, false);\\n        this.wasClean = false;\\n        this.code = 0;\\n        this.reason = '';\\n      }\\n\\n      inherits(CloseEvent, Event);\\n\\n      module.exports = CloseEvent;\\n    }, { \\\"./event\\\": 4, \\\"inherits\\\": 56 }], 3: [function (require, module, exports) {\\n      'use strict';\\n\\n      var inherits = require('inherits'),\\n          EventTarget = require('./eventtarget');\\n\\n      function EventEmitter() {\\n        EventTarget.call(this);\\n      }\\n\\n      inherits(EventEmitter, EventTarget);\\n\\n      EventEmitter.prototype.removeAllListeners = function (type) {\\n        if (type) {\\n          delete this._listeners[type];\\n        } else {\\n          this._listeners = {};\\n        }\\n      };\\n\\n      EventEmitter.prototype.once = function (type, listener) {\\n        var self = this,\\n            fired = false;\\n\\n        function g() {\\n          self.removeListener(type, g);\\n\\n          if (!fired) {\\n            fired = true;\\n            listener.apply(this, arguments);\\n          }\\n        }\\n\\n        this.on(type, g);\\n      };\\n\\n      EventEmitter.prototype.emit = function () {\\n        var type = arguments[0];\\n        var listeners = this._listeners[type];\\n        if (!listeners) {\\n          return;\\n        }\\n        // equivalent of Array.prototype.slice.call(arguments, 1);\\n        var l = arguments.length;\\n        var args = new Array(l - 1);\\n        for (var ai = 1; ai < l; ai++) {\\n          args[ai - 1] = arguments[ai];\\n        }\\n        for (var i = 0; i < listeners.length; i++) {\\n          listeners[i].apply(this, args);\\n        }\\n      };\\n\\n      EventEmitter.prototype.on = EventEmitter.prototype.addListener = EventTarget.prototype.addEventListener;\\n      EventEmitter.prototype.removeListener = EventTarget.prototype.removeEventListener;\\n\\n      module.exports.EventEmitter = EventEmitter;\\n    }, { \\\"./eventtarget\\\": 5, \\\"inherits\\\": 56 }], 4: [function (require, module, exports) {\\n      'use strict';\\n\\n      function Event(eventType) {\\n        this.type = eventType;\\n      }\\n\\n      Event.prototype.initEvent = function (eventType, canBubble, cancelable) {\\n        this.type = eventType;\\n        this.bubbles = canBubble;\\n        this.cancelable = cancelable;\\n        this.timeStamp = +new Date();\\n        return this;\\n      };\\n\\n      Event.prototype.stopPropagation = function () {};\\n      Event.prototype.preventDefault = function () {};\\n\\n      Event.CAPTURING_PHASE = 1;\\n      Event.AT_TARGET = 2;\\n      Event.BUBBLING_PHASE = 3;\\n\\n      module.exports = Event;\\n    }, {}], 5: [function (require, module, exports) {\\n      'use strict';\\n\\n      /* Simplified implementation of DOM2 EventTarget.\\r\\n       *   http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget\\r\\n       */\\n\\n      function EventTarget() {\\n        this._listeners = {};\\n      }\\n\\n      EventTarget.prototype.addEventListener = function (eventType, listener) {\\n        if (!(eventType in this._listeners)) {\\n          this._listeners[eventType] = [];\\n        }\\n        var arr = this._listeners[eventType];\\n        // #4\\n        if (arr.indexOf(listener) === -1) {\\n          // Make a copy so as not to interfere with a current dispatchEvent.\\n          arr = arr.concat([listener]);\\n        }\\n        this._listeners[eventType] = arr;\\n      };\\n\\n      EventTarget.prototype.removeEventListener = function (eventType, listener) {\\n        var arr = this._listeners[eventType];\\n        if (!arr) {\\n          return;\\n        }\\n        var idx = arr.indexOf(listener);\\n        if (idx !== -1) {\\n          if (arr.length > 1) {\\n            // Make a copy so as not to interfere with a current dispatchEvent.\\n            this._listeners[eventType] = arr.slice(0, idx).concat(arr.slice(idx + 1));\\n          } else {\\n            delete this._listeners[eventType];\\n          }\\n          return;\\n        }\\n      };\\n\\n      EventTarget.prototype.dispatchEvent = function () {\\n        var event = arguments[0];\\n        var t = event.type;\\n        // equivalent of Array.prototype.slice.call(arguments, 0);\\n        var args = arguments.length === 1 ? [event] : Array.apply(null, arguments);\\n        // TODO: This doesn't match the real behavior; per spec, onfoo get\\n        // their place in line from the /first/ time they're set from\\n        // non-null. Although WebKit bumps it to the end every time it's\\n        // set.\\n        if (this['on' + t]) {\\n          this['on' + t].apply(this, args);\\n        }\\n        if (t in this._listeners) {\\n          // Grab a reference to the listeners list. removeEventListener may alter the list.\\n          var listeners = this._listeners[t];\\n          for (var i = 0; i < listeners.length; i++) {\\n            listeners[i].apply(this, args);\\n          }\\n        }\\n      };\\n\\n      module.exports = EventTarget;\\n    }, {}], 6: [function (require, module, exports) {\\n      'use strict';\\n\\n      var inherits = require('inherits'),\\n          Event = require('./event');\\n\\n      function TransportMessageEvent(data) {\\n        Event.call(this);\\n        this.initEvent('message', false, false);\\n        this.data = data;\\n      }\\n\\n      inherits(TransportMessageEvent, Event);\\n\\n      module.exports = TransportMessageEvent;\\n    }, { \\\"./event\\\": 4, \\\"inherits\\\": 56 }], 7: [function (require, module, exports) {\\n      'use strict';\\n\\n      var JSON3 = require('json3'),\\n          iframeUtils = require('./utils/iframe');\\n\\n      function FacadeJS(transport) {\\n        this._transport = transport;\\n        transport.on('message', this._transportMessage.bind(this));\\n        transport.on('close', this._transportClose.bind(this));\\n      }\\n\\n      FacadeJS.prototype._transportClose = function (code, reason) {\\n        iframeUtils.postMessage('c', JSON3.stringify([code, reason]));\\n      };\\n      FacadeJS.prototype._transportMessage = function (frame) {\\n        iframeUtils.postMessage('t', frame);\\n      };\\n      FacadeJS.prototype._send = function (data) {\\n        this._transport.send(data);\\n      };\\n      FacadeJS.prototype._close = function () {\\n        this._transport.close();\\n        this._transport.removeAllListeners();\\n      };\\n\\n      module.exports = FacadeJS;\\n    }, { \\\"./utils/iframe\\\": 47, \\\"json3\\\": 57 }], 8: [function (require, module, exports) {\\n      (function (process) {\\n        'use strict';\\n\\n        var urlUtils = require('./utils/url'),\\n            eventUtils = require('./utils/event'),\\n            JSON3 = require('json3'),\\n            FacadeJS = require('./facade'),\\n            InfoIframeReceiver = require('./info-iframe-receiver'),\\n            iframeUtils = require('./utils/iframe'),\\n            loc = require('./location');\\n\\n        var debug = function () {};\\n        if (process.env.NODE_ENV !== 'production') {\\n          debug = require('debug')('sockjs-client:iframe-bootstrap');\\n        }\\n\\n        module.exports = function (SockJS, availableTransports) {\\n          var transportMap = {};\\n          availableTransports.forEach(function (at) {\\n            if (at.facadeTransport) {\\n              transportMap[at.facadeTransport.transportName] = at.facadeTransport;\\n            }\\n          });\\n\\n          // hard-coded for the info iframe\\n          // TODO see if we can make this more dynamic\\n          transportMap[InfoIframeReceiver.transportName] = InfoIframeReceiver;\\n          var parentOrigin;\\n\\n          /* eslint-disable camelcase */\\n          SockJS.bootstrap_iframe = function () {\\n            /* eslint-enable camelcase */\\n            var facade;\\n            iframeUtils.currentWindowId = loc.hash.slice(1);\\n            var onMessage = function (e) {\\n              if (e.source !== parent) {\\n                return;\\n              }\\n              if (typeof parentOrigin === 'undefined') {\\n                parentOrigin = e.origin;\\n              }\\n              if (e.origin !== parentOrigin) {\\n                return;\\n              }\\n\\n              var iframeMessage;\\n              try {\\n                iframeMessage = JSON3.parse(e.data);\\n              } catch (ignored) {\\n                debug('bad json', e.data);\\n                return;\\n              }\\n\\n              if (iframeMessage.windowId !== iframeUtils.currentWindowId) {\\n                return;\\n              }\\n              switch (iframeMessage.type) {\\n                case 's':\\n                  var p;\\n                  try {\\n                    p = JSON3.parse(iframeMessage.data);\\n                  } catch (ignored) {\\n                    debug('bad json', iframeMessage.data);\\n                    break;\\n                  }\\n                  var version = p[0];\\n                  var transport = p[1];\\n                  var transUrl = p[2];\\n                  var baseUrl = p[3];\\n                  debug(version, transport, transUrl, baseUrl);\\n                  // change this to semver logic\\n                  if (version !== SockJS.version) {\\n                    throw new Error('Incompatible SockJS! Main site uses:' + ' \\\"' + version + '\\\", the iframe:' + ' \\\"' + SockJS.version + '\\\".');\\n                  }\\n\\n                  if (!urlUtils.isOriginEqual(transUrl, loc.href) || !urlUtils.isOriginEqual(baseUrl, loc.href)) {\\n                    throw new Error('Can\\\\'t connect to different domain from within an ' + 'iframe. (' + loc.href + ', ' + transUrl + ', ' + baseUrl + ')');\\n                  }\\n                  facade = new FacadeJS(new transportMap[transport](transUrl, baseUrl));\\n                  break;\\n                case 'm':\\n                  facade._send(iframeMessage.data);\\n                  break;\\n                case 'c':\\n                  if (facade) {\\n                    facade._close();\\n                  }\\n                  facade = null;\\n                  break;\\n              }\\n            };\\n\\n            eventUtils.attachEvent('message', onMessage);\\n\\n            // Start\\n            iframeUtils.postMessage('s');\\n          };\\n        };\\n      }).call(this, { env: {} });\\n    }, { \\\"./facade\\\": 7, \\\"./info-iframe-receiver\\\": 10, \\\"./location\\\": 13, \\\"./utils/event\\\": 46, \\\"./utils/iframe\\\": 47, \\\"./utils/url\\\": 52, \\\"debug\\\": 54, \\\"json3\\\": 57 }], 9: [function (require, module, exports) {\\n      (function (process) {\\n        'use strict';\\n\\n        var EventEmitter = require('events').EventEmitter,\\n            inherits = require('inherits'),\\n            JSON3 = require('json3'),\\n            objectUtils = require('./utils/object');\\n\\n        var debug = function () {};\\n        if (process.env.NODE_ENV !== 'production') {\\n          debug = require('debug')('sockjs-client:info-ajax');\\n        }\\n\\n        function InfoAjax(url, AjaxObject) {\\n          EventEmitter.call(this);\\n\\n          var self = this;\\n          var t0 = +new Date();\\n          this.xo = new AjaxObject('GET', url);\\n\\n          this.xo.once('finish', function (status, text) {\\n            var info, rtt;\\n            if (status === 200) {\\n              rtt = +new Date() - t0;\\n              if (text) {\\n                try {\\n                  info = JSON3.parse(text);\\n                } catch (e) {\\n                  debug('bad json', text);\\n                }\\n              }\\n\\n              if (!objectUtils.isObject(info)) {\\n                info = {};\\n              }\\n            }\\n            self.emit('finish', info, rtt);\\n            self.removeAllListeners();\\n          });\\n        }\\n\\n        inherits(InfoAjax, EventEmitter);\\n\\n        InfoAjax.prototype.close = function () {\\n          this.removeAllListeners();\\n          this.xo.close();\\n        };\\n\\n        module.exports = InfoAjax;\\n      }).call(this, { env: {} });\\n    }, { \\\"./utils/object\\\": 49, \\\"debug\\\": 54, \\\"events\\\": 3, \\\"inherits\\\": 56, \\\"json3\\\": 57 }], 10: [function (require, module, exports) {\\n      'use strict';\\n\\n      var inherits = require('inherits'),\\n          EventEmitter = require('events').EventEmitter,\\n          JSON3 = require('json3'),\\n          XHRLocalObject = require('./transport/sender/xhr-local'),\\n          InfoAjax = require('./info-ajax');\\n\\n      function InfoReceiverIframe(transUrl) {\\n        var self = this;\\n        EventEmitter.call(this);\\n\\n        this.ir = new InfoAjax(transUrl, XHRLocalObject);\\n        this.ir.once('finish', function (info, rtt) {\\n          self.ir = null;\\n          self.emit('message', JSON3.stringify([info, rtt]));\\n        });\\n      }\\n\\n      inherits(InfoReceiverIframe, EventEmitter);\\n\\n      InfoReceiverIframe.transportName = 'iframe-info-receiver';\\n\\n      InfoReceiverIframe.prototype.close = function () {\\n        if (this.ir) {\\n          this.ir.close();\\n          this.ir = null;\\n        }\\n        this.removeAllListeners();\\n      };\\n\\n      module.exports = InfoReceiverIframe;\\n    }, { \\\"./info-ajax\\\": 9, \\\"./transport/sender/xhr-local\\\": 37, \\\"events\\\": 3, \\\"inherits\\\": 56, \\\"json3\\\": 57 }], 11: [function (require, module, exports) {\\n      (function (process, global) {\\n        'use strict';\\n\\n        var EventEmitter = require('events').EventEmitter,\\n            inherits = require('inherits'),\\n            JSON3 = require('json3'),\\n            utils = require('./utils/event'),\\n            IframeTransport = require('./transport/iframe'),\\n            InfoReceiverIframe = require('./info-iframe-receiver');\\n\\n        var debug = function () {};\\n        if (process.env.NODE_ENV !== 'production') {\\n          debug = require('debug')('sockjs-client:info-iframe');\\n        }\\n\\n        function InfoIframe(baseUrl, url) {\\n          var self = this;\\n          EventEmitter.call(this);\\n\\n          var go = function () {\\n            var ifr = self.ifr = new IframeTransport(InfoReceiverIframe.transportName, url, baseUrl);\\n\\n            ifr.once('message', function (msg) {\\n              if (msg) {\\n                var d;\\n                try {\\n                  d = JSON3.parse(msg);\\n                } catch (e) {\\n                  debug('bad json', msg);\\n                  self.emit('finish');\\n                  self.close();\\n                  return;\\n                }\\n\\n                var info = d[0],\\n                    rtt = d[1];\\n                self.emit('finish', info, rtt);\\n              }\\n              self.close();\\n            });\\n\\n            ifr.once('close', function () {\\n              self.emit('finish');\\n              self.close();\\n            });\\n          };\\n\\n          // TODO this seems the same as the 'needBody' from transports\\n          if (!global.document.body) {\\n            utils.attachEvent('load', go);\\n          } else {\\n            go();\\n          }\\n        }\\n\\n        inherits(InfoIframe, EventEmitter);\\n\\n        InfoIframe.enabled = function () {\\n          return IframeTransport.enabled();\\n        };\\n\\n        InfoIframe.prototype.close = function () {\\n          if (this.ifr) {\\n            this.ifr.close();\\n          }\\n          this.removeAllListeners();\\n          this.ifr = null;\\n        };\\n\\n        module.exports = InfoIframe;\\n      }).call(this, { env: {} }, typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {});\\n    }, { \\\"./info-iframe-receiver\\\": 10, \\\"./transport/iframe\\\": 22, \\\"./utils/event\\\": 46, \\\"debug\\\": 54, \\\"events\\\": 3, \\\"inherits\\\": 56, \\\"json3\\\": 57 }], 12: [function (require, module, exports) {\\n      (function (process) {\\n        'use strict';\\n\\n        var EventEmitter = require('events').EventEmitter,\\n            inherits = require('inherits'),\\n            urlUtils = require('./utils/url'),\\n            XDR = require('./transport/sender/xdr'),\\n            XHRCors = require('./transport/sender/xhr-cors'),\\n            XHRLocal = require('./transport/sender/xhr-local'),\\n            XHRFake = require('./transport/sender/xhr-fake'),\\n            InfoIframe = require('./info-iframe'),\\n            InfoAjax = require('./info-ajax');\\n\\n        var debug = function () {};\\n        if (process.env.NODE_ENV !== 'production') {\\n          debug = require('debug')('sockjs-client:info-receiver');\\n        }\\n\\n        function InfoReceiver(baseUrl, urlInfo) {\\n          debug(baseUrl);\\n          var self = this;\\n          EventEmitter.call(this);\\n\\n          setTimeout(function () {\\n            self.doXhr(baseUrl, urlInfo);\\n          }, 0);\\n        }\\n\\n        inherits(InfoReceiver, EventEmitter);\\n\\n        // TODO this is currently ignoring the list of available transports and the whitelist\\n\\n        InfoReceiver._getReceiver = function (baseUrl, url, urlInfo) {\\n          // determine method of CORS support (if needed)\\n          if (urlInfo.sameOrigin) {\\n            return new InfoAjax(url, XHRLocal);\\n          }\\n          if (XHRCors.enabled) {\\n            return new InfoAjax(url, XHRCors);\\n          }\\n          if (XDR.enabled && urlInfo.sameScheme) {\\n            return new InfoAjax(url, XDR);\\n          }\\n          if (InfoIframe.enabled()) {\\n            return new InfoIframe(baseUrl, url);\\n          }\\n          return new InfoAjax(url, XHRFake);\\n        };\\n\\n        InfoReceiver.prototype.doXhr = function (baseUrl, urlInfo) {\\n          var self = this,\\n              url = urlUtils.addPath(baseUrl, '/info');\\n          debug('doXhr', url);\\n\\n          this.xo = InfoReceiver._getReceiver(baseUrl, url, urlInfo);\\n\\n          this.timeoutRef = setTimeout(function () {\\n            debug('timeout');\\n            self._cleanup(false);\\n            self.emit('finish');\\n          }, InfoReceiver.timeout);\\n\\n          this.xo.once('finish', function (info, rtt) {\\n            debug('finish', info, rtt);\\n            self._cleanup(true);\\n            self.emit('finish', info, rtt);\\n          });\\n        };\\n\\n        InfoReceiver.prototype._cleanup = function (wasClean) {\\n          debug('_cleanup');\\n          clearTimeout(this.timeoutRef);\\n          this.timeoutRef = null;\\n          if (!wasClean && this.xo) {\\n            this.xo.close();\\n          }\\n          this.xo = null;\\n        };\\n\\n        InfoReceiver.prototype.close = function () {\\n          debug('close');\\n          this.removeAllListeners();\\n          this._cleanup(false);\\n        };\\n\\n        InfoReceiver.timeout = 8000;\\n\\n        module.exports = InfoReceiver;\\n      }).call(this, { env: {} });\\n    }, { \\\"./info-ajax\\\": 9, \\\"./info-iframe\\\": 11, \\\"./transport/sender/xdr\\\": 34, \\\"./transport/sender/xhr-cors\\\": 35, \\\"./transport/sender/xhr-fake\\\": 36, \\\"./transport/sender/xhr-local\\\": 37, \\\"./utils/url\\\": 52, \\\"debug\\\": 54, \\\"events\\\": 3, \\\"inherits\\\": 56 }], 13: [function (require, module, exports) {\\n      (function (global) {\\n        'use strict';\\n\\n        module.exports = global.location || {\\n          origin: 'http://localhost:80',\\n          protocol: 'http:',\\n          host: 'localhost',\\n          port: 80,\\n          href: 'http://localhost/',\\n          hash: ''\\n        };\\n      }).call(this, typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {});\\n    }, {}], 14: [function (require, module, exports) {\\n      (function (process, global) {\\n        'use strict';\\n\\n        require('./shims');\\n\\n        var URL = require('url-parse'),\\n            inherits = require('inherits'),\\n            JSON3 = require('json3'),\\n            random = require('./utils/random'),\\n            escape = require('./utils/escape'),\\n            urlUtils = require('./utils/url'),\\n            eventUtils = require('./utils/event'),\\n            transport = require('./utils/transport'),\\n            objectUtils = require('./utils/object'),\\n            browser = require('./utils/browser'),\\n            log = require('./utils/log'),\\n            Event = require('./event/event'),\\n            EventTarget = require('./event/eventtarget'),\\n            loc = require('./location'),\\n            CloseEvent = require('./event/close'),\\n            TransportMessageEvent = require('./event/trans-message'),\\n            InfoReceiver = require('./info-receiver');\\n\\n        var debug = function () {};\\n        if (process.env.NODE_ENV !== 'production') {\\n          debug = require('debug')('sockjs-client:main');\\n        }\\n\\n        var transports;\\n\\n        // follow constructor steps defined at http://dev.w3.org/html5/websockets/#the-websocket-interface\\n        function SockJS(url, protocols, options) {\\n          if (!(this instanceof SockJS)) {\\n            return new SockJS(url, protocols, options);\\n          }\\n          if (arguments.length < 1) {\\n            throw new TypeError(\\\"Failed to construct 'SockJS: 1 argument required, but only 0 present\\\");\\n          }\\n          EventTarget.call(this);\\n\\n          this.readyState = SockJS.CONNECTING;\\n          this.extensions = '';\\n          this.protocol = '';\\n\\n          // non-standard extension\\n          options = options || {};\\n          if (options.protocols_whitelist) {\\n            log.warn(\\\"'protocols_whitelist' is DEPRECATED. Use 'transports' instead.\\\");\\n          }\\n          this._transportsWhitelist = options.transports;\\n          this._transportOptions = options.transportOptions || {};\\n\\n          var sessionId = options.sessionId || 8;\\n          if (typeof sessionId === 'function') {\\n            this._generateSessionId = sessionId;\\n          } else if (typeof sessionId === 'number') {\\n            this._generateSessionId = function () {\\n              return random.string(sessionId);\\n            };\\n          } else {\\n            throw new TypeError('If sessionId is used in the options, it needs to be a number or a function.');\\n          }\\n\\n          this._server = options.server || random.numberString(1000);\\n\\n          // Step 1 of WS spec - parse and validate the url. Issue #8\\n          var parsedUrl = new URL(url);\\n          if (!parsedUrl.host || !parsedUrl.protocol) {\\n            throw new SyntaxError(\\\"The URL '\\\" + url + \\\"' is invalid\\\");\\n          } else if (parsedUrl.hash) {\\n            throw new SyntaxError('The URL must not contain a fragment');\\n          } else if (parsedUrl.protocol !== 'http:' && parsedUrl.protocol !== 'https:') {\\n            throw new SyntaxError(\\\"The URL's scheme must be either 'http:' or 'https:'. '\\\" + parsedUrl.protocol + \\\"' is not allowed.\\\");\\n          }\\n\\n          var secure = parsedUrl.protocol === 'https:';\\n          // Step 2 - don't allow secure origin with an insecure protocol\\n          if (loc.protocol === 'https:' && !secure) {\\n            throw new Error('SecurityError: An insecure SockJS connection may not be initiated from a page loaded over HTTPS');\\n          }\\n\\n          // Step 3 - check port access - no need here\\n          // Step 4 - parse protocols argument\\n          if (!protocols) {\\n            protocols = [];\\n          } else if (!Array.isArray(protocols)) {\\n            protocols = [protocols];\\n          }\\n\\n          // Step 5 - check protocols argument\\n          var sortedProtocols = protocols.sort();\\n          sortedProtocols.forEach(function (proto, i) {\\n            if (!proto) {\\n              throw new SyntaxError(\\\"The protocols entry '\\\" + proto + \\\"' is invalid.\\\");\\n            }\\n            if (i < sortedProtocols.length - 1 && proto === sortedProtocols[i + 1]) {\\n              throw new SyntaxError(\\\"The protocols entry '\\\" + proto + \\\"' is duplicated.\\\");\\n            }\\n          });\\n\\n          // Step 6 - convert origin\\n          var o = urlUtils.getOrigin(loc.href);\\n          this._origin = o ? o.toLowerCase() : null;\\n\\n          // remove the trailing slash\\n          parsedUrl.set('pathname', parsedUrl.pathname.replace(/\\\\/+$/, ''));\\n\\n          // store the sanitized url\\n          this.url = parsedUrl.href;\\n          debug('using url', this.url);\\n\\n          // Step 7 - start connection in background\\n          // obtain server info\\n          // http://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html#section-26\\n          this._urlInfo = {\\n            nullOrigin: !browser.hasDomain(),\\n            sameOrigin: urlUtils.isOriginEqual(this.url, loc.href),\\n            sameScheme: urlUtils.isSchemeEqual(this.url, loc.href)\\n          };\\n\\n          this._ir = new InfoReceiver(this.url, this._urlInfo);\\n          this._ir.once('finish', this._receiveInfo.bind(this));\\n        }\\n\\n        inherits(SockJS, EventTarget);\\n\\n        function userSetCode(code) {\\n          return code === 1000 || code >= 3000 && code <= 4999;\\n        }\\n\\n        SockJS.prototype.close = function (code, reason) {\\n          // Step 1\\n          if (code && !userSetCode(code)) {\\n            throw new Error('InvalidAccessError: Invalid code');\\n          }\\n          // Step 2.4 states the max is 123 bytes, but we are just checking length\\n          if (reason && reason.length > 123) {\\n            throw new SyntaxError('reason argument has an invalid length');\\n          }\\n\\n          // Step 3.1\\n          if (this.readyState === SockJS.CLOSING || this.readyState === SockJS.CLOSED) {\\n            return;\\n          }\\n\\n          // TODO look at docs to determine how to set this\\n          var wasClean = true;\\n          this._close(code || 1000, reason || 'Normal closure', wasClean);\\n        };\\n\\n        SockJS.prototype.send = function (data) {\\n          // #13 - convert anything non-string to string\\n          // TODO this currently turns objects into [object Object]\\n          if (typeof data !== 'string') {\\n            data = '' + data;\\n          }\\n          if (this.readyState === SockJS.CONNECTING) {\\n            throw new Error('InvalidStateError: The connection has not been established yet');\\n          }\\n          if (this.readyState !== SockJS.OPEN) {\\n            return;\\n          }\\n          this._transport.send(escape.quote(data));\\n        };\\n\\n        SockJS.version = require('./version');\\n\\n        SockJS.CONNECTING = 0;\\n        SockJS.OPEN = 1;\\n        SockJS.CLOSING = 2;\\n        SockJS.CLOSED = 3;\\n\\n        SockJS.prototype._receiveInfo = function (info, rtt) {\\n          debug('_receiveInfo', rtt);\\n          this._ir = null;\\n          if (!info) {\\n            this._close(1002, 'Cannot connect to server');\\n            return;\\n          }\\n\\n          // establish a round-trip timeout (RTO) based on the\\n          // round-trip time (RTT)\\n          this._rto = this.countRTO(rtt);\\n          // allow server to override url used for the actual transport\\n          this._transUrl = info.base_url ? info.base_url : this.url;\\n          info = objectUtils.extend(info, this._urlInfo);\\n          debug('info', info);\\n          // determine list of desired and supported transports\\n          var enabledTransports = transports.filterToEnabled(this._transportsWhitelist, info);\\n          this._transports = enabledTransports.main;\\n          debug(this._transports.length + ' enabled transports');\\n\\n          this._connect();\\n        };\\n\\n        SockJS.prototype._connect = function () {\\n          for (var Transport = this._transports.shift(); Transport; Transport = this._transports.shift()) {\\n            debug('attempt', Transport.transportName);\\n            if (Transport.needBody) {\\n              if (!global.document.body || typeof global.document.readyState !== 'undefined' && global.document.readyState !== 'complete' && global.document.readyState !== 'interactive') {\\n                debug('waiting for body');\\n                this._transports.unshift(Transport);\\n                eventUtils.attachEvent('load', this._connect.bind(this));\\n                return;\\n              }\\n            }\\n\\n            // calculate timeout based on RTO and round trips. Default to 5s\\n            var timeoutMs = this._rto * Transport.roundTrips || 5000;\\n            this._transportTimeoutId = setTimeout(this._transportTimeout.bind(this), timeoutMs);\\n            debug('using timeout', timeoutMs);\\n\\n            var transportUrl = urlUtils.addPath(this._transUrl, '/' + this._server + '/' + this._generateSessionId());\\n            var options = this._transportOptions[Transport.transportName];\\n            debug('transport url', transportUrl);\\n            var transportObj = new Transport(transportUrl, this._transUrl, options);\\n            transportObj.on('message', this._transportMessage.bind(this));\\n            transportObj.once('close', this._transportClose.bind(this));\\n            transportObj.transportName = Transport.transportName;\\n            this._transport = transportObj;\\n\\n            return;\\n          }\\n          this._close(2000, 'All transports failed', false);\\n        };\\n\\n        SockJS.prototype._transportTimeout = function () {\\n          debug('_transportTimeout');\\n          if (this.readyState === SockJS.CONNECTING) {\\n            if (this._transport) {\\n              this._transport.close();\\n            }\\n\\n            this._transportClose(2007, 'Transport timed out');\\n          }\\n        };\\n\\n        SockJS.prototype._transportMessage = function (msg) {\\n          debug('_transportMessage', msg);\\n          var self = this,\\n              type = msg.slice(0, 1),\\n              content = msg.slice(1),\\n              payload;\\n\\n          // first check for messages that don't need a payload\\n          switch (type) {\\n            case 'o':\\n              this._open();\\n              return;\\n            case 'h':\\n              this.dispatchEvent(new Event('heartbeat'));\\n              debug('heartbeat', this.transport);\\n              return;\\n          }\\n\\n          if (content) {\\n            try {\\n              payload = JSON3.parse(content);\\n            } catch (e) {\\n              debug('bad json', content);\\n            }\\n          }\\n\\n          if (typeof payload === 'undefined') {\\n            debug('empty payload', content);\\n            return;\\n          }\\n\\n          switch (type) {\\n            case 'a':\\n              if (Array.isArray(payload)) {\\n                payload.forEach(function (p) {\\n                  debug('message', self.transport, p);\\n                  self.dispatchEvent(new TransportMessageEvent(p));\\n                });\\n              }\\n              break;\\n            case 'm':\\n              debug('message', this.transport, payload);\\n              this.dispatchEvent(new TransportMessageEvent(payload));\\n              break;\\n            case 'c':\\n              if (Array.isArray(payload) && payload.length === 2) {\\n                this._close(payload[0], payload[1], true);\\n              }\\n              break;\\n          }\\n        };\\n\\n        SockJS.prototype._transportClose = function (code, reason) {\\n          debug('_transportClose', this.transport, code, reason);\\n          if (this._transport) {\\n            this._transport.removeAllListeners();\\n            this._transport = null;\\n            this.transport = null;\\n          }\\n\\n          if (!userSetCode(code) && code !== 2000 && this.readyState === SockJS.CONNECTING) {\\n            this._connect();\\n            return;\\n          }\\n\\n          this._close(code, reason);\\n        };\\n\\n        SockJS.prototype._open = function () {\\n          debug('_open', this._transport.transportName, this.readyState);\\n          if (this.readyState === SockJS.CONNECTING) {\\n            if (this._transportTimeoutId) {\\n              clearTimeout(this._transportTimeoutId);\\n              this._transportTimeoutId = null;\\n            }\\n            this.readyState = SockJS.OPEN;\\n            this.transport = this._transport.transportName;\\n            this.dispatchEvent(new Event('open'));\\n            debug('connected', this.transport);\\n          } else {\\n            // The server might have been restarted, and lost track of our\\n            // connection.\\n            this._close(1006, 'Server lost session');\\n          }\\n        };\\n\\n        SockJS.prototype._close = function (code, reason, wasClean) {\\n          debug('_close', this.transport, code, reason, wasClean, this.readyState);\\n          var forceFail = false;\\n\\n          if (this._ir) {\\n            forceFail = true;\\n            this._ir.close();\\n            this._ir = null;\\n          }\\n          if (this._transport) {\\n            this._transport.close();\\n            this._transport = null;\\n            this.transport = null;\\n          }\\n\\n          if (this.readyState === SockJS.CLOSED) {\\n            throw new Error('InvalidStateError: SockJS has already been closed');\\n          }\\n\\n          this.readyState = SockJS.CLOSING;\\n          setTimeout(function () {\\n            this.readyState = SockJS.CLOSED;\\n\\n            if (forceFail) {\\n              this.dispatchEvent(new Event('error'));\\n            }\\n\\n            var e = new CloseEvent('close');\\n            e.wasClean = wasClean || false;\\n            e.code = code || 1000;\\n            e.reason = reason;\\n\\n            this.dispatchEvent(e);\\n            this.onmessage = this.onclose = this.onerror = null;\\n            debug('disconnected');\\n          }.bind(this), 0);\\n        };\\n\\n        // See: http://www.erg.abdn.ac.uk/~gerrit/dccp/notes/ccid2/rto_estimator/\\n        // and RFC 2988.\\n        SockJS.prototype.countRTO = function (rtt) {\\n          // In a local environment, when using IE8/9 and the `jsonp-polling`\\n          // transport the time needed to establish a connection (the time that pass\\n          // from the opening of the transport to the call of `_dispatchOpen`) is\\n          // around 200msec (the lower bound used in the article above) and this\\n          // causes spurious timeouts. For this reason we calculate a value slightly\\n          // larger than that used in the article.\\n          if (rtt > 100) {\\n            return 4 * rtt; // rto > 400msec\\n          }\\n          return 300 + rtt; // 300msec < rto <= 400msec\\n        };\\n\\n        module.exports = function (availableTransports) {\\n          transports = transport(availableTransports);\\n          require('./iframe-bootstrap')(SockJS, availableTransports);\\n          return SockJS;\\n        };\\n      }).call(this, { env: {} }, typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {});\\n    }, { \\\"./event/close\\\": 2, \\\"./event/event\\\": 4, \\\"./event/eventtarget\\\": 5, \\\"./event/trans-message\\\": 6, \\\"./iframe-bootstrap\\\": 8, \\\"./info-receiver\\\": 12, \\\"./location\\\": 13, \\\"./shims\\\": 15, \\\"./utils/browser\\\": 44, \\\"./utils/escape\\\": 45, \\\"./utils/event\\\": 46, \\\"./utils/log\\\": 48, \\\"./utils/object\\\": 49, \\\"./utils/random\\\": 50, \\\"./utils/transport\\\": 51, \\\"./utils/url\\\": 52, \\\"./version\\\": 53, \\\"debug\\\": 54, \\\"inherits\\\": 56, \\\"json3\\\": 57, \\\"url-parse\\\": 61 }], 15: [function (require, module, exports) {\\n      /* eslint-disable */\\n      /* jscs: disable */\\n      'use strict';\\n\\n      // pulled specific shims from https://github.com/es-shims/es5-shim\\n\\n      var ArrayPrototype = Array.prototype;\\n      var ObjectPrototype = Object.prototype;\\n      var FunctionPrototype = Function.prototype;\\n      var StringPrototype = String.prototype;\\n      var array_slice = ArrayPrototype.slice;\\n\\n      var _toString = ObjectPrototype.toString;\\n      var isFunction = function (val) {\\n        return ObjectPrototype.toString.call(val) === '[object Function]';\\n      };\\n      var isArray = function isArray(obj) {\\n        return _toString.call(obj) === '[object Array]';\\n      };\\n      var isString = function isString(obj) {\\n        return _toString.call(obj) === '[object String]';\\n      };\\n\\n      var supportsDescriptors = Object.defineProperty && function () {\\n        try {\\n          Object.defineProperty({}, 'x', {});\\n          return true;\\n        } catch (e) {\\n          /* this is ES3 */\\n          return false;\\n        }\\n      }();\\n\\n      // Define configurable, writable and non-enumerable props\\n      // if they don't exist.\\n      var defineProperty;\\n      if (supportsDescriptors) {\\n        defineProperty = function (object, name, method, forceAssign) {\\n          if (!forceAssign && name in object) {\\n            return;\\n          }\\n          Object.defineProperty(object, name, {\\n            configurable: true,\\n            enumerable: false,\\n            writable: true,\\n            value: method\\n          });\\n        };\\n      } else {\\n        defineProperty = function (object, name, method, forceAssign) {\\n          if (!forceAssign && name in object) {\\n            return;\\n          }\\n          object[name] = method;\\n        };\\n      }\\n      var defineProperties = function (object, map, forceAssign) {\\n        for (var name in map) {\\n          if (ObjectPrototype.hasOwnProperty.call(map, name)) {\\n            defineProperty(object, name, map[name], forceAssign);\\n          }\\n        }\\n      };\\n\\n      var toObject = function (o) {\\n        if (o == null) {\\n          // this matches both null and undefined\\n          throw new TypeError(\\\"can't convert \\\" + o + ' to object');\\n        }\\n        return Object(o);\\n      };\\n\\n      //\\n      // Util\\n      // ======\\n      //\\n\\n      // ES5 9.4\\n      // http://es5.github.com/#x9.4\\n      // http://jsperf.com/to-integer\\n\\n      function toInteger(num) {\\n        var n = +num;\\n        if (n !== n) {\\n          // isNaN\\n          n = 0;\\n        } else if (n !== 0 && n !== 1 / 0 && n !== -(1 / 0)) {\\n          n = (n > 0 || -1) * Math.floor(Math.abs(n));\\n        }\\n        return n;\\n      }\\n\\n      function ToUint32(x) {\\n        return x >>> 0;\\n      }\\n\\n      //\\n      // Function\\n      // ========\\n      //\\n\\n      // ES-5 15.3.4.5\\n      // http://es5.github.com/#x15.3.4.5\\n\\n      function Empty() {}\\n\\n      defineProperties(FunctionPrototype, {\\n        bind: function bind(that) {\\n          // .length is 1\\n          // 1. Let Target be the this value.\\n          var target = this;\\n          // 2. If IsCallable(Target) is false, throw a TypeError exception.\\n          if (!isFunction(target)) {\\n            throw new TypeError('Function.prototype.bind called on incompatible ' + target);\\n          }\\n          // 3. Let A be a new (possibly empty) internal list of all of the\\n          //   argument values provided after thisArg (arg1, arg2 etc), in order.\\n          // XXX slicedArgs will stand in for \\\"A\\\" if used\\n          var args = array_slice.call(arguments, 1); // for normal call\\n          // 4. Let F be a new native ECMAScript object.\\n          // 11. Set the [[Prototype]] internal property of F to the standard\\n          //   built-in Function prototype object as specified in 15.3.3.1.\\n          // 12. Set the [[Call]] internal property of F as described in\\n          //   15.3.4.5.1.\\n          // 13. Set the [[Construct]] internal property of F as described in\\n          //   15.3.4.5.2.\\n          // 14. Set the [[HasInstance]] internal property of F as described in\\n          //   15.3.4.5.3.\\n          var binder = function () {\\n\\n            if (this instanceof bound) {\\n              // 15.3.4.5.2 [[Construct]]\\n              // When the [[Construct]] internal method of a function object,\\n              // F that was created using the bind function is called with a\\n              // list of arguments ExtraArgs, the following steps are taken:\\n              // 1. Let target be the value of F's [[TargetFunction]]\\n              //   internal property.\\n              // 2. If target has no [[Construct]] internal method, a\\n              //   TypeError exception is thrown.\\n              // 3. Let boundArgs be the value of F's [[BoundArgs]] internal\\n              //   property.\\n              // 4. Let args be a new list containing the same values as the\\n              //   list boundArgs in the same order followed by the same\\n              //   values as the list ExtraArgs in the same order.\\n              // 5. Return the result of calling the [[Construct]] internal\\n              //   method of target providing args as the arguments.\\n\\n              var result = target.apply(this, args.concat(array_slice.call(arguments)));\\n              if (Object(result) === result) {\\n                return result;\\n              }\\n              return this;\\n            } else {\\n              // 15.3.4.5.1 [[Call]]\\n              // When the [[Call]] internal method of a function object, F,\\n              // which was created using the bind function is called with a\\n              // this value and a list of arguments ExtraArgs, the following\\n              // steps are taken:\\n              // 1. Let boundArgs be the value of F's [[BoundArgs]] internal\\n              //   property.\\n              // 2. Let boundThis be the value of F's [[BoundThis]] internal\\n              //   property.\\n              // 3. Let target be the value of F's [[TargetFunction]] internal\\n              //   property.\\n              // 4. Let args be a new list containing the same values as the\\n              //   list boundArgs in the same order followed by the same\\n              //   values as the list ExtraArgs in the same order.\\n              // 5. Return the result of calling the [[Call]] internal method\\n              //   of target providing boundThis as the this value and\\n              //   providing args as the arguments.\\n\\n              // equiv: target.call(this, ...boundArgs, ...args)\\n              return target.apply(that, args.concat(array_slice.call(arguments)));\\n            }\\n          };\\n\\n          // 15. If the [[Class]] internal property of Target is \\\"Function\\\", then\\n          //     a. Let L be the length property of Target minus the length of A.\\n          //     b. Set the length own property of F to either 0 or L, whichever is\\n          //       larger.\\n          // 16. Else set the length own property of F to 0.\\n\\n          var boundLength = Math.max(0, target.length - args.length);\\n\\n          // 17. Set the attributes of the length own property of F to the values\\n          //   specified in 15.3.5.1.\\n          var boundArgs = [];\\n          for (var i = 0; i < boundLength; i++) {\\n            boundArgs.push('$' + i);\\n          }\\n\\n          // XXX Build a dynamic function with desired amount of arguments is the only\\n          // way to set the length property of a function.\\n          // In environments where Content Security Policies enabled (Chrome extensions,\\n          // for ex.) all use of eval or Function costructor throws an exception.\\n          // However in all of these environments Function.prototype.bind exists\\n          // and so this code will never be executed.\\n          var bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this, arguments); }')(binder);\\n\\n          if (target.prototype) {\\n            Empty.prototype = target.prototype;\\n            bound.prototype = new Empty();\\n            // Clean up dangling references.\\n            Empty.prototype = null;\\n          }\\n\\n          // TODO\\n          // 18. Set the [[Extensible]] internal property of F to true.\\n\\n          // TODO\\n          // 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).\\n          // 20. Call the [[DefineOwnProperty]] internal method of F with\\n          //   arguments \\\"caller\\\", PropertyDescriptor {[[Get]]: thrower, [[Set]]:\\n          //   thrower, [[Enumerable]]: false, [[Configurable]]: false}, and\\n          //   false.\\n          // 21. Call the [[DefineOwnProperty]] internal method of F with\\n          //   arguments \\\"arguments\\\", PropertyDescriptor {[[Get]]: thrower,\\n          //   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false},\\n          //   and false.\\n\\n          // TODO\\n          // NOTE Function objects created using Function.prototype.bind do not\\n          // have a prototype property or the [[Code]], [[FormalParameters]], and\\n          // [[Scope]] internal properties.\\n          // XXX can't delete prototype in pure-js.\\n\\n          // 22. Return F.\\n          return bound;\\n        }\\n      });\\n\\n      //\\n      // Array\\n      // =====\\n      //\\n\\n      // ES5 15.4.3.2\\n      // http://es5.github.com/#x15.4.3.2\\n      // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray\\n      defineProperties(Array, { isArray: isArray });\\n\\n      var boxedString = Object('a');\\n      var splitString = boxedString[0] !== 'a' || !(0 in boxedString);\\n\\n      var properlyBoxesContext = function properlyBoxed(method) {\\n        // Check node 0.6.21 bug where third parameter is not boxed\\n        var properlyBoxesNonStrict = true;\\n        var properlyBoxesStrict = true;\\n        if (method) {\\n          method.call('foo', function (_, __, context) {\\n            if (typeof context !== 'object') {\\n              properlyBoxesNonStrict = false;\\n            }\\n          });\\n\\n          method.call([1], function () {\\n            'use strict';\\n\\n            properlyBoxesStrict = typeof this === 'string';\\n          }, 'x');\\n        }\\n        return !!method && properlyBoxesNonStrict && properlyBoxesStrict;\\n      };\\n\\n      defineProperties(ArrayPrototype, {\\n        forEach: function forEach(fun /*, thisp*/) {\\n          var object = toObject(this),\\n              self = splitString && isString(this) ? this.split('') : object,\\n              thisp = arguments[1],\\n              i = -1,\\n              length = self.length >>> 0;\\n\\n          // If no callback function or if callback is not a callable function\\n          if (!isFunction(fun)) {\\n            throw new TypeError(); // TODO message\\n          }\\n\\n          while (++i < length) {\\n            if (i in self) {\\n              // Invoke the callback function with call, passing arguments:\\n              // context, property value, property key, thisArg object\\n              // context\\n              fun.call(thisp, self[i], i, object);\\n            }\\n          }\\n        }\\n      }, !properlyBoxesContext(ArrayPrototype.forEach));\\n\\n      // ES5 15.4.4.14\\n      // http://es5.github.com/#x15.4.4.14\\n      // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf\\n      var hasFirefox2IndexOfBug = Array.prototype.indexOf && [0, 1].indexOf(1, 2) !== -1;\\n      defineProperties(ArrayPrototype, {\\n        indexOf: function indexOf(sought /*, fromIndex */) {\\n          var self = splitString && isString(this) ? this.split('') : toObject(this),\\n              length = self.length >>> 0;\\n\\n          if (!length) {\\n            return -1;\\n          }\\n\\n          var i = 0;\\n          if (arguments.length > 1) {\\n            i = toInteger(arguments[1]);\\n          }\\n\\n          // handle negative indices\\n          i = i >= 0 ? i : Math.max(0, length + i);\\n          for (; i < length; i++) {\\n            if (i in self && self[i] === sought) {\\n              return i;\\n            }\\n          }\\n          return -1;\\n        }\\n      }, hasFirefox2IndexOfBug);\\n\\n      //\\n      // String\\n      // ======\\n      //\\n\\n      // ES5 15.5.4.14\\n      // http://es5.github.com/#x15.5.4.14\\n\\n      // [bugfix, IE lt 9, firefox 4, Konqueror, Opera, obscure browsers]\\n      // Many browsers do not split properly with regular expressions or they\\n      // do not perform the split correctly under obscure conditions.\\n      // See http://blog.stevenlevithan.com/archives/cross-browser-split\\n      // I've tested in many browsers and this seems to cover the deviant ones:\\n      //    'ab'.split(/(?:ab)*/) should be [\\\"\\\", \\\"\\\"], not [\\\"\\\"]\\n      //    '.'.split(/(.?)(.?)/) should be [\\\"\\\", \\\".\\\", \\\"\\\", \\\"\\\"], not [\\\"\\\", \\\"\\\"]\\n      //    'tesst'.split(/(s)*/) should be [\\\"t\\\", undefined, \\\"e\\\", \\\"s\\\", \\\"t\\\"], not\\n      //       [undefined, \\\"t\\\", undefined, \\\"e\\\", ...]\\n      //    ''.split(/.?/) should be [], not [\\\"\\\"]\\n      //    '.'.split(/()()/) should be [\\\".\\\"], not [\\\"\\\", \\\"\\\", \\\".\\\"]\\n\\n      var string_split = StringPrototype.split;\\n      if ('ab'.split(/(?:ab)*/).length !== 2 || '.'.split(/(.?)(.?)/).length !== 4 || 'tesst'.split(/(s)*/)[1] === 't' || 'test'.split(/(?:)/, -1).length !== 4 || ''.split(/.?/).length || '.'.split(/()()/).length > 1) {\\n        (function () {\\n          var compliantExecNpcg = /()??/.exec('')[1] === void 0; // NPCG: nonparticipating capturing group\\n\\n          StringPrototype.split = function (separator, limit) {\\n            var string = this;\\n            if (separator === void 0 && limit === 0) {\\n              return [];\\n            }\\n\\n            // If `separator` is not a regex, use native split\\n            if (_toString.call(separator) !== '[object RegExp]') {\\n              return string_split.call(this, separator, limit);\\n            }\\n\\n            var output = [],\\n                flags = (separator.ignoreCase ? 'i' : '') + (separator.multiline ? 'm' : '') + (separator.extended ? 'x' : '') + ( // Proposed for ES6\\n            separator.sticky ? 'y' : ''),\\n                // Firefox 3+\\n            lastLastIndex = 0,\\n\\n            // Make `global` and avoid `lastIndex` issues by working with a copy\\n            separator2,\\n                match,\\n                lastIndex,\\n                lastLength;\\n            separator = new RegExp(separator.source, flags + 'g');\\n            string += ''; // Type-convert\\n            if (!compliantExecNpcg) {\\n              // Doesn't need flags gy, but they don't hurt\\n              separator2 = new RegExp('^' + separator.source + '$(?!\\\\\\\\s)', flags);\\n            }\\n            /* Values for `limit`, per the spec:\\r\\n             * If undefined: 4294967295 // Math.pow(2, 32) - 1\\r\\n             * If 0, Infinity, or NaN: 0\\r\\n             * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;\\r\\n             * If negative number: 4294967296 - Math.floor(Math.abs(limit))\\r\\n             * If other: Type-convert, then use the above rules\\r\\n             */\\n            limit = limit === void 0 ? -1 >>> 0 : // Math.pow(2, 32) - 1\\n            ToUint32(limit);\\n            while (match = separator.exec(string)) {\\n              // `separator.lastIndex` is not reliable cross-browser\\n              lastIndex = match.index + match[0].length;\\n              if (lastIndex > lastLastIndex) {\\n                output.push(string.slice(lastLastIndex, match.index));\\n                // Fix browsers whose `exec` methods don't consistently return `undefined` for\\n                // nonparticipating capturing groups\\n                if (!compliantExecNpcg && match.length > 1) {\\n                  match[0].replace(separator2, function () {\\n                    for (var i = 1; i < arguments.length - 2; i++) {\\n                      if (arguments[i] === void 0) {\\n                        match[i] = void 0;\\n                      }\\n                    }\\n                  });\\n                }\\n                if (match.length > 1 && match.index < string.length) {\\n                  ArrayPrototype.push.apply(output, match.slice(1));\\n                }\\n                lastLength = match[0].length;\\n                lastLastIndex = lastIndex;\\n                if (output.length >= limit) {\\n                  break;\\n                }\\n              }\\n              if (separator.lastIndex === match.index) {\\n                separator.lastIndex++; // Avoid an infinite loop\\n              }\\n            }\\n            if (lastLastIndex === string.length) {\\n              if (lastLength || !separator.test('')) {\\n                output.push('');\\n              }\\n            } else {\\n              output.push(string.slice(lastLastIndex));\\n            }\\n            return output.length > limit ? output.slice(0, limit) : output;\\n          };\\n        })();\\n\\n        // [bugfix, chrome]\\n        // If separator is undefined, then the result array contains just one String,\\n        // which is the this value (converted to a String). If limit is not undefined,\\n        // then the output array is truncated so that it contains no more than limit\\n        // elements.\\n        // \\\"0\\\".split(undefined, 0) -> []\\n      } else if ('0'.split(void 0, 0).length) {\\n        StringPrototype.split = function split(separator, limit) {\\n          if (separator === void 0 && limit === 0) {\\n            return [];\\n          }\\n          return string_split.call(this, separator, limit);\\n        };\\n      }\\n\\n      // ECMA-262, 3rd B.2.3\\n      // Not an ECMAScript standard, although ECMAScript 3rd Edition has a\\n      // non-normative section suggesting uniform semantics and it should be\\n      // normalized across all browsers\\n      // [bugfix, IE lt 9] IE < 9 substr() with negative value not working in IE\\n      var string_substr = StringPrototype.substr;\\n      var hasNegativeSubstrBug = ''.substr && '0b'.substr(-1) !== 'b';\\n      defineProperties(StringPrototype, {\\n        substr: function substr(start, length) {\\n          return string_substr.call(this, start < 0 ? (start = this.length + start) < 0 ? 0 : start : start, length);\\n        }\\n      }, hasNegativeSubstrBug);\\n    }, {}], 16: [function (require, module, exports) {\\n      'use strict';\\n\\n      module.exports = [\\n      // streaming transports\\n      require('./transport/websocket'), require('./transport/xhr-streaming'), require('./transport/xdr-streaming'), require('./transport/eventsource'), require('./transport/lib/iframe-wrap')(require('./transport/eventsource'))\\n\\n      // polling transports\\n      , require('./transport/htmlfile'), require('./transport/lib/iframe-wrap')(require('./transport/htmlfile')), require('./transport/xhr-polling'), require('./transport/xdr-polling'), require('./transport/lib/iframe-wrap')(require('./transport/xhr-polling')), require('./transport/jsonp-polling')];\\n    }, { \\\"./transport/eventsource\\\": 20, \\\"./transport/htmlfile\\\": 21, \\\"./transport/jsonp-polling\\\": 23, \\\"./transport/lib/iframe-wrap\\\": 26, \\\"./transport/websocket\\\": 38, \\\"./transport/xdr-polling\\\": 39, \\\"./transport/xdr-streaming\\\": 40, \\\"./transport/xhr-polling\\\": 41, \\\"./transport/xhr-streaming\\\": 42 }], 17: [function (require, module, exports) {\\n      (function (process, global) {\\n        'use strict';\\n\\n        var EventEmitter = require('events').EventEmitter,\\n            inherits = require('inherits'),\\n            utils = require('../../utils/event'),\\n            urlUtils = require('../../utils/url'),\\n            XHR = global.XMLHttpRequest;\\n\\n        var debug = function () {};\\n        if (process.env.NODE_ENV !== 'production') {\\n          debug = require('debug')('sockjs-client:browser:xhr');\\n        }\\n\\n        function AbstractXHRObject(method, url, payload, opts) {\\n          debug(method, url);\\n          var self = this;\\n          EventEmitter.call(this);\\n\\n          setTimeout(function () {\\n            self._start(method, url, payload, opts);\\n          }, 0);\\n        }\\n\\n        inherits(AbstractXHRObject, EventEmitter);\\n\\n        AbstractXHRObject.prototype._start = function (method, url, payload, opts) {\\n          var self = this;\\n\\n          try {\\n            this.xhr = new XHR();\\n          } catch (x) {\\n            // intentionally empty\\n          }\\n\\n          if (!this.xhr) {\\n            debug('no xhr');\\n            this.emit('finish', 0, 'no xhr support');\\n            this._cleanup();\\n            return;\\n          }\\n\\n          // several browsers cache POSTs\\n          url = urlUtils.addQuery(url, 't=' + +new Date());\\n\\n          // Explorer tends to keep connection open, even after the\\n          // tab gets closed: http://bugs.jquery.com/ticket/5280\\n          this.unloadRef = utils.unloadAdd(function () {\\n            debug('unload cleanup');\\n            self._cleanup(true);\\n          });\\n          try {\\n            this.xhr.open(method, url, true);\\n            if (this.timeout && 'timeout' in this.xhr) {\\n              this.xhr.timeout = this.timeout;\\n              this.xhr.ontimeout = function () {\\n                debug('xhr timeout');\\n                self.emit('finish', 0, '');\\n                self._cleanup(false);\\n              };\\n            }\\n          } catch (e) {\\n            debug('exception', e);\\n            // IE raises an exception on wrong port.\\n            this.emit('finish', 0, '');\\n            this._cleanup(false);\\n            return;\\n          }\\n\\n          if ((!opts || !opts.noCredentials) && AbstractXHRObject.supportsCORS) {\\n            debug('withCredentials');\\n            // Mozilla docs says https://developer.mozilla.org/en/XMLHttpRequest :\\n            // \\\"This never affects same-site requests.\\\"\\n\\n            this.xhr.withCredentials = true;\\n          }\\n          if (opts && opts.headers) {\\n            for (var key in opts.headers) {\\n              this.xhr.setRequestHeader(key, opts.headers[key]);\\n            }\\n          }\\n\\n          this.xhr.onreadystatechange = function () {\\n            if (self.xhr) {\\n              var x = self.xhr;\\n              var text, status;\\n              debug('readyState', x.readyState);\\n              switch (x.readyState) {\\n                case 3:\\n                  // IE doesn't like peeking into responseText or status\\n                  // on Microsoft.XMLHTTP and readystate=3\\n                  try {\\n                    status = x.status;\\n                    text = x.responseText;\\n                  } catch (e) {\\n                    // intentionally empty\\n                  }\\n                  debug('status', status);\\n                  // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450\\n                  if (status === 1223) {\\n                    status = 204;\\n                  }\\n\\n                  // IE does return readystate == 3 for 404 answers.\\n                  if (status === 200 && text && text.length > 0) {\\n                    debug('chunk');\\n                    self.emit('chunk', status, text);\\n                  }\\n                  break;\\n                case 4:\\n                  status = x.status;\\n                  debug('status', status);\\n                  // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450\\n                  if (status === 1223) {\\n                    status = 204;\\n                  }\\n                  // IE returns this for a bad port\\n                  // http://msdn.microsoft.com/en-us/library/windows/desktop/aa383770(v=vs.85).aspx\\n                  if (status === 12005 || status === 12029) {\\n                    status = 0;\\n                  }\\n\\n                  debug('finish', status, x.responseText);\\n                  self.emit('finish', status, x.responseText);\\n                  self._cleanup(false);\\n                  break;\\n              }\\n            }\\n          };\\n\\n          try {\\n            self.xhr.send(payload);\\n          } catch (e) {\\n            self.emit('finish', 0, '');\\n            self._cleanup(false);\\n          }\\n        };\\n\\n        AbstractXHRObject.prototype._cleanup = function (abort) {\\n          debug('cleanup');\\n          if (!this.xhr) {\\n            return;\\n          }\\n          this.removeAllListeners();\\n          utils.unloadDel(this.unloadRef);\\n\\n          // IE needs this field to be a function\\n          this.xhr.onreadystatechange = function () {};\\n          if (this.xhr.ontimeout) {\\n            this.xhr.ontimeout = null;\\n          }\\n\\n          if (abort) {\\n            try {\\n              this.xhr.abort();\\n            } catch (x) {\\n              // intentionally empty\\n            }\\n          }\\n          this.unloadRef = this.xhr = null;\\n        };\\n\\n        AbstractXHRObject.prototype.close = function () {\\n          debug('close');\\n          this._cleanup(true);\\n        };\\n\\n        AbstractXHRObject.enabled = !!XHR;\\n        // override XMLHttpRequest for IE6/7\\n        // obfuscate to avoid firewalls\\n        var axo = ['Active'].concat('Object').join('X');\\n        if (!AbstractXHRObject.enabled && axo in global) {\\n          debug('overriding xmlhttprequest');\\n          XHR = function () {\\n            try {\\n              return new global[axo]('Microsoft.XMLHTTP');\\n            } catch (e) {\\n              return null;\\n            }\\n          };\\n          AbstractXHRObject.enabled = !!new XHR();\\n        }\\n\\n        var cors = false;\\n        try {\\n          cors = 'withCredentials' in new XHR();\\n        } catch (ignored) {\\n          // intentionally empty\\n        }\\n\\n        AbstractXHRObject.supportsCORS = cors;\\n\\n        module.exports = AbstractXHRObject;\\n      }).call(this, { env: {} }, typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {});\\n    }, { \\\"../../utils/event\\\": 46, \\\"../../utils/url\\\": 52, \\\"debug\\\": 54, \\\"events\\\": 3, \\\"inherits\\\": 56 }], 18: [function (require, module, exports) {\\n      (function (global) {\\n        module.exports = global.EventSource;\\n      }).call(this, typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {});\\n    }, {}], 19: [function (require, module, exports) {\\n      (function (global) {\\n        'use strict';\\n\\n        var Driver = global.WebSocket || global.MozWebSocket;\\n        if (Driver) {\\n          module.exports = function WebSocketBrowserDriver(url) {\\n            return new Driver(url);\\n          };\\n        } else {\\n          module.exports = undefined;\\n        }\\n      }).call(this, typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {});\\n    }, {}], 20: [function (require, module, exports) {\\n      'use strict';\\n\\n      var inherits = require('inherits'),\\n          AjaxBasedTransport = require('./lib/ajax-based'),\\n          EventSourceReceiver = require('./receiver/eventsource'),\\n          XHRCorsObject = require('./sender/xhr-cors'),\\n          EventSourceDriver = require('eventsource');\\n\\n      function EventSourceTransport(transUrl) {\\n        if (!EventSourceTransport.enabled()) {\\n          throw new Error('Transport created when disabled');\\n        }\\n\\n        AjaxBasedTransport.call(this, transUrl, '/eventsource', EventSourceReceiver, XHRCorsObject);\\n      }\\n\\n      inherits(EventSourceTransport, AjaxBasedTransport);\\n\\n      EventSourceTransport.enabled = function () {\\n        return !!EventSourceDriver;\\n      };\\n\\n      EventSourceTransport.transportName = 'eventsource';\\n      EventSourceTransport.roundTrips = 2;\\n\\n      module.exports = EventSourceTransport;\\n    }, { \\\"./lib/ajax-based\\\": 24, \\\"./receiver/eventsource\\\": 29, \\\"./sender/xhr-cors\\\": 35, \\\"eventsource\\\": 18, \\\"inherits\\\": 56 }], 21: [function (require, module, exports) {\\n      'use strict';\\n\\n      var inherits = require('inherits'),\\n          HtmlfileReceiver = require('./receiver/htmlfile'),\\n          XHRLocalObject = require('./sender/xhr-local'),\\n          AjaxBasedTransport = require('./lib/ajax-based');\\n\\n      function HtmlFileTransport(transUrl) {\\n        if (!HtmlfileReceiver.enabled) {\\n          throw new Error('Transport created when disabled');\\n        }\\n        AjaxBasedTransport.call(this, transUrl, '/htmlfile', HtmlfileReceiver, XHRLocalObject);\\n      }\\n\\n      inherits(HtmlFileTransport, AjaxBasedTransport);\\n\\n      HtmlFileTransport.enabled = function (info) {\\n        return HtmlfileReceiver.enabled && info.sameOrigin;\\n      };\\n\\n      HtmlFileTransport.transportName = 'htmlfile';\\n      HtmlFileTransport.roundTrips = 2;\\n\\n      module.exports = HtmlFileTransport;\\n    }, { \\\"./lib/ajax-based\\\": 24, \\\"./receiver/htmlfile\\\": 30, \\\"./sender/xhr-local\\\": 37, \\\"inherits\\\": 56 }], 22: [function (require, module, exports) {\\n      (function (process) {\\n        'use strict';\\n\\n        // Few cool transports do work only for same-origin. In order to make\\n        // them work cross-domain we shall use iframe, served from the\\n        // remote domain. New browsers have capabilities to communicate with\\n        // cross domain iframe using postMessage(). In IE it was implemented\\n        // from IE 8+, but of course, IE got some details wrong:\\n        //    http://msdn.microsoft.com/en-us/library/cc197015(v=VS.85).aspx\\n        //    http://stevesouders.com/misc/test-postmessage.php\\n\\n        var inherits = require('inherits'),\\n            JSON3 = require('json3'),\\n            EventEmitter = require('events').EventEmitter,\\n            version = require('../version'),\\n            urlUtils = require('../utils/url'),\\n            iframeUtils = require('../utils/iframe'),\\n            eventUtils = require('../utils/event'),\\n            random = require('../utils/random');\\n\\n        var debug = function () {};\\n        if (process.env.NODE_ENV !== 'production') {\\n          debug = require('debug')('sockjs-client:transport:iframe');\\n        }\\n\\n        function IframeTransport(transport, transUrl, baseUrl) {\\n          if (!IframeTransport.enabled()) {\\n            throw new Error('Transport created when disabled');\\n          }\\n          EventEmitter.call(this);\\n\\n          var self = this;\\n          this.origin = urlUtils.getOrigin(baseUrl);\\n          this.baseUrl = baseUrl;\\n          this.transUrl = transUrl;\\n          this.transport = transport;\\n          this.windowId = random.string(8);\\n\\n          var iframeUrl = urlUtils.addPath(baseUrl, '/iframe.html') + '#' + this.windowId;\\n          debug(transport, transUrl, iframeUrl);\\n\\n          this.iframeObj = iframeUtils.createIframe(iframeUrl, function (r) {\\n            debug('err callback');\\n            self.emit('close', 1006, 'Unable to load an iframe (' + r + ')');\\n            self.close();\\n          });\\n\\n          this.onmessageCallback = this._message.bind(this);\\n          eventUtils.attachEvent('message', this.onmessageCallback);\\n        }\\n\\n        inherits(IframeTransport, EventEmitter);\\n\\n        IframeTransport.prototype.close = function () {\\n          debug('close');\\n          this.removeAllListeners();\\n          if (this.iframeObj) {\\n            eventUtils.detachEvent('message', this.onmessageCallback);\\n            try {\\n              // When the iframe is not loaded, IE raises an exception\\n              // on 'contentWindow'.\\n              this.postMessage('c');\\n            } catch (x) {\\n              // intentionally empty\\n            }\\n            this.iframeObj.cleanup();\\n            this.iframeObj = null;\\n            this.onmessageCallback = this.iframeObj = null;\\n          }\\n        };\\n\\n        IframeTransport.prototype._message = function (e) {\\n          debug('message', e.data);\\n          if (!urlUtils.isOriginEqual(e.origin, this.origin)) {\\n            debug('not same origin', e.origin, this.origin);\\n            return;\\n          }\\n\\n          var iframeMessage;\\n          try {\\n            iframeMessage = JSON3.parse(e.data);\\n          } catch (ignored) {\\n            debug('bad json', e.data);\\n            return;\\n          }\\n\\n          if (iframeMessage.windowId !== this.windowId) {\\n            debug('mismatched window id', iframeMessage.windowId, this.windowId);\\n            return;\\n          }\\n\\n          switch (iframeMessage.type) {\\n            case 's':\\n              this.iframeObj.loaded();\\n              // window global dependency\\n              this.postMessage('s', JSON3.stringify([version, this.transport, this.transUrl, this.baseUrl]));\\n              break;\\n            case 't':\\n              this.emit('message', iframeMessage.data);\\n              break;\\n            case 'c':\\n              var cdata;\\n              try {\\n                cdata = JSON3.parse(iframeMessage.data);\\n              } catch (ignored) {\\n                debug('bad json', iframeMessage.data);\\n                return;\\n              }\\n              this.emit('close', cdata[0], cdata[1]);\\n              this.close();\\n              break;\\n          }\\n        };\\n\\n        IframeTransport.prototype.postMessage = function (type, data) {\\n          debug('postMessage', type, data);\\n          this.iframeObj.post(JSON3.stringify({\\n            windowId: this.windowId,\\n            type: type,\\n            data: data || ''\\n          }), this.origin);\\n        };\\n\\n        IframeTransport.prototype.send = function (message) {\\n          debug('send', message);\\n          this.postMessage('m', message);\\n        };\\n\\n        IframeTransport.enabled = function () {\\n          return iframeUtils.iframeEnabled;\\n        };\\n\\n        IframeTransport.transportName = 'iframe';\\n        IframeTransport.roundTrips = 2;\\n\\n        module.exports = IframeTransport;\\n      }).call(this, { env: {} });\\n    }, { \\\"../utils/event\\\": 46, \\\"../utils/iframe\\\": 47, \\\"../utils/random\\\": 50, \\\"../utils/url\\\": 52, \\\"../version\\\": 53, \\\"debug\\\": 54, \\\"events\\\": 3, \\\"inherits\\\": 56, \\\"json3\\\": 57 }], 23: [function (require, module, exports) {\\n      (function (global) {\\n        'use strict';\\n\\n        // The simplest and most robust transport, using the well-know cross\\n        // domain hack - JSONP. This transport is quite inefficient - one\\n        // message could use up to one http request. But at least it works almost\\n        // everywhere.\\n        // Known limitations:\\n        //   o you will get a spinning cursor\\n        //   o for Konqueror a dumb timer is needed to detect errors\\n\\n        var inherits = require('inherits'),\\n            SenderReceiver = require('./lib/sender-receiver'),\\n            JsonpReceiver = require('./receiver/jsonp'),\\n            jsonpSender = require('./sender/jsonp');\\n\\n        function JsonPTransport(transUrl) {\\n          if (!JsonPTransport.enabled()) {\\n            throw new Error('Transport created when disabled');\\n          }\\n          SenderReceiver.call(this, transUrl, '/jsonp', jsonpSender, JsonpReceiver);\\n        }\\n\\n        inherits(JsonPTransport, SenderReceiver);\\n\\n        JsonPTransport.enabled = function () {\\n          return !!global.document;\\n        };\\n\\n        JsonPTransport.transportName = 'jsonp-polling';\\n        JsonPTransport.roundTrips = 1;\\n        JsonPTransport.needBody = true;\\n\\n        module.exports = JsonPTransport;\\n      }).call(this, typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {});\\n    }, { \\\"./lib/sender-receiver\\\": 28, \\\"./receiver/jsonp\\\": 31, \\\"./sender/jsonp\\\": 33, \\\"inherits\\\": 56 }], 24: [function (require, module, exports) {\\n      (function (process) {\\n        'use strict';\\n\\n        var inherits = require('inherits'),\\n            urlUtils = require('../../utils/url'),\\n            SenderReceiver = require('./sender-receiver');\\n\\n        var debug = function () {};\\n        if (process.env.NODE_ENV !== 'production') {\\n          debug = require('debug')('sockjs-client:ajax-based');\\n        }\\n\\n        function createAjaxSender(AjaxObject) {\\n          return function (url, payload, callback) {\\n            debug('create ajax sender', url, payload);\\n            var opt = {};\\n            if (typeof payload === 'string') {\\n              opt.headers = { 'Content-type': 'text/plain' };\\n            }\\n            var ajaxUrl = urlUtils.addPath(url, '/xhr_send');\\n            var xo = new AjaxObject('POST', ajaxUrl, payload, opt);\\n            xo.once('finish', function (status) {\\n              debug('finish', status);\\n              xo = null;\\n\\n              if (status !== 200 && status !== 204) {\\n                return callback(new Error('http status ' + status));\\n              }\\n              callback();\\n            });\\n            return function () {\\n              debug('abort');\\n              xo.close();\\n              xo = null;\\n\\n              var err = new Error('Aborted');\\n              err.code = 1000;\\n              callback(err);\\n            };\\n          };\\n        }\\n\\n        function AjaxBasedTransport(transUrl, urlSuffix, Receiver, AjaxObject) {\\n          SenderReceiver.call(this, transUrl, urlSuffix, createAjaxSender(AjaxObject), Receiver, AjaxObject);\\n        }\\n\\n        inherits(AjaxBasedTransport, SenderReceiver);\\n\\n        module.exports = AjaxBasedTransport;\\n      }).call(this, { env: {} });\\n    }, { \\\"../../utils/url\\\": 52, \\\"./sender-receiver\\\": 28, \\\"debug\\\": 54, \\\"inherits\\\": 56 }], 25: [function (require, module, exports) {\\n      (function (process) {\\n        'use strict';\\n\\n        var inherits = require('inherits'),\\n            EventEmitter = require('events').EventEmitter;\\n\\n        var debug = function () {};\\n        if (process.env.NODE_ENV !== 'production') {\\n          debug = require('debug')('sockjs-client:buffered-sender');\\n        }\\n\\n        function BufferedSender(url, sender) {\\n          debug(url);\\n          EventEmitter.call(this);\\n          this.sendBuffer = [];\\n          this.sender = sender;\\n          this.url = url;\\n        }\\n\\n        inherits(BufferedSender, EventEmitter);\\n\\n        BufferedSender.prototype.send = function (message) {\\n          debug('send', message);\\n          this.sendBuffer.push(message);\\n          if (!this.sendStop) {\\n            this.sendSchedule();\\n          }\\n        };\\n\\n        // For polling transports in a situation when in the message callback,\\n        // new message is being send. If the sending connection was started\\n        // before receiving one, it is possible to saturate the network and\\n        // timeout due to the lack of receiving socket. To avoid that we delay\\n        // sending messages by some small time, in order to let receiving\\n        // connection be started beforehand. This is only a halfmeasure and\\n        // does not fix the big problem, but it does make the tests go more\\n        // stable on slow networks.\\n        BufferedSender.prototype.sendScheduleWait = function () {\\n          debug('sendScheduleWait');\\n          var self = this;\\n          var tref;\\n          this.sendStop = function () {\\n            debug('sendStop');\\n            self.sendStop = null;\\n            clearTimeout(tref);\\n          };\\n          tref = setTimeout(function () {\\n            debug('timeout');\\n            self.sendStop = null;\\n            self.sendSchedule();\\n          }, 25);\\n        };\\n\\n        BufferedSender.prototype.sendSchedule = function () {\\n          debug('sendSchedule', this.sendBuffer.length);\\n          var self = this;\\n          if (this.sendBuffer.length > 0) {\\n            var payload = '[' + this.sendBuffer.join(',') + ']';\\n            this.sendStop = this.sender(this.url, payload, function (err) {\\n              self.sendStop = null;\\n              if (err) {\\n                debug('error', err);\\n                self.emit('close', err.code || 1006, 'Sending error: ' + err);\\n                self.close();\\n              } else {\\n                self.sendScheduleWait();\\n              }\\n            });\\n            this.sendBuffer = [];\\n          }\\n        };\\n\\n        BufferedSender.prototype._cleanup = function () {\\n          debug('_cleanup');\\n          this.removeAllListeners();\\n        };\\n\\n        BufferedSender.prototype.close = function () {\\n          debug('close');\\n          this._cleanup();\\n          if (this.sendStop) {\\n            this.sendStop();\\n            this.sendStop = null;\\n          }\\n        };\\n\\n        module.exports = BufferedSender;\\n      }).call(this, { env: {} });\\n    }, { \\\"debug\\\": 54, \\\"events\\\": 3, \\\"inherits\\\": 56 }], 26: [function (require, module, exports) {\\n      (function (global) {\\n        'use strict';\\n\\n        var inherits = require('inherits'),\\n            IframeTransport = require('../iframe'),\\n            objectUtils = require('../../utils/object');\\n\\n        module.exports = function (transport) {\\n\\n          function IframeWrapTransport(transUrl, baseUrl) {\\n            IframeTransport.call(this, transport.transportName, transUrl, baseUrl);\\n          }\\n\\n          inherits(IframeWrapTransport, IframeTransport);\\n\\n          IframeWrapTransport.enabled = function (url, info) {\\n            if (!global.document) {\\n              return false;\\n            }\\n\\n            var iframeInfo = objectUtils.extend({}, info);\\n            iframeInfo.sameOrigin = true;\\n            return transport.enabled(iframeInfo) && IframeTransport.enabled();\\n          };\\n\\n          IframeWrapTransport.transportName = 'iframe-' + transport.transportName;\\n          IframeWrapTransport.needBody = true;\\n          IframeWrapTransport.roundTrips = IframeTransport.roundTrips + transport.roundTrips - 1; // html, javascript (2) + transport - no CORS (1)\\n\\n          IframeWrapTransport.facadeTransport = transport;\\n\\n          return IframeWrapTransport;\\n        };\\n      }).call(this, typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {});\\n    }, { \\\"../../utils/object\\\": 49, \\\"../iframe\\\": 22, \\\"inherits\\\": 56 }], 27: [function (require, module, exports) {\\n      (function (process) {\\n        'use strict';\\n\\n        var inherits = require('inherits'),\\n            EventEmitter = require('events').EventEmitter;\\n\\n        var debug = function () {};\\n        if (process.env.NODE_ENV !== 'production') {\\n          debug = require('debug')('sockjs-client:polling');\\n        }\\n\\n        function Polling(Receiver, receiveUrl, AjaxObject) {\\n          debug(receiveUrl);\\n          EventEmitter.call(this);\\n          this.Receiver = Receiver;\\n          this.receiveUrl = receiveUrl;\\n          this.AjaxObject = AjaxObject;\\n          this._scheduleReceiver();\\n        }\\n\\n        inherits(Polling, EventEmitter);\\n\\n        Polling.prototype._scheduleReceiver = function () {\\n          debug('_scheduleReceiver');\\n          var self = this;\\n          var poll = this.poll = new this.Receiver(this.receiveUrl, this.AjaxObject);\\n\\n          poll.on('message', function (msg) {\\n            debug('message', msg);\\n            self.emit('message', msg);\\n          });\\n\\n          poll.once('close', function (code, reason) {\\n            debug('close', code, reason, self.pollIsClosing);\\n            self.poll = poll = null;\\n\\n            if (!self.pollIsClosing) {\\n              if (reason === 'network') {\\n                self._scheduleReceiver();\\n              } else {\\n                self.emit('close', code || 1006, reason);\\n                self.removeAllListeners();\\n              }\\n            }\\n          });\\n        };\\n\\n        Polling.prototype.abort = function () {\\n          debug('abort');\\n          this.removeAllListeners();\\n          this.pollIsClosing = true;\\n          if (this.poll) {\\n            this.poll.abort();\\n          }\\n        };\\n\\n        module.exports = Polling;\\n      }).call(this, { env: {} });\\n    }, { \\\"debug\\\": 54, \\\"events\\\": 3, \\\"inherits\\\": 56 }], 28: [function (require, module, exports) {\\n      (function (process) {\\n        'use strict';\\n\\n        var inherits = require('inherits'),\\n            urlUtils = require('../../utils/url'),\\n            BufferedSender = require('./buffered-sender'),\\n            Polling = require('./polling');\\n\\n        var debug = function () {};\\n        if (process.env.NODE_ENV !== 'production') {\\n          debug = require('debug')('sockjs-client:sender-receiver');\\n        }\\n\\n        function SenderReceiver(transUrl, urlSuffix, senderFunc, Receiver, AjaxObject) {\\n          var pollUrl = urlUtils.addPath(transUrl, urlSuffix);\\n          debug(pollUrl);\\n          var self = this;\\n          BufferedSender.call(this, transUrl, senderFunc);\\n\\n          this.poll = new Polling(Receiver, pollUrl, AjaxObject);\\n          this.poll.on('message', function (msg) {\\n            debug('poll message', msg);\\n            self.emit('message', msg);\\n          });\\n          this.poll.once('close', function (code, reason) {\\n            debug('poll close', code, reason);\\n            self.poll = null;\\n            self.emit('close', code, reason);\\n            self.close();\\n          });\\n        }\\n\\n        inherits(SenderReceiver, BufferedSender);\\n\\n        SenderReceiver.prototype.close = function () {\\n          BufferedSender.prototype.close.call(this);\\n          debug('close');\\n          this.removeAllListeners();\\n          if (this.poll) {\\n            this.poll.abort();\\n            this.poll = null;\\n          }\\n        };\\n\\n        module.exports = SenderReceiver;\\n      }).call(this, { env: {} });\\n    }, { \\\"../../utils/url\\\": 52, \\\"./buffered-sender\\\": 25, \\\"./polling\\\": 27, \\\"debug\\\": 54, \\\"inherits\\\": 56 }], 29: [function (require, module, exports) {\\n      (function (process) {\\n        'use strict';\\n\\n        var inherits = require('inherits'),\\n            EventEmitter = require('events').EventEmitter,\\n            EventSourceDriver = require('eventsource');\\n\\n        var debug = function () {};\\n        if (process.env.NODE_ENV !== 'production') {\\n          debug = require('debug')('sockjs-client:receiver:eventsource');\\n        }\\n\\n        function EventSourceReceiver(url) {\\n          debug(url);\\n          EventEmitter.call(this);\\n\\n          var self = this;\\n          var es = this.es = new EventSourceDriver(url);\\n          es.onmessage = function (e) {\\n            debug('message', e.data);\\n            self.emit('message', decodeURI(e.data));\\n          };\\n          es.onerror = function (e) {\\n            debug('error', es.readyState, e);\\n            // ES on reconnection has readyState = 0 or 1.\\n            // on network error it's CLOSED = 2\\n            var reason = es.readyState !== 2 ? 'network' : 'permanent';\\n            self._cleanup();\\n            self._close(reason);\\n          };\\n        }\\n\\n        inherits(EventSourceReceiver, EventEmitter);\\n\\n        EventSourceReceiver.prototype.abort = function () {\\n          debug('abort');\\n          this._cleanup();\\n          this._close('user');\\n        };\\n\\n        EventSourceReceiver.prototype._cleanup = function () {\\n          debug('cleanup');\\n          var es = this.es;\\n          if (es) {\\n            es.onmessage = es.onerror = null;\\n            es.close();\\n            this.es = null;\\n          }\\n        };\\n\\n        EventSourceReceiver.prototype._close = function (reason) {\\n          debug('close', reason);\\n          var self = this;\\n          // Safari and chrome < 15 crash if we close window before\\n          // waiting for ES cleanup. See:\\n          // https://code.google.com/p/chromium/issues/detail?id=89155\\n          setTimeout(function () {\\n            self.emit('close', null, reason);\\n            self.removeAllListeners();\\n          }, 200);\\n        };\\n\\n        module.exports = EventSourceReceiver;\\n      }).call(this, { env: {} });\\n    }, { \\\"debug\\\": 54, \\\"events\\\": 3, \\\"eventsource\\\": 18, \\\"inherits\\\": 56 }], 30: [function (require, module, exports) {\\n      (function (process, global) {\\n        'use strict';\\n\\n        var inherits = require('inherits'),\\n            iframeUtils = require('../../utils/iframe'),\\n            urlUtils = require('../../utils/url'),\\n            EventEmitter = require('events').EventEmitter,\\n            random = require('../../utils/random');\\n\\n        var debug = function () {};\\n        if (process.env.NODE_ENV !== 'production') {\\n          debug = require('debug')('sockjs-client:receiver:htmlfile');\\n        }\\n\\n        function HtmlfileReceiver(url) {\\n          debug(url);\\n          EventEmitter.call(this);\\n          var self = this;\\n          iframeUtils.polluteGlobalNamespace();\\n\\n          this.id = 'a' + random.string(6);\\n          url = urlUtils.addQuery(url, 'c=' + decodeURIComponent(iframeUtils.WPrefix + '.' + this.id));\\n\\n          debug('using htmlfile', HtmlfileReceiver.htmlfileEnabled);\\n          var constructFunc = HtmlfileReceiver.htmlfileEnabled ? iframeUtils.createHtmlfile : iframeUtils.createIframe;\\n\\n          global[iframeUtils.WPrefix][this.id] = {\\n            start: function () {\\n              debug('start');\\n              self.iframeObj.loaded();\\n            },\\n            message: function (data) {\\n              debug('message', data);\\n              self.emit('message', data);\\n            },\\n            stop: function () {\\n              debug('stop');\\n              self._cleanup();\\n              self._close('network');\\n            }\\n          };\\n          this.iframeObj = constructFunc(url, function () {\\n            debug('callback');\\n            self._cleanup();\\n            self._close('permanent');\\n          });\\n        }\\n\\n        inherits(HtmlfileReceiver, EventEmitter);\\n\\n        HtmlfileReceiver.prototype.abort = function () {\\n          debug('abort');\\n          this._cleanup();\\n          this._close('user');\\n        };\\n\\n        HtmlfileReceiver.prototype._cleanup = function () {\\n          debug('_cleanup');\\n          if (this.iframeObj) {\\n            this.iframeObj.cleanup();\\n            this.iframeObj = null;\\n          }\\n          delete global[iframeUtils.WPrefix][this.id];\\n        };\\n\\n        HtmlfileReceiver.prototype._close = function (reason) {\\n          debug('_close', reason);\\n          this.emit('close', null, reason);\\n          this.removeAllListeners();\\n        };\\n\\n        HtmlfileReceiver.htmlfileEnabled = false;\\n\\n        // obfuscate to avoid firewalls\\n        var axo = ['Active'].concat('Object').join('X');\\n        if (axo in global) {\\n          try {\\n            HtmlfileReceiver.htmlfileEnabled = !!new global[axo]('htmlfile');\\n          } catch (x) {\\n            // intentionally empty\\n          }\\n        }\\n\\n        HtmlfileReceiver.enabled = HtmlfileReceiver.htmlfileEnabled || iframeUtils.iframeEnabled;\\n\\n        module.exports = HtmlfileReceiver;\\n      }).call(this, { env: {} }, typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {});\\n    }, { \\\"../../utils/iframe\\\": 47, \\\"../../utils/random\\\": 50, \\\"../../utils/url\\\": 52, \\\"debug\\\": 54, \\\"events\\\": 3, \\\"inherits\\\": 56 }], 31: [function (require, module, exports) {\\n      (function (process, global) {\\n        'use strict';\\n\\n        var utils = require('../../utils/iframe'),\\n            random = require('../../utils/random'),\\n            browser = require('../../utils/browser'),\\n            urlUtils = require('../../utils/url'),\\n            inherits = require('inherits'),\\n            EventEmitter = require('events').EventEmitter;\\n\\n        var debug = function () {};\\n        if (process.env.NODE_ENV !== 'production') {\\n          debug = require('debug')('sockjs-client:receiver:jsonp');\\n        }\\n\\n        function JsonpReceiver(url) {\\n          debug(url);\\n          var self = this;\\n          EventEmitter.call(this);\\n\\n          utils.polluteGlobalNamespace();\\n\\n          this.id = 'a' + random.string(6);\\n          var urlWithId = urlUtils.addQuery(url, 'c=' + encodeURIComponent(utils.WPrefix + '.' + this.id));\\n\\n          global[utils.WPrefix][this.id] = this._callback.bind(this);\\n          this._createScript(urlWithId);\\n\\n          // Fallback mostly for Konqueror - stupid timer, 35 seconds shall be plenty.\\n          this.timeoutId = setTimeout(function () {\\n            debug('timeout');\\n            self._abort(new Error('JSONP script loaded abnormally (timeout)'));\\n          }, JsonpReceiver.timeout);\\n        }\\n\\n        inherits(JsonpReceiver, EventEmitter);\\n\\n        JsonpReceiver.prototype.abort = function () {\\n          debug('abort');\\n          if (global[utils.WPrefix][this.id]) {\\n            var err = new Error('JSONP user aborted read');\\n            err.code = 1000;\\n            this._abort(err);\\n          }\\n        };\\n\\n        JsonpReceiver.timeout = 35000;\\n        JsonpReceiver.scriptErrorTimeout = 1000;\\n\\n        JsonpReceiver.prototype._callback = function (data) {\\n          debug('_callback', data);\\n          this._cleanup();\\n\\n          if (this.aborting) {\\n            return;\\n          }\\n\\n          if (data) {\\n            debug('message', data);\\n            this.emit('message', data);\\n          }\\n          this.emit('close', null, 'network');\\n          this.removeAllListeners();\\n        };\\n\\n        JsonpReceiver.prototype._abort = function (err) {\\n          debug('_abort', err);\\n          this._cleanup();\\n          this.aborting = true;\\n          this.emit('close', err.code, err.message);\\n          this.removeAllListeners();\\n        };\\n\\n        JsonpReceiver.prototype._cleanup = function () {\\n          debug('_cleanup');\\n          clearTimeout(this.timeoutId);\\n          if (this.script2) {\\n            this.script2.parentNode.removeChild(this.script2);\\n            this.script2 = null;\\n          }\\n          if (this.script) {\\n            var script = this.script;\\n            // Unfortunately, you can't really abort script loading of\\n            // the script.\\n            script.parentNode.removeChild(script);\\n            script.onreadystatechange = script.onerror = script.onload = script.onclick = null;\\n            this.script = null;\\n          }\\n          delete global[utils.WPrefix][this.id];\\n        };\\n\\n        JsonpReceiver.prototype._scriptError = function () {\\n          debug('_scriptError');\\n          var self = this;\\n          if (this.errorTimer) {\\n            return;\\n          }\\n\\n          this.errorTimer = setTimeout(function () {\\n            if (!self.loadedOkay) {\\n              self._abort(new Error('JSONP script loaded abnormally (onerror)'));\\n            }\\n          }, JsonpReceiver.scriptErrorTimeout);\\n        };\\n\\n        JsonpReceiver.prototype._createScript = function (url) {\\n          debug('_createScript', url);\\n          var self = this;\\n          var script = this.script = global.document.createElement('script');\\n          var script2; // Opera synchronous load trick.\\n\\n          script.id = 'a' + random.string(8);\\n          script.src = url;\\n          script.type = 'text/javascript';\\n          script.charset = 'UTF-8';\\n          script.onerror = this._scriptError.bind(this);\\n          script.onload = function () {\\n            debug('onload');\\n            self._abort(new Error('JSONP script loaded abnormally (onload)'));\\n          };\\n\\n          // IE9 fires 'error' event after onreadystatechange or before, in random order.\\n          // Use loadedOkay to determine if actually errored\\n          script.onreadystatechange = function () {\\n            debug('onreadystatechange', script.readyState);\\n            if (/loaded|closed/.test(script.readyState)) {\\n              if (script && script.htmlFor && script.onclick) {\\n                self.loadedOkay = true;\\n                try {\\n                  // In IE, actually execute the script.\\n                  script.onclick();\\n                } catch (x) {\\n                  // intentionally empty\\n                }\\n              }\\n              if (script) {\\n                self._abort(new Error('JSONP script loaded abnormally (onreadystatechange)'));\\n              }\\n            }\\n          };\\n          // IE: event/htmlFor/onclick trick.\\n          // One can't rely on proper order for onreadystatechange. In order to\\n          // make sure, set a 'htmlFor' and 'event' properties, so that\\n          // script code will be installed as 'onclick' handler for the\\n          // script object. Later, onreadystatechange, manually execute this\\n          // code. FF and Chrome doesn't work with 'event' and 'htmlFor'\\n          // set. For reference see:\\n          //   http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html\\n          // Also, read on that about script ordering:\\n          //   http://wiki.whatwg.org/wiki/Dynamic_Script_Execution_Order\\n          if (typeof script.async === 'undefined' && global.document.attachEvent) {\\n            // According to mozilla docs, in recent browsers script.async defaults\\n            // to 'true', so we may use it to detect a good browser:\\n            // https://developer.mozilla.org/en/HTML/Element/script\\n            if (!browser.isOpera()) {\\n              // Naively assume we're in IE\\n              try {\\n                script.htmlFor = script.id;\\n                script.event = 'onclick';\\n              } catch (x) {\\n                // intentionally empty\\n              }\\n              script.async = true;\\n            } else {\\n              // Opera, second sync script hack\\n              script2 = this.script2 = global.document.createElement('script');\\n              script2.text = \\\"try{var a = document.getElementById('\\\" + script.id + \\\"'); if(a)a.onerror();}catch(x){};\\\";\\n              script.async = script2.async = false;\\n            }\\n          }\\n          if (typeof script.async !== 'undefined') {\\n            script.async = true;\\n          }\\n\\n          var head = global.document.getElementsByTagName('head')[0];\\n          head.insertBefore(script, head.firstChild);\\n          if (script2) {\\n            head.insertBefore(script2, head.firstChild);\\n          }\\n        };\\n\\n        module.exports = JsonpReceiver;\\n      }).call(this, { env: {} }, typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {});\\n    }, { \\\"../../utils/browser\\\": 44, \\\"../../utils/iframe\\\": 47, \\\"../../utils/random\\\": 50, \\\"../../utils/url\\\": 52, \\\"debug\\\": 54, \\\"events\\\": 3, \\\"inherits\\\": 56 }], 32: [function (require, module, exports) {\\n      (function (process) {\\n        'use strict';\\n\\n        var inherits = require('inherits'),\\n            EventEmitter = require('events').EventEmitter;\\n\\n        var debug = function () {};\\n        if (process.env.NODE_ENV !== 'production') {\\n          debug = require('debug')('sockjs-client:receiver:xhr');\\n        }\\n\\n        function XhrReceiver(url, AjaxObject) {\\n          debug(url);\\n          EventEmitter.call(this);\\n          var self = this;\\n\\n          this.bufferPosition = 0;\\n\\n          this.xo = new AjaxObject('POST', url, null);\\n          this.xo.on('chunk', this._chunkHandler.bind(this));\\n          this.xo.once('finish', function (status, text) {\\n            debug('finish', status, text);\\n            self._chunkHandler(status, text);\\n            self.xo = null;\\n            var reason = status === 200 ? 'network' : 'permanent';\\n            debug('close', reason);\\n            self.emit('close', null, reason);\\n            self._cleanup();\\n          });\\n        }\\n\\n        inherits(XhrReceiver, EventEmitter);\\n\\n        XhrReceiver.prototype._chunkHandler = function (status, text) {\\n          debug('_chunkHandler', status);\\n          if (status !== 200 || !text) {\\n            return;\\n          }\\n\\n          for (var idx = -1;; this.bufferPosition += idx + 1) {\\n            var buf = text.slice(this.bufferPosition);\\n            idx = buf.indexOf('\\\\n');\\n            if (idx === -1) {\\n              break;\\n            }\\n            var msg = buf.slice(0, idx);\\n            if (msg) {\\n              debug('message', msg);\\n              this.emit('message', msg);\\n            }\\n          }\\n        };\\n\\n        XhrReceiver.prototype._cleanup = function () {\\n          debug('_cleanup');\\n          this.removeAllListeners();\\n        };\\n\\n        XhrReceiver.prototype.abort = function () {\\n          debug('abort');\\n          if (this.xo) {\\n            this.xo.close();\\n            debug('close');\\n            this.emit('close', null, 'user');\\n            this.xo = null;\\n          }\\n          this._cleanup();\\n        };\\n\\n        module.exports = XhrReceiver;\\n      }).call(this, { env: {} });\\n    }, { \\\"debug\\\": 54, \\\"events\\\": 3, \\\"inherits\\\": 56 }], 33: [function (require, module, exports) {\\n      (function (process, global) {\\n        'use strict';\\n\\n        var random = require('../../utils/random'),\\n            urlUtils = require('../../utils/url');\\n\\n        var debug = function () {};\\n        if (process.env.NODE_ENV !== 'production') {\\n          debug = require('debug')('sockjs-client:sender:jsonp');\\n        }\\n\\n        var form, area;\\n\\n        function createIframe(id) {\\n          debug('createIframe', id);\\n          try {\\n            // ie6 dynamic iframes with target=\\\"\\\" support (thanks Chris Lambacher)\\n            return global.document.createElement('<iframe name=\\\"' + id + '\\\">');\\n          } catch (x) {\\n            var iframe = global.document.createElement('iframe');\\n            iframe.name = id;\\n            return iframe;\\n          }\\n        }\\n\\n        function createForm() {\\n          debug('createForm');\\n          form = global.document.createElement('form');\\n          form.style.display = 'none';\\n          form.style.position = 'absolute';\\n          form.method = 'POST';\\n          form.enctype = 'application/x-www-form-urlencoded';\\n          form.acceptCharset = 'UTF-8';\\n\\n          area = global.document.createElement('textarea');\\n          area.name = 'd';\\n          form.appendChild(area);\\n\\n          global.document.body.appendChild(form);\\n        }\\n\\n        module.exports = function (url, payload, callback) {\\n          debug(url, payload);\\n          if (!form) {\\n            createForm();\\n          }\\n          var id = 'a' + random.string(8);\\n          form.target = id;\\n          form.action = urlUtils.addQuery(urlUtils.addPath(url, '/jsonp_send'), 'i=' + id);\\n\\n          var iframe = createIframe(id);\\n          iframe.id = id;\\n          iframe.style.display = 'none';\\n          form.appendChild(iframe);\\n\\n          try {\\n            area.value = payload;\\n          } catch (e) {\\n            // seriously broken browsers get here\\n          }\\n          form.submit();\\n\\n          var completed = function (err) {\\n            debug('completed', id, err);\\n            if (!iframe.onerror) {\\n              return;\\n            }\\n            iframe.onreadystatechange = iframe.onerror = iframe.onload = null;\\n            // Opera mini doesn't like if we GC iframe\\n            // immediately, thus this timeout.\\n            setTimeout(function () {\\n              debug('cleaning up', id);\\n              iframe.parentNode.removeChild(iframe);\\n              iframe = null;\\n            }, 500);\\n            area.value = '';\\n            // It is not possible to detect if the iframe succeeded or\\n            // failed to submit our form.\\n            callback(err);\\n          };\\n          iframe.onerror = function () {\\n            debug('onerror', id);\\n            completed();\\n          };\\n          iframe.onload = function () {\\n            debug('onload', id);\\n            completed();\\n          };\\n          iframe.onreadystatechange = function (e) {\\n            debug('onreadystatechange', id, iframe.readyState, e);\\n            if (iframe.readyState === 'complete') {\\n              completed();\\n            }\\n          };\\n          return function () {\\n            debug('aborted', id);\\n            completed(new Error('Aborted'));\\n          };\\n        };\\n      }).call(this, { env: {} }, typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {});\\n    }, { \\\"../../utils/random\\\": 50, \\\"../../utils/url\\\": 52, \\\"debug\\\": 54 }], 34: [function (require, module, exports) {\\n      (function (process, global) {\\n        'use strict';\\n\\n        var EventEmitter = require('events').EventEmitter,\\n            inherits = require('inherits'),\\n            eventUtils = require('../../utils/event'),\\n            browser = require('../../utils/browser'),\\n            urlUtils = require('../../utils/url');\\n\\n        var debug = function () {};\\n        if (process.env.NODE_ENV !== 'production') {\\n          debug = require('debug')('sockjs-client:sender:xdr');\\n        }\\n\\n        // References:\\n        //   http://ajaxian.com/archives/100-line-ajax-wrapper\\n        //   http://msdn.microsoft.com/en-us/library/cc288060(v=VS.85).aspx\\n\\n        function XDRObject(method, url, payload) {\\n          debug(method, url);\\n          var self = this;\\n          EventEmitter.call(this);\\n\\n          setTimeout(function () {\\n            self._start(method, url, payload);\\n          }, 0);\\n        }\\n\\n        inherits(XDRObject, EventEmitter);\\n\\n        XDRObject.prototype._start = function (method, url, payload) {\\n          debug('_start');\\n          var self = this;\\n          var xdr = new global.XDomainRequest();\\n          // IE caches even POSTs\\n          url = urlUtils.addQuery(url, 't=' + +new Date());\\n\\n          xdr.onerror = function () {\\n            debug('onerror');\\n            self._error();\\n          };\\n          xdr.ontimeout = function () {\\n            debug('ontimeout');\\n            self._error();\\n          };\\n          xdr.onprogress = function () {\\n            debug('progress', xdr.responseText);\\n            self.emit('chunk', 200, xdr.responseText);\\n          };\\n          xdr.onload = function () {\\n            debug('load');\\n            self.emit('finish', 200, xdr.responseText);\\n            self._cleanup(false);\\n          };\\n          this.xdr = xdr;\\n          this.unloadRef = eventUtils.unloadAdd(function () {\\n            self._cleanup(true);\\n          });\\n          try {\\n            // Fails with AccessDenied if port number is bogus\\n            this.xdr.open(method, url);\\n            if (this.timeout) {\\n              this.xdr.timeout = this.timeout;\\n            }\\n            this.xdr.send(payload);\\n          } catch (x) {\\n            this._error();\\n          }\\n        };\\n\\n        XDRObject.prototype._error = function () {\\n          this.emit('finish', 0, '');\\n          this._cleanup(false);\\n        };\\n\\n        XDRObject.prototype._cleanup = function (abort) {\\n          debug('cleanup', abort);\\n          if (!this.xdr) {\\n            return;\\n          }\\n          this.removeAllListeners();\\n          eventUtils.unloadDel(this.unloadRef);\\n\\n          this.xdr.ontimeout = this.xdr.onerror = this.xdr.onprogress = this.xdr.onload = null;\\n          if (abort) {\\n            try {\\n              this.xdr.abort();\\n            } catch (x) {\\n              // intentionally empty\\n            }\\n          }\\n          this.unloadRef = this.xdr = null;\\n        };\\n\\n        XDRObject.prototype.close = function () {\\n          debug('close');\\n          this._cleanup(true);\\n        };\\n\\n        // IE 8/9 if the request target uses the same scheme - #79\\n        XDRObject.enabled = !!(global.XDomainRequest && browser.hasDomain());\\n\\n        module.exports = XDRObject;\\n      }).call(this, { env: {} }, typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {});\\n    }, { \\\"../../utils/browser\\\": 44, \\\"../../utils/event\\\": 46, \\\"../../utils/url\\\": 52, \\\"debug\\\": 54, \\\"events\\\": 3, \\\"inherits\\\": 56 }], 35: [function (require, module, exports) {\\n      'use strict';\\n\\n      var inherits = require('inherits'),\\n          XhrDriver = require('../driver/xhr');\\n\\n      function XHRCorsObject(method, url, payload, opts) {\\n        XhrDriver.call(this, method, url, payload, opts);\\n      }\\n\\n      inherits(XHRCorsObject, XhrDriver);\\n\\n      XHRCorsObject.enabled = XhrDriver.enabled && XhrDriver.supportsCORS;\\n\\n      module.exports = XHRCorsObject;\\n    }, { \\\"../driver/xhr\\\": 17, \\\"inherits\\\": 56 }], 36: [function (require, module, exports) {\\n      'use strict';\\n\\n      var EventEmitter = require('events').EventEmitter,\\n          inherits = require('inherits');\\n\\n      function XHRFake() /* method, url, payload, opts */{\\n        var self = this;\\n        EventEmitter.call(this);\\n\\n        this.to = setTimeout(function () {\\n          self.emit('finish', 200, '{}');\\n        }, XHRFake.timeout);\\n      }\\n\\n      inherits(XHRFake, EventEmitter);\\n\\n      XHRFake.prototype.close = function () {\\n        clearTimeout(this.to);\\n      };\\n\\n      XHRFake.timeout = 2000;\\n\\n      module.exports = XHRFake;\\n    }, { \\\"events\\\": 3, \\\"inherits\\\": 56 }], 37: [function (require, module, exports) {\\n      'use strict';\\n\\n      var inherits = require('inherits'),\\n          XhrDriver = require('../driver/xhr');\\n\\n      function XHRLocalObject(method, url, payload /*, opts */) {\\n        XhrDriver.call(this, method, url, payload, {\\n          noCredentials: true\\n        });\\n      }\\n\\n      inherits(XHRLocalObject, XhrDriver);\\n\\n      XHRLocalObject.enabled = XhrDriver.enabled;\\n\\n      module.exports = XHRLocalObject;\\n    }, { \\\"../driver/xhr\\\": 17, \\\"inherits\\\": 56 }], 38: [function (require, module, exports) {\\n      (function (process) {\\n        'use strict';\\n\\n        var utils = require('../utils/event'),\\n            urlUtils = require('../utils/url'),\\n            inherits = require('inherits'),\\n            EventEmitter = require('events').EventEmitter,\\n            WebsocketDriver = require('./driver/websocket');\\n\\n        var debug = function () {};\\n        if (process.env.NODE_ENV !== 'production') {\\n          debug = require('debug')('sockjs-client:websocket');\\n        }\\n\\n        function WebSocketTransport(transUrl, ignore, options) {\\n          if (!WebSocketTransport.enabled()) {\\n            throw new Error('Transport created when disabled');\\n          }\\n\\n          EventEmitter.call(this);\\n          debug('constructor', transUrl);\\n\\n          var self = this;\\n          var url = urlUtils.addPath(transUrl, '/websocket');\\n          if (url.slice(0, 5) === 'https') {\\n            url = 'wss' + url.slice(5);\\n          } else {\\n            url = 'ws' + url.slice(4);\\n          }\\n          this.url = url;\\n\\n          this.ws = new WebsocketDriver(this.url, [], options);\\n          this.ws.onmessage = function (e) {\\n            debug('message event', e.data);\\n            self.emit('message', e.data);\\n          };\\n          // Firefox has an interesting bug. If a websocket connection is\\n          // created after onunload, it stays alive even when user\\n          // navigates away from the page. In such situation let's lie -\\n          // let's not open the ws connection at all. See:\\n          // https://github.com/sockjs/sockjs-client/issues/28\\n          // https://bugzilla.mozilla.org/show_bug.cgi?id=696085\\n          this.unloadRef = utils.unloadAdd(function () {\\n            debug('unload');\\n            self.ws.close();\\n          });\\n          this.ws.onclose = function (e) {\\n            debug('close event', e.code, e.reason);\\n            self.emit('close', e.code, e.reason);\\n            self._cleanup();\\n          };\\n          this.ws.onerror = function (e) {\\n            debug('error event', e);\\n            self.emit('close', 1006, 'WebSocket connection broken');\\n            self._cleanup();\\n          };\\n        }\\n\\n        inherits(WebSocketTransport, EventEmitter);\\n\\n        WebSocketTransport.prototype.send = function (data) {\\n          var msg = '[' + data + ']';\\n          debug('send', msg);\\n          this.ws.send(msg);\\n        };\\n\\n        WebSocketTransport.prototype.close = function () {\\n          debug('close');\\n          var ws = this.ws;\\n          this._cleanup();\\n          if (ws) {\\n            ws.close();\\n          }\\n        };\\n\\n        WebSocketTransport.prototype._cleanup = function () {\\n          debug('_cleanup');\\n          var ws = this.ws;\\n          if (ws) {\\n            ws.onmessage = ws.onclose = ws.onerror = null;\\n          }\\n          utils.unloadDel(this.unloadRef);\\n          this.unloadRef = this.ws = null;\\n          this.removeAllListeners();\\n        };\\n\\n        WebSocketTransport.enabled = function () {\\n          debug('enabled');\\n          return !!WebsocketDriver;\\n        };\\n        WebSocketTransport.transportName = 'websocket';\\n\\n        // In theory, ws should require 1 round trip. But in chrome, this is\\n        // not very stable over SSL. Most likely a ws connection requires a\\n        // separate SSL connection, in which case 2 round trips are an\\n        // absolute minumum.\\n        WebSocketTransport.roundTrips = 2;\\n\\n        module.exports = WebSocketTransport;\\n      }).call(this, { env: {} });\\n    }, { \\\"../utils/event\\\": 46, \\\"../utils/url\\\": 52, \\\"./driver/websocket\\\": 19, \\\"debug\\\": 54, \\\"events\\\": 3, \\\"inherits\\\": 56 }], 39: [function (require, module, exports) {\\n      'use strict';\\n\\n      var inherits = require('inherits'),\\n          AjaxBasedTransport = require('./lib/ajax-based'),\\n          XdrStreamingTransport = require('./xdr-streaming'),\\n          XhrReceiver = require('./receiver/xhr'),\\n          XDRObject = require('./sender/xdr');\\n\\n      function XdrPollingTransport(transUrl) {\\n        if (!XDRObject.enabled) {\\n          throw new Error('Transport created when disabled');\\n        }\\n        AjaxBasedTransport.call(this, transUrl, '/xhr', XhrReceiver, XDRObject);\\n      }\\n\\n      inherits(XdrPollingTransport, AjaxBasedTransport);\\n\\n      XdrPollingTransport.enabled = XdrStreamingTransport.enabled;\\n      XdrPollingTransport.transportName = 'xdr-polling';\\n      XdrPollingTransport.roundTrips = 2; // preflight, ajax\\n\\n      module.exports = XdrPollingTransport;\\n    }, { \\\"./lib/ajax-based\\\": 24, \\\"./receiver/xhr\\\": 32, \\\"./sender/xdr\\\": 34, \\\"./xdr-streaming\\\": 40, \\\"inherits\\\": 56 }], 40: [function (require, module, exports) {\\n      'use strict';\\n\\n      var inherits = require('inherits'),\\n          AjaxBasedTransport = require('./lib/ajax-based'),\\n          XhrReceiver = require('./receiver/xhr'),\\n          XDRObject = require('./sender/xdr');\\n\\n      // According to:\\n      //   http://stackoverflow.com/questions/1641507/detect-browser-support-for-cross-domain-xmlhttprequests\\n      //   http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/\\n\\n      function XdrStreamingTransport(transUrl) {\\n        if (!XDRObject.enabled) {\\n          throw new Error('Transport created when disabled');\\n        }\\n        AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XDRObject);\\n      }\\n\\n      inherits(XdrStreamingTransport, AjaxBasedTransport);\\n\\n      XdrStreamingTransport.enabled = function (info) {\\n        if (info.cookie_needed || info.nullOrigin) {\\n          return false;\\n        }\\n        return XDRObject.enabled && info.sameScheme;\\n      };\\n\\n      XdrStreamingTransport.transportName = 'xdr-streaming';\\n      XdrStreamingTransport.roundTrips = 2; // preflight, ajax\\n\\n      module.exports = XdrStreamingTransport;\\n    }, { \\\"./lib/ajax-based\\\": 24, \\\"./receiver/xhr\\\": 32, \\\"./sender/xdr\\\": 34, \\\"inherits\\\": 56 }], 41: [function (require, module, exports) {\\n      'use strict';\\n\\n      var inherits = require('inherits'),\\n          AjaxBasedTransport = require('./lib/ajax-based'),\\n          XhrReceiver = require('./receiver/xhr'),\\n          XHRCorsObject = require('./sender/xhr-cors'),\\n          XHRLocalObject = require('./sender/xhr-local');\\n\\n      function XhrPollingTransport(transUrl) {\\n        if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {\\n          throw new Error('Transport created when disabled');\\n        }\\n        AjaxBasedTransport.call(this, transUrl, '/xhr', XhrReceiver, XHRCorsObject);\\n      }\\n\\n      inherits(XhrPollingTransport, AjaxBasedTransport);\\n\\n      XhrPollingTransport.enabled = function (info) {\\n        if (info.nullOrigin) {\\n          return false;\\n        }\\n\\n        if (XHRLocalObject.enabled && info.sameOrigin) {\\n          return true;\\n        }\\n        return XHRCorsObject.enabled;\\n      };\\n\\n      XhrPollingTransport.transportName = 'xhr-polling';\\n      XhrPollingTransport.roundTrips = 2; // preflight, ajax\\n\\n      module.exports = XhrPollingTransport;\\n    }, { \\\"./lib/ajax-based\\\": 24, \\\"./receiver/xhr\\\": 32, \\\"./sender/xhr-cors\\\": 35, \\\"./sender/xhr-local\\\": 37, \\\"inherits\\\": 56 }], 42: [function (require, module, exports) {\\n      (function (global) {\\n        'use strict';\\n\\n        var inherits = require('inherits'),\\n            AjaxBasedTransport = require('./lib/ajax-based'),\\n            XhrReceiver = require('./receiver/xhr'),\\n            XHRCorsObject = require('./sender/xhr-cors'),\\n            XHRLocalObject = require('./sender/xhr-local'),\\n            browser = require('../utils/browser');\\n\\n        function XhrStreamingTransport(transUrl) {\\n          if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {\\n            throw new Error('Transport created when disabled');\\n          }\\n          AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XHRCorsObject);\\n        }\\n\\n        inherits(XhrStreamingTransport, AjaxBasedTransport);\\n\\n        XhrStreamingTransport.enabled = function (info) {\\n          if (info.nullOrigin) {\\n            return false;\\n          }\\n          // Opera doesn't support xhr-streaming #60\\n          // But it might be able to #92\\n          if (browser.isOpera()) {\\n            return false;\\n          }\\n\\n          return XHRCorsObject.enabled;\\n        };\\n\\n        XhrStreamingTransport.transportName = 'xhr-streaming';\\n        XhrStreamingTransport.roundTrips = 2; // preflight, ajax\\n\\n        // Safari gets confused when a streaming ajax request is started\\n        // before onload. This causes the load indicator to spin indefinetely.\\n        // Only require body when used in a browser\\n        XhrStreamingTransport.needBody = !!global.document;\\n\\n        module.exports = XhrStreamingTransport;\\n      }).call(this, typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {});\\n    }, { \\\"../utils/browser\\\": 44, \\\"./lib/ajax-based\\\": 24, \\\"./receiver/xhr\\\": 32, \\\"./sender/xhr-cors\\\": 35, \\\"./sender/xhr-local\\\": 37, \\\"inherits\\\": 56 }], 43: [function (require, module, exports) {\\n      (function (global) {\\n        'use strict';\\n\\n        if (global.crypto && global.crypto.getRandomValues) {\\n          module.exports.randomBytes = function (length) {\\n            var bytes = new Uint8Array(length);\\n            global.crypto.getRandomValues(bytes);\\n            return bytes;\\n          };\\n        } else {\\n          module.exports.randomBytes = function (length) {\\n            var bytes = new Array(length);\\n            for (var i = 0; i < length; i++) {\\n              bytes[i] = Math.floor(Math.random() * 256);\\n            }\\n            return bytes;\\n          };\\n        }\\n      }).call(this, typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {});\\n    }, {}], 44: [function (require, module, exports) {\\n      (function (global) {\\n        'use strict';\\n\\n        module.exports = {\\n          isOpera: function () {\\n            return global.navigator && /opera/i.test(global.navigator.userAgent);\\n          },\\n\\n          isKonqueror: function () {\\n            return global.navigator && /konqueror/i.test(global.navigator.userAgent);\\n          }\\n\\n          // #187 wrap document.domain in try/catch because of WP8 from file:///\\n          , hasDomain: function () {\\n            // non-browser client always has a domain\\n            if (!global.document) {\\n              return true;\\n            }\\n\\n            try {\\n              return !!global.document.domain;\\n            } catch (e) {\\n              return false;\\n            }\\n          }\\n        };\\n      }).call(this, typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {});\\n    }, {}], 45: [function (require, module, exports) {\\n      'use strict';\\n\\n      var JSON3 = require('json3');\\n\\n      // Some extra characters that Chrome gets wrong, and substitutes with\\n      // something else on the wire.\\n      // eslint-disable-next-line no-control-regex\\n      var extraEscapable = /[\\\\x00-\\\\x1f\\\\ud800-\\\\udfff\\\\ufffe\\\\uffff\\\\u0300-\\\\u0333\\\\u033d-\\\\u0346\\\\u034a-\\\\u034c\\\\u0350-\\\\u0352\\\\u0357-\\\\u0358\\\\u035c-\\\\u0362\\\\u0374\\\\u037e\\\\u0387\\\\u0591-\\\\u05af\\\\u05c4\\\\u0610-\\\\u0617\\\\u0653-\\\\u0654\\\\u0657-\\\\u065b\\\\u065d-\\\\u065e\\\\u06df-\\\\u06e2\\\\u06eb-\\\\u06ec\\\\u0730\\\\u0732-\\\\u0733\\\\u0735-\\\\u0736\\\\u073a\\\\u073d\\\\u073f-\\\\u0741\\\\u0743\\\\u0745\\\\u0747\\\\u07eb-\\\\u07f1\\\\u0951\\\\u0958-\\\\u095f\\\\u09dc-\\\\u09dd\\\\u09df\\\\u0a33\\\\u0a36\\\\u0a59-\\\\u0a5b\\\\u0a5e\\\\u0b5c-\\\\u0b5d\\\\u0e38-\\\\u0e39\\\\u0f43\\\\u0f4d\\\\u0f52\\\\u0f57\\\\u0f5c\\\\u0f69\\\\u0f72-\\\\u0f76\\\\u0f78\\\\u0f80-\\\\u0f83\\\\u0f93\\\\u0f9d\\\\u0fa2\\\\u0fa7\\\\u0fac\\\\u0fb9\\\\u1939-\\\\u193a\\\\u1a17\\\\u1b6b\\\\u1cda-\\\\u1cdb\\\\u1dc0-\\\\u1dcf\\\\u1dfc\\\\u1dfe\\\\u1f71\\\\u1f73\\\\u1f75\\\\u1f77\\\\u1f79\\\\u1f7b\\\\u1f7d\\\\u1fbb\\\\u1fbe\\\\u1fc9\\\\u1fcb\\\\u1fd3\\\\u1fdb\\\\u1fe3\\\\u1feb\\\\u1fee-\\\\u1fef\\\\u1ff9\\\\u1ffb\\\\u1ffd\\\\u2000-\\\\u2001\\\\u20d0-\\\\u20d1\\\\u20d4-\\\\u20d7\\\\u20e7-\\\\u20e9\\\\u2126\\\\u212a-\\\\u212b\\\\u2329-\\\\u232a\\\\u2adc\\\\u302b-\\\\u302c\\\\uaab2-\\\\uaab3\\\\uf900-\\\\ufa0d\\\\ufa10\\\\ufa12\\\\ufa15-\\\\ufa1e\\\\ufa20\\\\ufa22\\\\ufa25-\\\\ufa26\\\\ufa2a-\\\\ufa2d\\\\ufa30-\\\\ufa6d\\\\ufa70-\\\\ufad9\\\\ufb1d\\\\ufb1f\\\\ufb2a-\\\\ufb36\\\\ufb38-\\\\ufb3c\\\\ufb3e\\\\ufb40-\\\\ufb41\\\\ufb43-\\\\ufb44\\\\ufb46-\\\\ufb4e\\\\ufff0-\\\\uffff]/g,\\n          extraLookup;\\n\\n      // This may be quite slow, so let's delay until user actually uses bad\\n      // characters.\\n      var unrollLookup = function (escapable) {\\n        var i;\\n        var unrolled = {};\\n        var c = [];\\n        for (i = 0; i < 65536; i++) {\\n          c.push(String.fromCharCode(i));\\n        }\\n        escapable.lastIndex = 0;\\n        c.join('').replace(escapable, function (a) {\\n          unrolled[a] = '\\\\\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\\n          return '';\\n        });\\n        escapable.lastIndex = 0;\\n        return unrolled;\\n      };\\n\\n      // Quote string, also taking care of unicode characters that browsers\\n      // often break. Especially, take care of unicode surrogates:\\n      // http://en.wikipedia.org/wiki/Mapping_of_Unicode_characters#Surrogates\\n      module.exports = {\\n        quote: function (string) {\\n          var quoted = JSON3.stringify(string);\\n\\n          // In most cases this should be very fast and good enough.\\n          extraEscapable.lastIndex = 0;\\n          if (!extraEscapable.test(quoted)) {\\n            return quoted;\\n          }\\n\\n          if (!extraLookup) {\\n            extraLookup = unrollLookup(extraEscapable);\\n          }\\n\\n          return quoted.replace(extraEscapable, function (a) {\\n            return extraLookup[a];\\n          });\\n        }\\n      };\\n    }, { \\\"json3\\\": 57 }], 46: [function (require, module, exports) {\\n      (function (global) {\\n        'use strict';\\n\\n        var random = require('./random');\\n\\n        var onUnload = {},\\n            afterUnload = false\\n        // detect google chrome packaged apps because they don't allow the 'unload' event\\n        ,\\n            isChromePackagedApp = global.chrome && global.chrome.app && global.chrome.app.runtime;\\n\\n        module.exports = {\\n          attachEvent: function (event, listener) {\\n            if (typeof global.addEventListener !== 'undefined') {\\n              global.addEventListener(event, listener, false);\\n            } else if (global.document && global.attachEvent) {\\n              // IE quirks.\\n              // According to: http://stevesouders.com/misc/test-postmessage.php\\n              // the message gets delivered only to 'document', not 'window'.\\n              global.document.attachEvent('on' + event, listener);\\n              // I get 'window' for ie8.\\n              global.attachEvent('on' + event, listener);\\n            }\\n          },\\n\\n          detachEvent: function (event, listener) {\\n            if (typeof global.addEventListener !== 'undefined') {\\n              global.removeEventListener(event, listener, false);\\n            } else if (global.document && global.detachEvent) {\\n              global.document.detachEvent('on' + event, listener);\\n              global.detachEvent('on' + event, listener);\\n            }\\n          },\\n\\n          unloadAdd: function (listener) {\\n            if (isChromePackagedApp) {\\n              return null;\\n            }\\n\\n            var ref = random.string(8);\\n            onUnload[ref] = listener;\\n            if (afterUnload) {\\n              setTimeout(this.triggerUnloadCallbacks, 0);\\n            }\\n            return ref;\\n          },\\n\\n          unloadDel: function (ref) {\\n            if (ref in onUnload) {\\n              delete onUnload[ref];\\n            }\\n          },\\n\\n          triggerUnloadCallbacks: function () {\\n            for (var ref in onUnload) {\\n              onUnload[ref]();\\n              delete onUnload[ref];\\n            }\\n          }\\n        };\\n\\n        var unloadTriggered = function () {\\n          if (afterUnload) {\\n            return;\\n          }\\n          afterUnload = true;\\n          module.exports.triggerUnloadCallbacks();\\n        };\\n\\n        // 'unload' alone is not reliable in opera within an iframe, but we\\n        // can't use `beforeunload` as IE fires it on javascript: links.\\n        if (!isChromePackagedApp) {\\n          module.exports.attachEvent('unload', unloadTriggered);\\n        }\\n      }).call(this, typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {});\\n    }, { \\\"./random\\\": 50 }], 47: [function (require, module, exports) {\\n      (function (process, global) {\\n        'use strict';\\n\\n        var eventUtils = require('./event'),\\n            JSON3 = require('json3'),\\n            browser = require('./browser');\\n\\n        var debug = function () {};\\n        if (process.env.NODE_ENV !== 'production') {\\n          debug = require('debug')('sockjs-client:utils:iframe');\\n        }\\n\\n        module.exports = {\\n          WPrefix: '_jp',\\n          currentWindowId: null,\\n\\n          polluteGlobalNamespace: function () {\\n            if (!(module.exports.WPrefix in global)) {\\n              global[module.exports.WPrefix] = {};\\n            }\\n          },\\n\\n          postMessage: function (type, data) {\\n            if (global.parent !== global) {\\n              global.parent.postMessage(JSON3.stringify({\\n                windowId: module.exports.currentWindowId,\\n                type: type,\\n                data: data || ''\\n              }), '*');\\n            } else {\\n              debug('Cannot postMessage, no parent window.', type, data);\\n            }\\n          },\\n\\n          createIframe: function (iframeUrl, errorCallback) {\\n            var iframe = global.document.createElement('iframe');\\n            var tref, unloadRef;\\n            var unattach = function () {\\n              debug('unattach');\\n              clearTimeout(tref);\\n              // Explorer had problems with that.\\n              try {\\n                iframe.onload = null;\\n              } catch (x) {\\n                // intentionally empty\\n              }\\n              iframe.onerror = null;\\n            };\\n            var cleanup = function () {\\n              debug('cleanup');\\n              if (iframe) {\\n                unattach();\\n                // This timeout makes chrome fire onbeforeunload event\\n                // within iframe. Without the timeout it goes straight to\\n                // onunload.\\n                setTimeout(function () {\\n                  if (iframe) {\\n                    iframe.parentNode.removeChild(iframe);\\n                  }\\n                  iframe = null;\\n                }, 0);\\n                eventUtils.unloadDel(unloadRef);\\n              }\\n            };\\n            var onerror = function (err) {\\n              debug('onerror', err);\\n              if (iframe) {\\n                cleanup();\\n                errorCallback(err);\\n              }\\n            };\\n            var post = function (msg, origin) {\\n              debug('post', msg, origin);\\n              setTimeout(function () {\\n                try {\\n                  // When the iframe is not loaded, IE raises an exception\\n                  // on 'contentWindow'.\\n                  if (iframe && iframe.contentWindow) {\\n                    iframe.contentWindow.postMessage(msg, origin);\\n                  }\\n                } catch (x) {\\n                  // intentionally empty\\n                }\\n              }, 0);\\n            };\\n\\n            iframe.src = iframeUrl;\\n            iframe.style.display = 'none';\\n            iframe.style.position = 'absolute';\\n            iframe.onerror = function () {\\n              onerror('onerror');\\n            };\\n            iframe.onload = function () {\\n              debug('onload');\\n              // `onload` is triggered before scripts on the iframe are\\n              // executed. Give it few seconds to actually load stuff.\\n              clearTimeout(tref);\\n              tref = setTimeout(function () {\\n                onerror('onload timeout');\\n              }, 2000);\\n            };\\n            global.document.body.appendChild(iframe);\\n            tref = setTimeout(function () {\\n              onerror('timeout');\\n            }, 15000);\\n            unloadRef = eventUtils.unloadAdd(cleanup);\\n            return {\\n              post: post,\\n              cleanup: cleanup,\\n              loaded: unattach\\n            };\\n          }\\n\\n          /* eslint no-undef: \\\"off\\\", new-cap: \\\"off\\\" */\\n          , createHtmlfile: function (iframeUrl, errorCallback) {\\n            var axo = ['Active'].concat('Object').join('X');\\n            var doc = new global[axo]('htmlfile');\\n            var tref, unloadRef;\\n            var iframe;\\n            var unattach = function () {\\n              clearTimeout(tref);\\n              iframe.onerror = null;\\n            };\\n            var cleanup = function () {\\n              if (doc) {\\n                unattach();\\n                eventUtils.unloadDel(unloadRef);\\n                iframe.parentNode.removeChild(iframe);\\n                iframe = doc = null;\\n                CollectGarbage();\\n              }\\n            };\\n            var onerror = function (r) {\\n              debug('onerror', r);\\n              if (doc) {\\n                cleanup();\\n                errorCallback(r);\\n              }\\n            };\\n            var post = function (msg, origin) {\\n              try {\\n                // When the iframe is not loaded, IE raises an exception\\n                // on 'contentWindow'.\\n                setTimeout(function () {\\n                  if (iframe && iframe.contentWindow) {\\n                    iframe.contentWindow.postMessage(msg, origin);\\n                  }\\n                }, 0);\\n              } catch (x) {\\n                // intentionally empty\\n              }\\n            };\\n\\n            doc.open();\\n            doc.write('<html><s' + 'cript>' + 'document.domain=\\\"' + global.document.domain + '\\\";' + '</s' + 'cript></html>');\\n            doc.close();\\n            doc.parentWindow[module.exports.WPrefix] = global[module.exports.WPrefix];\\n            var c = doc.createElement('div');\\n            doc.body.appendChild(c);\\n            iframe = doc.createElement('iframe');\\n            c.appendChild(iframe);\\n            iframe.src = iframeUrl;\\n            iframe.onerror = function () {\\n              onerror('onerror');\\n            };\\n            tref = setTimeout(function () {\\n              onerror('timeout');\\n            }, 15000);\\n            unloadRef = eventUtils.unloadAdd(cleanup);\\n            return {\\n              post: post,\\n              cleanup: cleanup,\\n              loaded: unattach\\n            };\\n          }\\n        };\\n\\n        module.exports.iframeEnabled = false;\\n        if (global.document) {\\n          // postMessage misbehaves in konqueror 4.6.5 - the messages are delivered with\\n          // huge delay, or not at all.\\n          module.exports.iframeEnabled = (typeof global.postMessage === 'function' || typeof global.postMessage === 'object') && !browser.isKonqueror();\\n        }\\n      }).call(this, { env: {} }, typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {});\\n    }, { \\\"./browser\\\": 44, \\\"./event\\\": 46, \\\"debug\\\": 54, \\\"json3\\\": 57 }], 48: [function (require, module, exports) {\\n      (function (global) {\\n        'use strict';\\n\\n        var logObject = {};\\n        ['log', 'debug', 'warn'].forEach(function (level) {\\n          var levelExists;\\n\\n          try {\\n            levelExists = global.console && global.console[level] && global.console[level].apply;\\n          } catch (e) {\\n            // do nothing\\n          }\\n\\n          logObject[level] = levelExists ? function () {\\n            return global.console[level].apply(global.console, arguments);\\n          } : level === 'log' ? function () {} : logObject.log;\\n        });\\n\\n        module.exports = logObject;\\n      }).call(this, typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {});\\n    }, {}], 49: [function (require, module, exports) {\\n      'use strict';\\n\\n      module.exports = {\\n        isObject: function (obj) {\\n          var type = typeof obj;\\n          return type === 'function' || type === 'object' && !!obj;\\n        },\\n\\n        extend: function (obj) {\\n          if (!this.isObject(obj)) {\\n            return obj;\\n          }\\n          var source, prop;\\n          for (var i = 1, length = arguments.length; i < length; i++) {\\n            source = arguments[i];\\n            for (prop in source) {\\n              if (Object.prototype.hasOwnProperty.call(source, prop)) {\\n                obj[prop] = source[prop];\\n              }\\n            }\\n          }\\n          return obj;\\n        }\\n      };\\n    }, {}], 50: [function (require, module, exports) {\\n      'use strict';\\n\\n      /* global crypto:true */\\n\\n      var crypto = require('crypto');\\n\\n      // This string has length 32, a power of 2, so the modulus doesn't introduce a\\n      // bias.\\n      var _randomStringChars = 'abcdefghijklmnopqrstuvwxyz012345';\\n      module.exports = {\\n        string: function (length) {\\n          var max = _randomStringChars.length;\\n          var bytes = crypto.randomBytes(length);\\n          var ret = [];\\n          for (var i = 0; i < length; i++) {\\n            ret.push(_randomStringChars.substr(bytes[i] % max, 1));\\n          }\\n          return ret.join('');\\n        },\\n\\n        number: function (max) {\\n          return Math.floor(Math.random() * max);\\n        },\\n\\n        numberString: function (max) {\\n          var t = ('' + (max - 1)).length;\\n          var p = new Array(t + 1).join('0');\\n          return (p + this.number(max)).slice(-t);\\n        }\\n      };\\n    }, { \\\"crypto\\\": 43 }], 51: [function (require, module, exports) {\\n      (function (process) {\\n        'use strict';\\n\\n        var debug = function () {};\\n        if (process.env.NODE_ENV !== 'production') {\\n          debug = require('debug')('sockjs-client:utils:transport');\\n        }\\n\\n        module.exports = function (availableTransports) {\\n          return {\\n            filterToEnabled: function (transportsWhitelist, info) {\\n              var transports = {\\n                main: [],\\n                facade: []\\n              };\\n              if (!transportsWhitelist) {\\n                transportsWhitelist = [];\\n              } else if (typeof transportsWhitelist === 'string') {\\n                transportsWhitelist = [transportsWhitelist];\\n              }\\n\\n              availableTransports.forEach(function (trans) {\\n                if (!trans) {\\n                  return;\\n                }\\n\\n                if (trans.transportName === 'websocket' && info.websocket === false) {\\n                  debug('disabled from server', 'websocket');\\n                  return;\\n                }\\n\\n                if (transportsWhitelist.length && transportsWhitelist.indexOf(trans.transportName) === -1) {\\n                  debug('not in whitelist', trans.transportName);\\n                  return;\\n                }\\n\\n                if (trans.enabled(info)) {\\n                  debug('enabled', trans.transportName);\\n                  transports.main.push(trans);\\n                  if (trans.facadeTransport) {\\n                    transports.facade.push(trans.facadeTransport);\\n                  }\\n                } else {\\n                  debug('disabled', trans.transportName);\\n                }\\n              });\\n              return transports;\\n            }\\n          };\\n        };\\n      }).call(this, { env: {} });\\n    }, { \\\"debug\\\": 54 }], 52: [function (require, module, exports) {\\n      (function (process) {\\n        'use strict';\\n\\n        var URL = require('url-parse');\\n\\n        var debug = function () {};\\n        if (process.env.NODE_ENV !== 'production') {\\n          debug = require('debug')('sockjs-client:utils:url');\\n        }\\n\\n        module.exports = {\\n          getOrigin: function (url) {\\n            if (!url) {\\n              return null;\\n            }\\n\\n            var p = new URL(url);\\n            if (p.protocol === 'file:') {\\n              return null;\\n            }\\n\\n            var port = p.port;\\n            if (!port) {\\n              port = p.protocol === 'https:' ? '443' : '80';\\n            }\\n\\n            return p.protocol + '//' + p.hostname + ':' + port;\\n          },\\n\\n          isOriginEqual: function (a, b) {\\n            var res = this.getOrigin(a) === this.getOrigin(b);\\n            debug('same', a, b, res);\\n            return res;\\n          },\\n\\n          isSchemeEqual: function (a, b) {\\n            return a.split(':')[0] === b.split(':')[0];\\n          },\\n\\n          addPath: function (url, path) {\\n            var qs = url.split('?');\\n            return qs[0] + path + (qs[1] ? '?' + qs[1] : '');\\n          },\\n\\n          addQuery: function (url, q) {\\n            return url + (url.indexOf('?') === -1 ? '?' + q : '&' + q);\\n          }\\n        };\\n      }).call(this, { env: {} });\\n    }, { \\\"debug\\\": 54, \\\"url-parse\\\": 61 }], 53: [function (require, module, exports) {\\n      module.exports = '1.1.5';\\n    }, {}], 54: [function (require, module, exports) {\\n      (function (process) {\\n        /**\\r\\n         * This is the web browser implementation of `debug()`.\\r\\n         *\\r\\n         * Expose `debug()` as the module.\\r\\n         */\\n\\n        exports = module.exports = require('./debug');\\n        exports.log = log;\\n        exports.formatArgs = formatArgs;\\n        exports.save = save;\\n        exports.load = load;\\n        exports.useColors = useColors;\\n        exports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();\\n\\n        /**\\r\\n         * Colors.\\r\\n         */\\n\\n        exports.colors = ['lightseagreen', 'forestgreen', 'goldenrod', 'dodgerblue', 'darkorchid', 'crimson'];\\n\\n        /**\\r\\n         * Currently only WebKit-based Web Inspectors, Firefox >= v31,\\r\\n         * and the Firebug extension (any Firefox version) are known\\r\\n         * to support \\\"%c\\\" CSS customizations.\\r\\n         *\\r\\n         * TODO: add a `localStorage` variable to explicitly enable/disable colors\\r\\n         */\\n\\n        function useColors() {\\n          // NB: In an Electron preload script, document will be defined but not fully\\n          // initialized. Since we know we're in Chrome, we'll just detect this case\\n          // explicitly\\n          if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\\n            return true;\\n          }\\n\\n          // is webkit? http://stackoverflow.com/a/16459606/376773\\n          // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\\n          return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance ||\\n          // is firebug? http://stackoverflow.com/a/398120/376773\\n          typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) ||\\n          // is firefox >= v31?\\n          // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\\n          typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\\\/(\\\\d+)/) && parseInt(RegExp.$1, 10) >= 31 ||\\n          // double check webkit in userAgent just in case we are in a worker\\n          typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\\\/(\\\\d+)/);\\n        }\\n\\n        /**\\r\\n         * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\\r\\n         */\\n\\n        exports.formatters.j = function (v) {\\n          try {\\n            return JSON.stringify(v);\\n          } catch (err) {\\n            return '[UnexpectedJSONParseError]: ' + err.message;\\n          }\\n        };\\n\\n        /**\\r\\n         * Colorize log arguments if enabled.\\r\\n         *\\r\\n         * @api public\\r\\n         */\\n\\n        function formatArgs(args) {\\n          var useColors = this.useColors;\\n\\n          args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);\\n\\n          if (!useColors) return;\\n\\n          var c = 'color: ' + this.color;\\n          args.splice(1, 0, c, 'color: inherit');\\n\\n          // the final \\\"%c\\\" is somewhat tricky, because there could be other\\n          // arguments passed either before or after the %c, so we need to\\n          // figure out the correct index to insert the CSS into\\n          var index = 0;\\n          var lastC = 0;\\n          args[0].replace(/%[a-zA-Z%]/g, function (match) {\\n            if ('%%' === match) return;\\n            index++;\\n            if ('%c' === match) {\\n              // we only are interested in the *last* %c\\n              // (the user may have provided their own)\\n              lastC = index;\\n            }\\n          });\\n\\n          args.splice(lastC, 0, c);\\n        }\\n\\n        /**\\r\\n         * Invokes `console.log()` when available.\\r\\n         * No-op when `console.log` is not a \\\"function\\\".\\r\\n         *\\r\\n         * @api public\\r\\n         */\\n\\n        function log() {\\n          // this hackery is required for IE8/9, where\\n          // the `console.log` function doesn't have 'apply'\\n          return 'object' === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);\\n        }\\n\\n        /**\\r\\n         * Save `namespaces`.\\r\\n         *\\r\\n         * @param {String} namespaces\\r\\n         * @api private\\r\\n         */\\n\\n        function save(namespaces) {\\n          try {\\n            if (null == namespaces) {\\n              exports.storage.removeItem('debug');\\n            } else {\\n              exports.storage.debug = namespaces;\\n            }\\n          } catch (e) {}\\n        }\\n\\n        /**\\r\\n         * Load `namespaces`.\\r\\n         *\\r\\n         * @return {String} returns the previously persisted debug modes\\r\\n         * @api private\\r\\n         */\\n\\n        function load() {\\n          var r;\\n          try {\\n            r = exports.storage.debug;\\n          } catch (e) {}\\n\\n          // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\\n          if (!r && typeof process !== 'undefined' && 'env' in process) {\\n            r = process.env.DEBUG;\\n          }\\n\\n          return r;\\n        }\\n\\n        /**\\r\\n         * Enable namespaces listed in `localStorage.debug` initially.\\r\\n         */\\n\\n        exports.enable(load());\\n\\n        /**\\r\\n         * Localstorage attempts to return the localstorage.\\r\\n         *\\r\\n         * This is necessary because safari throws\\r\\n         * when a user disables cookies/localstorage\\r\\n         * and you attempt to access it.\\r\\n         *\\r\\n         * @return {LocalStorage}\\r\\n         * @api private\\r\\n         */\\n\\n        function localstorage() {\\n          try {\\n            return window.localStorage;\\n          } catch (e) {}\\n        }\\n      }).call(this, { env: {} });\\n    }, { \\\"./debug\\\": 55 }], 55: [function (require, module, exports) {\\n\\n      /**\\r\\n       * This is the common logic for both the Node.js and web browser\\r\\n       * implementations of `debug()`.\\r\\n       *\\r\\n       * Expose `debug()` as the module.\\r\\n       */\\n\\n      exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\\n      exports.coerce = coerce;\\n      exports.disable = disable;\\n      exports.enable = enable;\\n      exports.enabled = enabled;\\n      exports.humanize = require('ms');\\n\\n      /**\\r\\n       * The currently active debug mode names, and names to skip.\\r\\n       */\\n\\n      exports.names = [];\\n      exports.skips = [];\\n\\n      /**\\r\\n       * Map of special \\\"%n\\\" handling functions, for the debug \\\"format\\\" argument.\\r\\n       *\\r\\n       * Valid key names are a single, lower or upper-case letter, i.e. \\\"n\\\" and \\\"N\\\".\\r\\n       */\\n\\n      exports.formatters = {};\\n\\n      /**\\r\\n       * Previous log timestamp.\\r\\n       */\\n\\n      var prevTime;\\n\\n      /**\\r\\n       * Select a color.\\r\\n       * @param {String} namespace\\r\\n       * @return {Number}\\r\\n       * @api private\\r\\n       */\\n\\n      function selectColor(namespace) {\\n        var hash = 0,\\n            i;\\n\\n        for (i in namespace) {\\n          hash = (hash << 5) - hash + namespace.charCodeAt(i);\\n          hash |= 0; // Convert to 32bit integer\\n        }\\n\\n        return exports.colors[Math.abs(hash) % exports.colors.length];\\n      }\\n\\n      /**\\r\\n       * Create a debugger with the given `namespace`.\\r\\n       *\\r\\n       * @param {String} namespace\\r\\n       * @return {Function}\\r\\n       * @api public\\r\\n       */\\n\\n      function createDebug(namespace) {\\n\\n        function debug() {\\n          // disabled?\\n          if (!debug.enabled) return;\\n\\n          var self = debug;\\n\\n          // set `diff` timestamp\\n          var curr = +new Date();\\n          var ms = curr - (prevTime || curr);\\n          self.diff = ms;\\n          self.prev = prevTime;\\n          self.curr = curr;\\n          prevTime = curr;\\n\\n          // turn the `arguments` into a proper Array\\n          var args = new Array(arguments.length);\\n          for (var i = 0; i < args.length; i++) {\\n            args[i] = arguments[i];\\n          }\\n\\n          args[0] = exports.coerce(args[0]);\\n\\n          if ('string' !== typeof args[0]) {\\n            // anything else let's inspect with %O\\n            args.unshift('%O');\\n          }\\n\\n          // apply any `formatters` transformations\\n          var index = 0;\\n          args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {\\n            // if we encounter an escaped % then don't increase the array index\\n            if (match === '%%') return match;\\n            index++;\\n            var formatter = exports.formatters[format];\\n            if ('function' === typeof formatter) {\\n              var val = args[index];\\n              match = formatter.call(self, val);\\n\\n              // now we need to remove `args[index]` since it's inlined in the `format`\\n              args.splice(index, 1);\\n              index--;\\n            }\\n            return match;\\n          });\\n\\n          // apply env-specific formatting (colors, etc.)\\n          exports.formatArgs.call(self, args);\\n\\n          var logFn = debug.log || exports.log || console.log.bind(console);\\n          logFn.apply(self, args);\\n        }\\n\\n        debug.namespace = namespace;\\n        debug.enabled = exports.enabled(namespace);\\n        debug.useColors = exports.useColors();\\n        debug.color = selectColor(namespace);\\n\\n        // env-specific initialization logic for debug instances\\n        if ('function' === typeof exports.init) {\\n          exports.init(debug);\\n        }\\n\\n        return debug;\\n      }\\n\\n      /**\\r\\n       * Enables a debug mode by namespaces. This can include modes\\r\\n       * separated by a colon and wildcards.\\r\\n       *\\r\\n       * @param {String} namespaces\\r\\n       * @api public\\r\\n       */\\n\\n      function enable(namespaces) {\\n        exports.save(namespaces);\\n\\n        exports.names = [];\\n        exports.skips = [];\\n\\n        var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\\\s,]+/);\\n        var len = split.length;\\n\\n        for (var i = 0; i < len; i++) {\\n          if (!split[i]) continue; // ignore empty strings\\n          namespaces = split[i].replace(/\\\\*/g, '.*?');\\n          if (namespaces[0] === '-') {\\n            exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\\n          } else {\\n            exports.names.push(new RegExp('^' + namespaces + '$'));\\n          }\\n        }\\n      }\\n\\n      /**\\r\\n       * Disable debug output.\\r\\n       *\\r\\n       * @api public\\r\\n       */\\n\\n      function disable() {\\n        exports.enable('');\\n      }\\n\\n      /**\\r\\n       * Returns true if the given mode name is enabled, false otherwise.\\r\\n       *\\r\\n       * @param {String} name\\r\\n       * @return {Boolean}\\r\\n       * @api public\\r\\n       */\\n\\n      function enabled(name) {\\n        var i, len;\\n        for (i = 0, len = exports.skips.length; i < len; i++) {\\n          if (exports.skips[i].test(name)) {\\n            return false;\\n          }\\n        }\\n        for (i = 0, len = exports.names.length; i < len; i++) {\\n          if (exports.names[i].test(name)) {\\n            return true;\\n          }\\n        }\\n        return false;\\n      }\\n\\n      /**\\r\\n       * Coerce `val`.\\r\\n       *\\r\\n       * @param {Mixed} val\\r\\n       * @return {Mixed}\\r\\n       * @api private\\r\\n       */\\n\\n      function coerce(val) {\\n        if (val instanceof Error) return val.stack || val.message;\\n        return val;\\n      }\\n    }, { \\\"ms\\\": 58 }], 56: [function (require, module, exports) {\\n      if (typeof Object.create === 'function') {\\n        // implementation from standard node.js 'util' module\\n        module.exports = function inherits(ctor, superCtor) {\\n          ctor.super_ = superCtor;\\n          ctor.prototype = Object.create(superCtor.prototype, {\\n            constructor: {\\n              value: ctor,\\n              enumerable: false,\\n              writable: true,\\n              configurable: true\\n            }\\n          });\\n        };\\n      } else {\\n        // old school shim for old browsers\\n        module.exports = function inherits(ctor, superCtor) {\\n          ctor.super_ = superCtor;\\n          var TempCtor = function () {};\\n          TempCtor.prototype = superCtor.prototype;\\n          ctor.prototype = new TempCtor();\\n          ctor.prototype.constructor = ctor;\\n        };\\n      }\\n    }, {}], 57: [function (require, module, exports) {\\n      (function (global) {\\n        /*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */\\n        ;(function () {\\n          // Detect the `define` function exposed by asynchronous module loaders. The\\n          // strict `define` check is necessary for compatibility with `r.js`.\\n          var isLoader = typeof define === \\\"function\\\" && define.amd;\\n\\n          // A set of types used to distinguish objects from primitives.\\n          var objectTypes = {\\n            \\\"function\\\": true,\\n            \\\"object\\\": true\\n          };\\n\\n          // Detect the `exports` object exposed by CommonJS implementations.\\n          var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;\\n\\n          // Use the `global` object exposed by Node (including Browserify via\\n          // `insert-module-globals`), Narwhal, and Ringo as the default context,\\n          // and the `window` object in browsers. Rhino exports a `global` function\\n          // instead.\\n          var root = objectTypes[typeof window] && window || this,\\n              freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == \\\"object\\\" && global;\\n\\n          if (freeGlobal && (freeGlobal[\\\"global\\\"] === freeGlobal || freeGlobal[\\\"window\\\"] === freeGlobal || freeGlobal[\\\"self\\\"] === freeGlobal)) {\\n            root = freeGlobal;\\n          }\\n\\n          // Public: Initializes JSON 3 using the given `context` object, attaching the\\n          // `stringify` and `parse` functions to the specified `exports` object.\\n          function runInContext(context, exports) {\\n            context || (context = root[\\\"Object\\\"]());\\n            exports || (exports = root[\\\"Object\\\"]());\\n\\n            // Native constructor aliases.\\n            var Number = context[\\\"Number\\\"] || root[\\\"Number\\\"],\\n                String = context[\\\"String\\\"] || root[\\\"String\\\"],\\n                Object = context[\\\"Object\\\"] || root[\\\"Object\\\"],\\n                Date = context[\\\"Date\\\"] || root[\\\"Date\\\"],\\n                SyntaxError = context[\\\"SyntaxError\\\"] || root[\\\"SyntaxError\\\"],\\n                TypeError = context[\\\"TypeError\\\"] || root[\\\"TypeError\\\"],\\n                Math = context[\\\"Math\\\"] || root[\\\"Math\\\"],\\n                nativeJSON = context[\\\"JSON\\\"] || root[\\\"JSON\\\"];\\n\\n            // Delegate to the native `stringify` and `parse` implementations.\\n            if (typeof nativeJSON == \\\"object\\\" && nativeJSON) {\\n              exports.stringify = nativeJSON.stringify;\\n              exports.parse = nativeJSON.parse;\\n            }\\n\\n            // Convenience aliases.\\n            var objectProto = Object.prototype,\\n                getClass = objectProto.toString,\\n                isProperty,\\n                forEach,\\n                undef;\\n\\n            // Test the `Date#getUTC*` methods. Based on work by @Yaffle.\\n            var isExtended = new Date(-3509827334573292);\\n            try {\\n              // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical\\n              // results for certain dates in Opera >= 10.53.\\n              isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&\\n              // Safari < 2.0.2 stores the internal millisecond time value correctly,\\n              // but clips the values returned by the date methods to the range of\\n              // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).\\n              isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;\\n            } catch (exception) {}\\n\\n            // Internal: Determines whether the native `JSON.stringify` and `parse`\\n            // implementations are spec-compliant. Based on work by Ken Snyder.\\n            function has(name) {\\n              if (has[name] !== undef) {\\n                // Return cached feature test result.\\n                return has[name];\\n              }\\n              var isSupported;\\n              if (name == \\\"bug-string-char-index\\\") {\\n                // IE <= 7 doesn't support accessing string characters using square\\n                // bracket notation. IE 8 only supports this for primitives.\\n                isSupported = \\\"a\\\"[0] != \\\"a\\\";\\n              } else if (name == \\\"json\\\") {\\n                // Indicates whether both `JSON.stringify` and `JSON.parse` are\\n                // supported.\\n                isSupported = has(\\\"json-stringify\\\") && has(\\\"json-parse\\\");\\n              } else {\\n                var value,\\n                    serialized = '{\\\"a\\\":[1,true,false,null,\\\"\\\\\\\\u0000\\\\\\\\b\\\\\\\\n\\\\\\\\f\\\\\\\\r\\\\\\\\t\\\"]}';\\n                // Test `JSON.stringify`.\\n                if (name == \\\"json-stringify\\\") {\\n                  var stringify = exports.stringify,\\n                      stringifySupported = typeof stringify == \\\"function\\\" && isExtended;\\n                  if (stringifySupported) {\\n                    // A test function object with a custom `toJSON` method.\\n                    (value = function () {\\n                      return 1;\\n                    }).toJSON = value;\\n                    try {\\n                      stringifySupported =\\n                      // Firefox 3.1b1 and b2 serialize string, number, and boolean\\n                      // primitives as object literals.\\n                      stringify(0) === \\\"0\\\" &&\\n                      // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object\\n                      // literals.\\n                      stringify(new Number()) === \\\"0\\\" && stringify(new String()) == '\\\"\\\"' &&\\n                      // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or\\n                      // does not define a canonical JSON representation (this applies to\\n                      // objects with `toJSON` properties as well, *unless* they are nested\\n                      // within an object or array).\\n                      stringify(getClass) === undef &&\\n                      // IE 8 serializes `undefined` as `\\\"undefined\\\"`. Safari <= 5.1.7 and\\n                      // FF 3.1b3 pass this test.\\n                      stringify(undef) === undef &&\\n                      // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,\\n                      // respectively, if the value is omitted entirely.\\n                      stringify() === undef &&\\n                      // FF 3.1b1, 2 throw an error if the given value is not a number,\\n                      // string, array, object, Boolean, or `null` literal. This applies to\\n                      // objects with custom `toJSON` methods as well, unless they are nested\\n                      // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`\\n                      // methods entirely.\\n                      stringify(value) === \\\"1\\\" && stringify([value]) == \\\"[1]\\\" &&\\n                      // Prototype <= 1.6.1 serializes `[undefined]` as `\\\"[]\\\"` instead of\\n                      // `\\\"[null]\\\"`.\\n                      stringify([undef]) == \\\"[null]\\\" &&\\n                      // YUI 3.0.0b1 fails to serialize `null` literals.\\n                      stringify(null) == \\\"null\\\" &&\\n                      // FF 3.1b1, 2 halts serialization if an array contains a function:\\n                      // `[1, true, getClass, 1]` serializes as \\\"[1,true,],\\\". FF 3.1b3\\n                      // elides non-JSON values from objects and arrays, unless they\\n                      // define custom `toJSON` methods.\\n                      stringify([undef, getClass, null]) == \\\"[null,null,null]\\\" &&\\n                      // Simple serialization test. FF 3.1b1 uses Unicode escape sequences\\n                      // where character escape codes are expected (e.g., `\\\\b` => `\\\\u0008`).\\n                      stringify({ \\\"a\\\": [value, true, false, null, \\\"\\\\x00\\\\b\\\\n\\\\f\\\\r\\\\t\\\"] }) == serialized &&\\n                      // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.\\n                      stringify(null, value) === \\\"1\\\" && stringify([1, 2], null, 1) == \\\"[\\\\n 1,\\\\n 2\\\\n]\\\" &&\\n                      // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly\\n                      // serialize extended years.\\n                      stringify(new Date(-8.64e15)) == '\\\"-271821-04-20T00:00:00.000Z\\\"' &&\\n                      // The milliseconds are optional in ES 5, but required in 5.1.\\n                      stringify(new Date(8.64e15)) == '\\\"+275760-09-13T00:00:00.000Z\\\"' &&\\n                      // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative\\n                      // four-digit years instead of six-digit years. Credits: @Yaffle.\\n                      stringify(new Date(-621987552e5)) == '\\\"-000001-01-01T00:00:00.000Z\\\"' &&\\n                      // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond\\n                      // values less than 1000. Credits: @Yaffle.\\n                      stringify(new Date(-1)) == '\\\"1969-12-31T23:59:59.999Z\\\"';\\n                    } catch (exception) {\\n                      stringifySupported = false;\\n                    }\\n                  }\\n                  isSupported = stringifySupported;\\n                }\\n                // Test `JSON.parse`.\\n                if (name == \\\"json-parse\\\") {\\n                  var parse = exports.parse;\\n                  if (typeof parse == \\\"function\\\") {\\n                    try {\\n                      // FF 3.1b1, b2 will throw an exception if a bare literal is provided.\\n                      // Conforming implementations should also coerce the initial argument to\\n                      // a string prior to parsing.\\n                      if (parse(\\\"0\\\") === 0 && !parse(false)) {\\n                        // Simple parsing test.\\n                        value = parse(serialized);\\n                        var parseSupported = value[\\\"a\\\"].length == 5 && value[\\\"a\\\"][0] === 1;\\n                        if (parseSupported) {\\n                          try {\\n                            // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.\\n                            parseSupported = !parse('\\\"\\\\t\\\"');\\n                          } catch (exception) {}\\n                          if (parseSupported) {\\n                            try {\\n                              // FF 4.0 and 4.0.1 allow leading `+` signs and leading\\n                              // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow\\n                              // certain octal literals.\\n                              parseSupported = parse(\\\"01\\\") !== 1;\\n                            } catch (exception) {}\\n                          }\\n                          if (parseSupported) {\\n                            try {\\n                              // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal\\n                              // points. These environments, along with FF 3.1b1 and 2,\\n                              // also allow trailing commas in JSON objects and arrays.\\n                              parseSupported = parse(\\\"1.\\\") !== 1;\\n                            } catch (exception) {}\\n                          }\\n                        }\\n                      }\\n                    } catch (exception) {\\n                      parseSupported = false;\\n                    }\\n                  }\\n                  isSupported = parseSupported;\\n                }\\n              }\\n              return has[name] = !!isSupported;\\n            }\\n\\n            if (!has(\\\"json\\\")) {\\n              // Common `[[Class]]` name aliases.\\n              var functionClass = \\\"[object Function]\\\",\\n                  dateClass = \\\"[object Date]\\\",\\n                  numberClass = \\\"[object Number]\\\",\\n                  stringClass = \\\"[object String]\\\",\\n                  arrayClass = \\\"[object Array]\\\",\\n                  booleanClass = \\\"[object Boolean]\\\";\\n\\n              // Detect incomplete support for accessing string characters by index.\\n              var charIndexBuggy = has(\\\"bug-string-char-index\\\");\\n\\n              // Define additional utility methods if the `Date` methods are buggy.\\n              if (!isExtended) {\\n                var floor = Math.floor;\\n                // A mapping between the months of the year and the number of days between\\n                // January 1st and the first of the respective month.\\n                var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];\\n                // Internal: Calculates the number of days between the Unix epoch and the\\n                // first day of the given month.\\n                var getDay = function (year, month) {\\n                  return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);\\n                };\\n              }\\n\\n              // Internal: Determines if a property is a direct property of the given\\n              // object. Delegates to the native `Object#hasOwnProperty` method.\\n              if (!(isProperty = objectProto.hasOwnProperty)) {\\n                isProperty = function (property) {\\n                  var members = {},\\n                      constructor;\\n                  if ((members.__proto__ = null, members.__proto__ = {\\n                    // The *proto* property cannot be set multiple times in recent\\n                    // versions of Firefox and SeaMonkey.\\n                    \\\"toString\\\": 1\\n                  }, members).toString != getClass) {\\n                    // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but\\n                    // supports the mutable *proto* property.\\n                    isProperty = function (property) {\\n                      // Capture and break the object's prototype chain (see section 8.6.2\\n                      // of the ES 5.1 spec). The parenthesized expression prevents an\\n                      // unsafe transformation by the Closure Compiler.\\n                      var original = this.__proto__,\\n                          result = property in (this.__proto__ = null, this);\\n                      // Restore the original prototype chain.\\n                      this.__proto__ = original;\\n                      return result;\\n                    };\\n                  } else {\\n                    // Capture a reference to the top-level `Object` constructor.\\n                    constructor = members.constructor;\\n                    // Use the `constructor` property to simulate `Object#hasOwnProperty` in\\n                    // other environments.\\n                    isProperty = function (property) {\\n                      var parent = (this.constructor || constructor).prototype;\\n                      return property in this && !(property in parent && this[property] === parent[property]);\\n                    };\\n                  }\\n                  members = null;\\n                  return isProperty.call(this, property);\\n                };\\n              }\\n\\n              // Internal: Normalizes the `for...in` iteration algorithm across\\n              // environments. Each enumerated key is yielded to a `callback` function.\\n              forEach = function (object, callback) {\\n                var size = 0,\\n                    Properties,\\n                    members,\\n                    property;\\n\\n                // Tests for bugs in the current environment's `for...in` algorithm. The\\n                // `valueOf` property inherits the non-enumerable flag from\\n                // `Object.prototype` in older versions of IE, Netscape, and Mozilla.\\n                (Properties = function () {\\n                  this.valueOf = 0;\\n                }).prototype.valueOf = 0;\\n\\n                // Iterate over a new instance of the `Properties` class.\\n                members = new Properties();\\n                for (property in members) {\\n                  // Ignore all properties inherited from `Object.prototype`.\\n                  if (isProperty.call(members, property)) {\\n                    size++;\\n                  }\\n                }\\n                Properties = members = null;\\n\\n                // Normalize the iteration algorithm.\\n                if (!size) {\\n                  // A list of non-enumerable properties inherited from `Object.prototype`.\\n                  members = [\\\"valueOf\\\", \\\"toString\\\", \\\"toLocaleString\\\", \\\"propertyIsEnumerable\\\", \\\"isPrototypeOf\\\", \\\"hasOwnProperty\\\", \\\"constructor\\\"];\\n                  // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable\\n                  // properties.\\n                  forEach = function (object, callback) {\\n                    var isFunction = getClass.call(object) == functionClass,\\n                        property,\\n                        length;\\n                    var hasProperty = !isFunction && typeof object.constructor != \\\"function\\\" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;\\n                    for (property in object) {\\n                      // Gecko <= 1.0 enumerates the `prototype` property of functions under\\n                      // certain conditions; IE does not.\\n                      if (!(isFunction && property == \\\"prototype\\\") && hasProperty.call(object, property)) {\\n                        callback(property);\\n                      }\\n                    }\\n                    // Manually invoke the callback for each non-enumerable property.\\n                    for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));\\n                  };\\n                } else if (size == 2) {\\n                  // Safari <= 2.0.4 enumerates shadowed properties twice.\\n                  forEach = function (object, callback) {\\n                    // Create a set of iterated properties.\\n                    var members = {},\\n                        isFunction = getClass.call(object) == functionClass,\\n                        property;\\n                    for (property in object) {\\n                      // Store each property name to prevent double enumeration. The\\n                      // `prototype` property of functions is not enumerated due to cross-\\n                      // environment inconsistencies.\\n                      if (!(isFunction && property == \\\"prototype\\\") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {\\n                        callback(property);\\n                      }\\n                    }\\n                  };\\n                } else {\\n                  // No bugs detected; use the standard `for...in` algorithm.\\n                  forEach = function (object, callback) {\\n                    var isFunction = getClass.call(object) == functionClass,\\n                        property,\\n                        isConstructor;\\n                    for (property in object) {\\n                      if (!(isFunction && property == \\\"prototype\\\") && isProperty.call(object, property) && !(isConstructor = property === \\\"constructor\\\")) {\\n                        callback(property);\\n                      }\\n                    }\\n                    // Manually invoke the callback for the `constructor` property due to\\n                    // cross-environment inconsistencies.\\n                    if (isConstructor || isProperty.call(object, property = \\\"constructor\\\")) {\\n                      callback(property);\\n                    }\\n                  };\\n                }\\n                return forEach(object, callback);\\n              };\\n\\n              // Public: Serializes a JavaScript `value` as a JSON string. The optional\\n              // `filter` argument may specify either a function that alters how object and\\n              // array members are serialized, or an array of strings and numbers that\\n              // indicates which properties should be serialized. The optional `width`\\n              // argument may be either a string or number that specifies the indentation\\n              // level of the output.\\n              if (!has(\\\"json-stringify\\\")) {\\n                // Internal: A map of control characters and their escaped equivalents.\\n                var Escapes = {\\n                  92: \\\"\\\\\\\\\\\\\\\\\\\",\\n                  34: '\\\\\\\\\\\"',\\n                  8: \\\"\\\\\\\\b\\\",\\n                  12: \\\"\\\\\\\\f\\\",\\n                  10: \\\"\\\\\\\\n\\\",\\n                  13: \\\"\\\\\\\\r\\\",\\n                  9: \\\"\\\\\\\\t\\\"\\n                };\\n\\n                // Internal: Converts `value` into a zero-padded string such that its\\n                // length is at least equal to `width`. The `width` must be <= 6.\\n                var leadingZeroes = \\\"000000\\\";\\n                var toPaddedString = function (width, value) {\\n                  // The `|| 0` expression is necessary to work around a bug in\\n                  // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== \\\"0\\\"`.\\n                  return (leadingZeroes + (value || 0)).slice(-width);\\n                };\\n\\n                // Internal: Double-quotes a string `value`, replacing all ASCII control\\n                // characters (characters with code unit values between 0 and 31) with\\n                // their escaped equivalents. This is an implementation of the\\n                // `Quote(value)` operation defined in ES 5.1 section 15.12.3.\\n                var unicodePrefix = \\\"\\\\\\\\u00\\\";\\n                var quote = function (value) {\\n                  var result = '\\\"',\\n                      index = 0,\\n                      length = value.length,\\n                      useCharIndex = !charIndexBuggy || length > 10;\\n                  var symbols = useCharIndex && (charIndexBuggy ? value.split(\\\"\\\") : value);\\n                  for (; index < length; index++) {\\n                    var charCode = value.charCodeAt(index);\\n                    // If the character is a control character, append its Unicode or\\n                    // shorthand escape sequence; otherwise, append the character as-is.\\n                    switch (charCode) {\\n                      case 8:case 9:case 10:case 12:case 13:case 34:case 92:\\n                        result += Escapes[charCode];\\n                        break;\\n                      default:\\n                        if (charCode < 32) {\\n                          result += unicodePrefix + toPaddedString(2, charCode.toString(16));\\n                          break;\\n                        }\\n                        result += useCharIndex ? symbols[index] : value.charAt(index);\\n                    }\\n                  }\\n                  return result + '\\\"';\\n                };\\n\\n                // Internal: Recursively serializes an object. Implements the\\n                // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.\\n                var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {\\n                  var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;\\n                  try {\\n                    // Necessary for host object support.\\n                    value = object[property];\\n                  } catch (exception) {}\\n                  if (typeof value == \\\"object\\\" && value) {\\n                    className = getClass.call(value);\\n                    if (className == dateClass && !isProperty.call(value, \\\"toJSON\\\")) {\\n                      if (value > -1 / 0 && value < 1 / 0) {\\n                        // Dates are serialized according to the `Date#toJSON` method\\n                        // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15\\n                        // for the ISO 8601 date time string format.\\n                        if (getDay) {\\n                          // Manually compute the year, month, date, hours, minutes,\\n                          // seconds, and milliseconds if the `getUTC*` methods are\\n                          // buggy. Adapted from @Yaffle's `date-shim` project.\\n                          date = floor(value / 864e5);\\n                          for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);\\n                          for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);\\n                          date = 1 + date - getDay(year, month);\\n                          // The `time` value specifies the time within the day (see ES\\n                          // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used\\n                          // to compute `A modulo B`, as the `%` operator does not\\n                          // correspond to the `modulo` operation for negative numbers.\\n                          time = (value % 864e5 + 864e5) % 864e5;\\n                          // The hours, minutes, seconds, and milliseconds are obtained by\\n                          // decomposing the time within the day. See section 15.9.1.10.\\n                          hours = floor(time / 36e5) % 24;\\n                          minutes = floor(time / 6e4) % 60;\\n                          seconds = floor(time / 1e3) % 60;\\n                          milliseconds = time % 1e3;\\n                        } else {\\n                          year = value.getUTCFullYear();\\n                          month = value.getUTCMonth();\\n                          date = value.getUTCDate();\\n                          hours = value.getUTCHours();\\n                          minutes = value.getUTCMinutes();\\n                          seconds = value.getUTCSeconds();\\n                          milliseconds = value.getUTCMilliseconds();\\n                        }\\n                        // Serialize extended years correctly.\\n                        value = (year <= 0 || year >= 1e4 ? (year < 0 ? \\\"-\\\" : \\\"+\\\") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) + \\\"-\\\" + toPaddedString(2, month + 1) + \\\"-\\\" + toPaddedString(2, date) +\\n                        // Months, dates, hours, minutes, and seconds should have two\\n                        // digits; milliseconds should have three.\\n                        \\\"T\\\" + toPaddedString(2, hours) + \\\":\\\" + toPaddedString(2, minutes) + \\\":\\\" + toPaddedString(2, seconds) +\\n                        // Milliseconds are optional in ES 5.0, but required in 5.1.\\n                        \\\".\\\" + toPaddedString(3, milliseconds) + \\\"Z\\\";\\n                      } else {\\n                        value = null;\\n                      }\\n                    } else if (typeof value.toJSON == \\\"function\\\" && (className != numberClass && className != stringClass && className != arrayClass || isProperty.call(value, \\\"toJSON\\\"))) {\\n                      // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the\\n                      // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3\\n                      // ignores all `toJSON` methods on these objects unless they are\\n                      // defined directly on an instance.\\n                      value = value.toJSON(property);\\n                    }\\n                  }\\n                  if (callback) {\\n                    // If a replacement function was provided, call it to obtain the value\\n                    // for serialization.\\n                    value = callback.call(object, property, value);\\n                  }\\n                  if (value === null) {\\n                    return \\\"null\\\";\\n                  }\\n                  className = getClass.call(value);\\n                  if (className == booleanClass) {\\n                    // Booleans are represented literally.\\n                    return \\\"\\\" + value;\\n                  } else if (className == numberClass) {\\n                    // JSON numbers must be finite. `Infinity` and `NaN` are serialized as\\n                    // `\\\"null\\\"`.\\n                    return value > -1 / 0 && value < 1 / 0 ? \\\"\\\" + value : \\\"null\\\";\\n                  } else if (className == stringClass) {\\n                    // Strings are double-quoted and escaped.\\n                    return quote(\\\"\\\" + value);\\n                  }\\n                  // Recursively serialize objects and arrays.\\n                  if (typeof value == \\\"object\\\") {\\n                    // Check for cyclic structures. This is a linear search; performance\\n                    // is inversely proportional to the number of unique nested objects.\\n                    for (length = stack.length; length--;) {\\n                      if (stack[length] === value) {\\n                        // Cyclic structures cannot be serialized by `JSON.stringify`.\\n                        throw TypeError();\\n                      }\\n                    }\\n                    // Add the object to the stack of traversed objects.\\n                    stack.push(value);\\n                    results = [];\\n                    // Save the current indentation level and indent one additional level.\\n                    prefix = indentation;\\n                    indentation += whitespace;\\n                    if (className == arrayClass) {\\n                      // Recursively serialize array elements.\\n                      for (index = 0, length = value.length; index < length; index++) {\\n                        element = serialize(index, value, callback, properties, whitespace, indentation, stack);\\n                        results.push(element === undef ? \\\"null\\\" : element);\\n                      }\\n                      result = results.length ? whitespace ? \\\"[\\\\n\\\" + indentation + results.join(\\\",\\\\n\\\" + indentation) + \\\"\\\\n\\\" + prefix + \\\"]\\\" : \\\"[\\\" + results.join(\\\",\\\") + \\\"]\\\" : \\\"[]\\\";\\n                    } else {\\n                      // Recursively serialize object members. Members are selected from\\n                      // either a user-specified list of property names, or the object\\n                      // itself.\\n                      forEach(properties || value, function (property) {\\n                        var element = serialize(property, value, callback, properties, whitespace, indentation, stack);\\n                        if (element !== undef) {\\n                          // According to ES 5.1 section 15.12.3: \\\"If `gap` {whitespace}\\n                          // is not the empty string, let `member` {quote(property) + \\\":\\\"}\\n                          // be the concatenation of `member` and the `space` character.\\\"\\n                          // The \\\"`space` character\\\" refers to the literal space\\n                          // character, not the `space` {width} argument provided to\\n                          // `JSON.stringify`.\\n                          results.push(quote(property) + \\\":\\\" + (whitespace ? \\\" \\\" : \\\"\\\") + element);\\n                        }\\n                      });\\n                      result = results.length ? whitespace ? \\\"{\\\\n\\\" + indentation + results.join(\\\",\\\\n\\\" + indentation) + \\\"\\\\n\\\" + prefix + \\\"}\\\" : \\\"{\\\" + results.join(\\\",\\\") + \\\"}\\\" : \\\"{}\\\";\\n                    }\\n                    // Remove the object from the traversed object stack.\\n                    stack.pop();\\n                    return result;\\n                  }\\n                };\\n\\n                // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.\\n                exports.stringify = function (source, filter, width) {\\n                  var whitespace, callback, properties, className;\\n                  if (objectTypes[typeof filter] && filter) {\\n                    if ((className = getClass.call(filter)) == functionClass) {\\n                      callback = filter;\\n                    } else if (className == arrayClass) {\\n                      // Convert the property names array into a makeshift set.\\n                      properties = {};\\n                      for (var index = 0, length = filter.length, value; index < length; value = filter[index++], (className = getClass.call(value), className == stringClass || className == numberClass) && (properties[value] = 1));\\n                    }\\n                  }\\n                  if (width) {\\n                    if ((className = getClass.call(width)) == numberClass) {\\n                      // Convert the `width` to an integer and create a string containing\\n                      // `width` number of space characters.\\n                      if ((width -= width % 1) > 0) {\\n                        for (whitespace = \\\"\\\", width > 10 && (width = 10); whitespace.length < width; whitespace += \\\" \\\");\\n                      }\\n                    } else if (className == stringClass) {\\n                      whitespace = width.length <= 10 ? width : width.slice(0, 10);\\n                    }\\n                  }\\n                  // Opera <= 7.54u2 discards the values associated with empty string keys\\n                  // (`\\\"\\\"`) only if they are used directly within an object member list\\n                  // (e.g., `!(\\\"\\\" in { \\\"\\\": 1})`).\\n                  return serialize(\\\"\\\", (value = {}, value[\\\"\\\"] = source, value), callback, properties, whitespace, \\\"\\\", []);\\n                };\\n              }\\n\\n              // Public: Parses a JSON source string.\\n              if (!has(\\\"json-parse\\\")) {\\n                var fromCharCode = String.fromCharCode;\\n\\n                // Internal: A map of escaped control characters and their unescaped\\n                // equivalents.\\n                var Unescapes = {\\n                  92: \\\"\\\\\\\\\\\",\\n                  34: '\\\"',\\n                  47: \\\"/\\\",\\n                  98: \\\"\\\\b\\\",\\n                  116: \\\"\\\\t\\\",\\n                  110: \\\"\\\\n\\\",\\n                  102: \\\"\\\\f\\\",\\n                  114: \\\"\\\\r\\\"\\n                };\\n\\n                // Internal: Stores the parser state.\\n                var Index, Source;\\n\\n                // Internal: Resets the parser state and throws a `SyntaxError`.\\n                var abort = function () {\\n                  Index = Source = null;\\n                  throw SyntaxError();\\n                };\\n\\n                // Internal: Returns the next token, or `\\\"$\\\"` if the parser has reached\\n                // the end of the source string. A token may be a string, number, `null`\\n                // literal, or Boolean literal.\\n                var lex = function () {\\n                  var source = Source,\\n                      length = source.length,\\n                      value,\\n                      begin,\\n                      position,\\n                      isSigned,\\n                      charCode;\\n                  while (Index < length) {\\n                    charCode = source.charCodeAt(Index);\\n                    switch (charCode) {\\n                      case 9:case 10:case 13:case 32:\\n                        // Skip whitespace tokens, including tabs, carriage returns, line\\n                        // feeds, and space characters.\\n                        Index++;\\n                        break;\\n                      case 123:case 125:case 91:case 93:case 58:case 44:\\n                        // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at\\n                        // the current position.\\n                        value = charIndexBuggy ? source.charAt(Index) : source[Index];\\n                        Index++;\\n                        return value;\\n                      case 34:\\n                        // `\\\"` delimits a JSON string; advance to the next character and\\n                        // begin parsing the string. String tokens are prefixed with the\\n                        // sentinel `@` character to distinguish them from punctuators and\\n                        // end-of-string tokens.\\n                        for (value = \\\"@\\\", Index++; Index < length;) {\\n                          charCode = source.charCodeAt(Index);\\n                          if (charCode < 32) {\\n                            // Unescaped ASCII control characters (those with a code unit\\n                            // less than the space character) are not permitted.\\n                            abort();\\n                          } else if (charCode == 92) {\\n                            // A reverse solidus (`\\\\`) marks the beginning of an escaped\\n                            // control character (including `\\\"`, `\\\\`, and `/`) or Unicode\\n                            // escape sequence.\\n                            charCode = source.charCodeAt(++Index);\\n                            switch (charCode) {\\n                              case 92:case 34:case 47:case 98:case 116:case 110:case 102:case 114:\\n                                // Revive escaped control characters.\\n                                value += Unescapes[charCode];\\n                                Index++;\\n                                break;\\n                              case 117:\\n                                // `\\\\u` marks the beginning of a Unicode escape sequence.\\n                                // Advance to the first character and validate the\\n                                // four-digit code point.\\n                                begin = ++Index;\\n                                for (position = Index + 4; Index < position; Index++) {\\n                                  charCode = source.charCodeAt(Index);\\n                                  // A valid sequence comprises four hexdigits (case-\\n                                  // insensitive) that form a single hexadecimal value.\\n                                  if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {\\n                                    // Invalid Unicode escape sequence.\\n                                    abort();\\n                                  }\\n                                }\\n                                // Revive the escaped character.\\n                                value += fromCharCode(\\\"0x\\\" + source.slice(begin, Index));\\n                                break;\\n                              default:\\n                                // Invalid escape sequence.\\n                                abort();\\n                            }\\n                          } else {\\n                            if (charCode == 34) {\\n                              // An unescaped double-quote character marks the end of the\\n                              // string.\\n                              break;\\n                            }\\n                            charCode = source.charCodeAt(Index);\\n                            begin = Index;\\n                            // Optimize for the common case where a string is valid.\\n                            while (charCode >= 32 && charCode != 92 && charCode != 34) {\\n                              charCode = source.charCodeAt(++Index);\\n                            }\\n                            // Append the string as-is.\\n                            value += source.slice(begin, Index);\\n                          }\\n                        }\\n                        if (source.charCodeAt(Index) == 34) {\\n                          // Advance to the next character and return the revived string.\\n                          Index++;\\n                          return value;\\n                        }\\n                        // Unterminated string.\\n                        abort();\\n                      default:\\n                        // Parse numbers and literals.\\n                        begin = Index;\\n                        // Advance past the negative sign, if one is specified.\\n                        if (charCode == 45) {\\n                          isSigned = true;\\n                          charCode = source.charCodeAt(++Index);\\n                        }\\n                        // Parse an integer or floating-point value.\\n                        if (charCode >= 48 && charCode <= 57) {\\n                          // Leading zeroes are interpreted as octal literals.\\n                          if (charCode == 48 && (charCode = source.charCodeAt(Index + 1), charCode >= 48 && charCode <= 57)) {\\n                            // Illegal octal literal.\\n                            abort();\\n                          }\\n                          isSigned = false;\\n                          // Parse the integer component.\\n                          for (; Index < length && (charCode = source.charCodeAt(Index), charCode >= 48 && charCode <= 57); Index++);\\n                          // Floats cannot contain a leading decimal point; however, this\\n                          // case is already accounted for by the parser.\\n                          if (source.charCodeAt(Index) == 46) {\\n                            position = ++Index;\\n                            // Parse the decimal component.\\n                            for (; position < length && (charCode = source.charCodeAt(position), charCode >= 48 && charCode <= 57); position++);\\n                            if (position == Index) {\\n                              // Illegal trailing decimal.\\n                              abort();\\n                            }\\n                            Index = position;\\n                          }\\n                          // Parse exponents. The `e` denoting the exponent is\\n                          // case-insensitive.\\n                          charCode = source.charCodeAt(Index);\\n                          if (charCode == 101 || charCode == 69) {\\n                            charCode = source.charCodeAt(++Index);\\n                            // Skip past the sign following the exponent, if one is\\n                            // specified.\\n                            if (charCode == 43 || charCode == 45) {\\n                              Index++;\\n                            }\\n                            // Parse the exponential component.\\n                            for (position = Index; position < length && (charCode = source.charCodeAt(position), charCode >= 48 && charCode <= 57); position++);\\n                            if (position == Index) {\\n                              // Illegal empty exponent.\\n                              abort();\\n                            }\\n                            Index = position;\\n                          }\\n                          // Coerce the parsed value to a JavaScript number.\\n                          return +source.slice(begin, Index);\\n                        }\\n                        // A negative sign may only precede numbers.\\n                        if (isSigned) {\\n                          abort();\\n                        }\\n                        // `true`, `false`, and `null` literals.\\n                        if (source.slice(Index, Index + 4) == \\\"true\\\") {\\n                          Index += 4;\\n                          return true;\\n                        } else if (source.slice(Index, Index + 5) == \\\"false\\\") {\\n                          Index += 5;\\n                          return false;\\n                        } else if (source.slice(Index, Index + 4) == \\\"null\\\") {\\n                          Index += 4;\\n                          return null;\\n                        }\\n                        // Unrecognized token.\\n                        abort();\\n                    }\\n                  }\\n                  // Return the sentinel `$` character if the parser has reached the end\\n                  // of the source string.\\n                  return \\\"$\\\";\\n                };\\n\\n                // Internal: Parses a JSON `value` token.\\n                var get = function (value) {\\n                  var results, hasMembers;\\n                  if (value == \\\"$\\\") {\\n                    // Unexpected end of input.\\n                    abort();\\n                  }\\n                  if (typeof value == \\\"string\\\") {\\n                    if ((charIndexBuggy ? value.charAt(0) : value[0]) == \\\"@\\\") {\\n                      // Remove the sentinel `@` character.\\n                      return value.slice(1);\\n                    }\\n                    // Parse object and array literals.\\n                    if (value == \\\"[\\\") {\\n                      // Parses a JSON array, returning a new JavaScript array.\\n                      results = [];\\n                      for (;; hasMembers || (hasMembers = true)) {\\n                        value = lex();\\n                        // A closing square bracket marks the end of the array literal.\\n                        if (value == \\\"]\\\") {\\n                          break;\\n                        }\\n                        // If the array literal contains elements, the current token\\n                        // should be a comma separating the previous element from the\\n                        // next.\\n                        if (hasMembers) {\\n                          if (value == \\\",\\\") {\\n                            value = lex();\\n                            if (value == \\\"]\\\") {\\n                              // Unexpected trailing `,` in array literal.\\n                              abort();\\n                            }\\n                          } else {\\n                            // A `,` must separate each array element.\\n                            abort();\\n                          }\\n                        }\\n                        // Elisions and leading commas are not permitted.\\n                        if (value == \\\",\\\") {\\n                          abort();\\n                        }\\n                        results.push(get(value));\\n                      }\\n                      return results;\\n                    } else if (value == \\\"{\\\") {\\n                      // Parses a JSON object, returning a new JavaScript object.\\n                      results = {};\\n                      for (;; hasMembers || (hasMembers = true)) {\\n                        value = lex();\\n                        // A closing curly brace marks the end of the object literal.\\n                        if (value == \\\"}\\\") {\\n                          break;\\n                        }\\n                        // If the object literal contains members, the current token\\n                        // should be a comma separator.\\n                        if (hasMembers) {\\n                          if (value == \\\",\\\") {\\n                            value = lex();\\n                            if (value == \\\"}\\\") {\\n                              // Unexpected trailing `,` in object literal.\\n                              abort();\\n                            }\\n                          } else {\\n                            // A `,` must separate each object member.\\n                            abort();\\n                          }\\n                        }\\n                        // Leading commas are not permitted, object property names must be\\n                        // double-quoted strings, and a `:` must separate each property\\n                        // name and value.\\n                        if (value == \\\",\\\" || typeof value != \\\"string\\\" || (charIndexBuggy ? value.charAt(0) : value[0]) != \\\"@\\\" || lex() != \\\":\\\") {\\n                          abort();\\n                        }\\n                        results[value.slice(1)] = get(lex());\\n                      }\\n                      return results;\\n                    }\\n                    // Unexpected token encountered.\\n                    abort();\\n                  }\\n                  return value;\\n                };\\n\\n                // Internal: Updates a traversed object member.\\n                var update = function (source, property, callback) {\\n                  var element = walk(source, property, callback);\\n                  if (element === undef) {\\n                    delete source[property];\\n                  } else {\\n                    source[property] = element;\\n                  }\\n                };\\n\\n                // Internal: Recursively traverses a parsed JSON object, invoking the\\n                // `callback` function for each value. This is an implementation of the\\n                // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.\\n                var walk = function (source, property, callback) {\\n                  var value = source[property],\\n                      length;\\n                  if (typeof value == \\\"object\\\" && value) {\\n                    // `forEach` can't be used to traverse an array in Opera <= 8.54\\n                    // because its `Object#hasOwnProperty` implementation returns `false`\\n                    // for array indices (e.g., `![1, 2, 3].hasOwnProperty(\\\"0\\\")`).\\n                    if (getClass.call(value) == arrayClass) {\\n                      for (length = value.length; length--;) {\\n                        update(value, length, callback);\\n                      }\\n                    } else {\\n                      forEach(value, function (property) {\\n                        update(value, property, callback);\\n                      });\\n                    }\\n                  }\\n                  return callback.call(source, property, value);\\n                };\\n\\n                // Public: `JSON.parse`. See ES 5.1 section 15.12.2.\\n                exports.parse = function (source, callback) {\\n                  var result, value;\\n                  Index = 0;\\n                  Source = \\\"\\\" + source;\\n                  result = get(lex());\\n                  // If a JSON string contains multiple tokens, it is invalid.\\n                  if (lex() != \\\"$\\\") {\\n                    abort();\\n                  }\\n                  // Reset the parser state.\\n                  Index = Source = null;\\n                  return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[\\\"\\\"] = result, value), \\\"\\\", callback) : result;\\n                };\\n              }\\n            }\\n\\n            exports[\\\"runInContext\\\"] = runInContext;\\n            return exports;\\n          }\\n\\n          if (freeExports && !isLoader) {\\n            // Export for CommonJS environments.\\n            runInContext(root, freeExports);\\n          } else {\\n            // Export for web browsers and JavaScript engines.\\n            var nativeJSON = root.JSON,\\n                previousJSON = root[\\\"JSON3\\\"],\\n                isRestored = false;\\n\\n            var JSON3 = runInContext(root, root[\\\"JSON3\\\"] = {\\n              // Public: Restores the original value of the global `JSON` object and\\n              // returns a reference to the `JSON3` object.\\n              \\\"noConflict\\\": function () {\\n                if (!isRestored) {\\n                  isRestored = true;\\n                  root.JSON = nativeJSON;\\n                  root[\\\"JSON3\\\"] = previousJSON;\\n                  nativeJSON = previousJSON = null;\\n                }\\n                return JSON3;\\n              }\\n            });\\n\\n            root.JSON = {\\n              \\\"parse\\\": JSON3.parse,\\n              \\\"stringify\\\": JSON3.stringify\\n            };\\n          }\\n\\n          // Export for asynchronous module loaders.\\n          if (isLoader) {\\n            define(function () {\\n              return JSON3;\\n            });\\n          }\\n        }).call(this);\\n      }).call(this, typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {});\\n    }, {}], 58: [function (require, module, exports) {\\n      /**\\r\\n       * Helpers.\\r\\n       */\\n\\n      var s = 1000;\\n      var m = s * 60;\\n      var h = m * 60;\\n      var d = h * 24;\\n      var y = d * 365.25;\\n\\n      /**\\r\\n       * Parse or format the given `val`.\\r\\n       *\\r\\n       * Options:\\r\\n       *\\r\\n       *  - `long` verbose formatting [false]\\r\\n       *\\r\\n       * @param {String|Number} val\\r\\n       * @param {Object} [options]\\r\\n       * @throws {Error} throw an error if val is not a non-empty string or a number\\r\\n       * @return {String|Number}\\r\\n       * @api public\\r\\n       */\\n\\n      module.exports = function (val, options) {\\n        options = options || {};\\n        var type = typeof val;\\n        if (type === 'string' && val.length > 0) {\\n          return parse(val);\\n        } else if (type === 'number' && isNaN(val) === false) {\\n          return options.long ? fmtLong(val) : fmtShort(val);\\n        }\\n        throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));\\n      };\\n\\n      /**\\r\\n       * Parse the given `str` and return milliseconds.\\r\\n       *\\r\\n       * @param {String} str\\r\\n       * @return {Number}\\r\\n       * @api private\\r\\n       */\\n\\n      function parse(str) {\\n        str = String(str);\\n        if (str.length > 100) {\\n          return;\\n        }\\n        var match = /^((?:\\\\d+)?\\\\.?\\\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);\\n        if (!match) {\\n          return;\\n        }\\n        var n = parseFloat(match[1]);\\n        var type = (match[2] || 'ms').toLowerCase();\\n        switch (type) {\\n          case 'years':\\n          case 'year':\\n          case 'yrs':\\n          case 'yr':\\n          case 'y':\\n            return n * y;\\n          case 'days':\\n          case 'day':\\n          case 'd':\\n            return n * d;\\n          case 'hours':\\n          case 'hour':\\n          case 'hrs':\\n          case 'hr':\\n          case 'h':\\n            return n * h;\\n          case 'minutes':\\n          case 'minute':\\n          case 'mins':\\n          case 'min':\\n          case 'm':\\n            return n * m;\\n          case 'seconds':\\n          case 'second':\\n          case 'secs':\\n          case 'sec':\\n          case 's':\\n            return n * s;\\n          case 'milliseconds':\\n          case 'millisecond':\\n          case 'msecs':\\n          case 'msec':\\n          case 'ms':\\n            return n;\\n          default:\\n            return undefined;\\n        }\\n      }\\n\\n      /**\\r\\n       * Short format for `ms`.\\r\\n       *\\r\\n       * @param {Number} ms\\r\\n       * @return {String}\\r\\n       * @api private\\r\\n       */\\n\\n      function fmtShort(ms) {\\n        if (ms >= d) {\\n          return Math.round(ms / d) + 'd';\\n        }\\n        if (ms >= h) {\\n          return Math.round(ms / h) + 'h';\\n        }\\n        if (ms >= m) {\\n          return Math.round(ms / m) + 'm';\\n        }\\n        if (ms >= s) {\\n          return Math.round(ms / s) + 's';\\n        }\\n        return ms + 'ms';\\n      }\\n\\n      /**\\r\\n       * Long format for `ms`.\\r\\n       *\\r\\n       * @param {Number} ms\\r\\n       * @return {String}\\r\\n       * @api private\\r\\n       */\\n\\n      function fmtLong(ms) {\\n        return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';\\n      }\\n\\n      /**\\r\\n       * Pluralization helper.\\r\\n       */\\n\\n      function plural(ms, n, name) {\\n        if (ms < n) {\\n          return;\\n        }\\n        if (ms < n * 1.5) {\\n          return Math.floor(ms / n) + ' ' + name;\\n        }\\n        return Math.ceil(ms / n) + ' ' + name + 's';\\n      }\\n    }, {}], 59: [function (require, module, exports) {\\n      'use strict';\\n\\n      var has = Object.prototype.hasOwnProperty;\\n\\n      /**\\r\\n       * Decode a URI encoded string.\\r\\n       *\\r\\n       * @param {String} input The URI encoded string.\\r\\n       * @returns {String} The decoded string.\\r\\n       * @api private\\r\\n       */\\n      function decode(input) {\\n        return decodeURIComponent(input.replace(/\\\\+/g, ' '));\\n      }\\n\\n      /**\\r\\n       * Simple query string parser.\\r\\n       *\\r\\n       * @param {String} query The query string that needs to be parsed.\\r\\n       * @returns {Object}\\r\\n       * @api public\\r\\n       */\\n      function querystring(query) {\\n        var parser = /([^=?&]+)=?([^&]*)/g,\\n            result = {},\\n            part;\\n\\n        while (part = parser.exec(query)) {\\n          var key = decode(part[1]),\\n              value = decode(part[2]);\\n\\n          //\\n          // Prevent overriding of existing properties. This ensures that build-in\\n          // methods like `toString` or __proto__ are not overriden by malicious\\n          // querystrings.\\n          //\\n          if (key in result) continue;\\n          result[key] = value;\\n        }\\n\\n        return result;\\n      }\\n\\n      /**\\r\\n       * Transform a query string to an object.\\r\\n       *\\r\\n       * @param {Object} obj Object that should be transformed.\\r\\n       * @param {String} prefix Optional prefix.\\r\\n       * @returns {String}\\r\\n       * @api public\\r\\n       */\\n      function querystringify(obj, prefix) {\\n        prefix = prefix || '';\\n\\n        var pairs = [];\\n\\n        //\\n        // Optionally prefix with a '?' if needed\\n        //\\n        if ('string' !== typeof prefix) prefix = '?';\\n\\n        for (var key in obj) {\\n          if (has.call(obj, key)) {\\n            pairs.push(encodeURIComponent(key) + '=' + encodeURIComponent(obj[key]));\\n          }\\n        }\\n\\n        return pairs.length ? prefix + pairs.join('&') : '';\\n      }\\n\\n      //\\n      // Expose the module.\\n      //\\n      exports.stringify = querystringify;\\n      exports.parse = querystring;\\n    }, {}], 60: [function (require, module, exports) {\\n      'use strict';\\n\\n      /**\\r\\n       * Check if we're required to add a port number.\\r\\n       *\\r\\n       * @see https://url.spec.whatwg.org/#default-port\\r\\n       * @param {Number|String} port Port number we need to check\\r\\n       * @param {String} protocol Protocol we need to check against.\\r\\n       * @returns {Boolean} Is it a default port for the given protocol\\r\\n       * @api private\\r\\n       */\\n\\n      module.exports = function required(port, protocol) {\\n        protocol = protocol.split(':')[0];\\n        port = +port;\\n\\n        if (!port) return false;\\n\\n        switch (protocol) {\\n          case 'http':\\n          case 'ws':\\n            return port !== 80;\\n\\n          case 'https':\\n          case 'wss':\\n            return port !== 443;\\n\\n          case 'ftp':\\n            return port !== 21;\\n\\n          case 'gopher':\\n            return port !== 70;\\n\\n          case 'file':\\n            return false;\\n        }\\n\\n        return port !== 0;\\n      };\\n    }, {}], 61: [function (require, module, exports) {\\n      (function (global) {\\n        'use strict';\\n\\n        var required = require('requires-port'),\\n            qs = require('querystringify'),\\n            protocolre = /^([a-z][a-z0-9.+-]*:)?(\\\\/\\\\/)?([\\\\S\\\\s]*)/i,\\n            slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\\\\/\\\\//;\\n\\n        /**\\r\\n         * These are the parse rules for the URL parser, it informs the parser\\r\\n         * about:\\r\\n         *\\r\\n         * 0. The char it Needs to parse, if it's a string it should be done using\\r\\n         *    indexOf, RegExp using exec and NaN means set as current value.\\r\\n         * 1. The property we should set when parsing this value.\\r\\n         * 2. Indication if it's backwards or forward parsing, when set as number it's\\r\\n         *    the value of extra chars that should be split off.\\r\\n         * 3. Inherit from location if non existing in the parser.\\r\\n         * 4. `toLowerCase` the resulting value.\\r\\n         */\\n        var rules = [['#', 'hash'], // Extract from the back.\\n        ['?', 'query'], // Extract from the back.\\n        ['/', 'pathname'], // Extract from the back.\\n        ['@', 'auth', 1], // Extract from the front.\\n        [NaN, 'host', undefined, 1, 1], // Set left over value.\\n        [/:(\\\\d+)$/, 'port', undefined, 1], // RegExp the back.\\n        [NaN, 'hostname', undefined, 1, 1] // Set left over.\\n        ];\\n\\n        /**\\r\\n         * These properties should not be copied or inherited from. This is only needed\\r\\n         * for all non blob URL's as a blob URL does not include a hash, only the\\r\\n         * origin.\\r\\n         *\\r\\n         * @type {Object}\\r\\n         * @private\\r\\n         */\\n        var ignore = { hash: 1, query: 1 };\\n\\n        /**\\r\\n         * The location object differs when your code is loaded through a normal page,\\r\\n         * Worker or through a worker using a blob. And with the blobble begins the\\r\\n         * trouble as the location object will contain the URL of the blob, not the\\r\\n         * location of the page where our code is loaded in. The actual origin is\\r\\n         * encoded in the `pathname` so we can thankfully generate a good \\\"default\\\"\\r\\n         * location from it so we can generate proper relative URL's again.\\r\\n         *\\r\\n         * @param {Object|String} loc Optional default location object.\\r\\n         * @returns {Object} lolcation object.\\r\\n         * @api public\\r\\n         */\\n        function lolcation(loc) {\\n          loc = loc || global.location || {};\\n\\n          var finaldestination = {},\\n              type = typeof loc,\\n              key;\\n\\n          if ('blob:' === loc.protocol) {\\n            finaldestination = new URL(unescape(loc.pathname), {});\\n          } else if ('string' === type) {\\n            finaldestination = new URL(loc, {});\\n            for (key in ignore) delete finaldestination[key];\\n          } else if ('object' === type) {\\n            for (key in loc) {\\n              if (key in ignore) continue;\\n              finaldestination[key] = loc[key];\\n            }\\n\\n            if (finaldestination.slashes === undefined) {\\n              finaldestination.slashes = slashes.test(loc.href);\\n            }\\n          }\\n\\n          return finaldestination;\\n        }\\n\\n        /**\\r\\n         * @typedef ProtocolExtract\\r\\n         * @type Object\\r\\n         * @property {String} protocol Protocol matched in the URL, in lowercase.\\r\\n         * @property {Boolean} slashes `true` if protocol is followed by \\\"//\\\", else `false`.\\r\\n         * @property {String} rest Rest of the URL that is not part of the protocol.\\r\\n         */\\n\\n        /**\\r\\n         * Extract protocol information from a URL with/without double slash (\\\"//\\\").\\r\\n         *\\r\\n         * @param {String} address URL we want to extract from.\\r\\n         * @return {ProtocolExtract} Extracted information.\\r\\n         * @api private\\r\\n         */\\n        function extractProtocol(address) {\\n          var match = protocolre.exec(address);\\n\\n          return {\\n            protocol: match[1] ? match[1].toLowerCase() : '',\\n            slashes: !!match[2],\\n            rest: match[3]\\n          };\\n        }\\n\\n        /**\\r\\n         * Resolve a relative URL pathname against a base URL pathname.\\r\\n         *\\r\\n         * @param {String} relative Pathname of the relative URL.\\r\\n         * @param {String} base Pathname of the base URL.\\r\\n         * @return {String} Resolved pathname.\\r\\n         * @api private\\r\\n         */\\n        function resolve(relative, base) {\\n          var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/')),\\n              i = path.length,\\n              last = path[i - 1],\\n              unshift = false,\\n              up = 0;\\n\\n          while (i--) {\\n            if (path[i] === '.') {\\n              path.splice(i, 1);\\n            } else if (path[i] === '..') {\\n              path.splice(i, 1);\\n              up++;\\n            } else if (up) {\\n              if (i === 0) unshift = true;\\n              path.splice(i, 1);\\n              up--;\\n            }\\n          }\\n\\n          if (unshift) path.unshift('');\\n          if (last === '.' || last === '..') path.push('');\\n\\n          return path.join('/');\\n        }\\n\\n        /**\\r\\n         * The actual URL instance. Instead of returning an object we've opted-in to\\r\\n         * create an actual constructor as it's much more memory efficient and\\r\\n         * faster and it pleases my OCD.\\r\\n         *\\r\\n         * @constructor\\r\\n         * @param {String} address URL we want to parse.\\r\\n         * @param {Object|String} location Location defaults for relative paths.\\r\\n         * @param {Boolean|Function} parser Parser for the query string.\\r\\n         * @api public\\r\\n         */\\n        function URL(address, location, parser) {\\n          if (!(this instanceof URL)) {\\n            return new URL(address, location, parser);\\n          }\\n\\n          var relative,\\n              extracted,\\n              parse,\\n              instruction,\\n              index,\\n              key,\\n              instructions = rules.slice(),\\n              type = typeof location,\\n              url = this,\\n              i = 0;\\n\\n          //\\n          // The following if statements allows this module two have compatibility with\\n          // 2 different API:\\n          //\\n          // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments\\n          //    where the boolean indicates that the query string should also be parsed.\\n          //\\n          // 2. The `URL` interface of the browser which accepts a URL, object as\\n          //    arguments. The supplied object will be used as default values / fall-back\\n          //    for relative paths.\\n          //\\n          if ('object' !== type && 'string' !== type) {\\n            parser = location;\\n            location = null;\\n          }\\n\\n          if (parser && 'function' !== typeof parser) parser = qs.parse;\\n\\n          location = lolcation(location);\\n\\n          //\\n          // Extract protocol information before running the instructions.\\n          //\\n          extracted = extractProtocol(address || '');\\n          relative = !extracted.protocol && !extracted.slashes;\\n          url.slashes = extracted.slashes || relative && location.slashes;\\n          url.protocol = extracted.protocol || location.protocol || '';\\n          address = extracted.rest;\\n\\n          //\\n          // When the authority component is absent the URL starts with a path\\n          // component.\\n          //\\n          if (!extracted.slashes) instructions[2] = [/(.*)/, 'pathname'];\\n\\n          for (; i < instructions.length; i++) {\\n            instruction = instructions[i];\\n            parse = instruction[0];\\n            key = instruction[1];\\n\\n            if (parse !== parse) {\\n              url[key] = address;\\n            } else if ('string' === typeof parse) {\\n              if (~(index = address.indexOf(parse))) {\\n                if ('number' === typeof instruction[2]) {\\n                  url[key] = address.slice(0, index);\\n                  address = address.slice(index + instruction[2]);\\n                } else {\\n                  url[key] = address.slice(index);\\n                  address = address.slice(0, index);\\n                }\\n              }\\n            } else if (index = parse.exec(address)) {\\n              url[key] = index[1];\\n              address = address.slice(0, index.index);\\n            }\\n\\n            url[key] = url[key] || (relative && instruction[3] ? location[key] || '' : '');\\n\\n            //\\n            // Hostname, host and protocol should be lowercased so they can be used to\\n            // create a proper `origin`.\\n            //\\n            if (instruction[4]) url[key] = url[key].toLowerCase();\\n          }\\n\\n          //\\n          // Also parse the supplied query string in to an object. If we're supplied\\n          // with a custom parser as function use that instead of the default build-in\\n          // parser.\\n          //\\n          if (parser) url.query = parser(url.query);\\n\\n          //\\n          // If the URL is relative, resolve the pathname against the base URL.\\n          //\\n          if (relative && location.slashes && url.pathname.charAt(0) !== '/' && (url.pathname !== '' || location.pathname !== '')) {\\n            url.pathname = resolve(url.pathname, location.pathname);\\n          }\\n\\n          //\\n          // We should not add port numbers if they are already the default port number\\n          // for a given protocol. As the host also contains the port number we're going\\n          // override it with the hostname which contains no port number.\\n          //\\n          if (!required(url.port, url.protocol)) {\\n            url.host = url.hostname;\\n            url.port = '';\\n          }\\n\\n          //\\n          // Parse down the `auth` for the username and password.\\n          //\\n          url.username = url.password = '';\\n          if (url.auth) {\\n            instruction = url.auth.split(':');\\n            url.username = instruction[0] || '';\\n            url.password = instruction[1] || '';\\n          }\\n\\n          url.origin = url.protocol && url.host && url.protocol !== 'file:' ? url.protocol + '//' + url.host : 'null';\\n\\n          //\\n          // The href is just the compiled result.\\n          //\\n          url.href = url.toString();\\n        }\\n\\n        /**\\r\\n         * This is convenience method for changing properties in the URL instance to\\r\\n         * insure that they all propagate correctly.\\r\\n         *\\r\\n         * @param {String} part          Property we need to adjust.\\r\\n         * @param {Mixed} value          The newly assigned value.\\r\\n         * @param {Boolean|Function} fn  When setting the query, it will be the function\\r\\n         *                               used to parse the query.\\r\\n         *                               When setting the protocol, double slash will be\\r\\n         *                               removed from the final url if it is true.\\r\\n         * @returns {URL}\\r\\n         * @api public\\r\\n         */\\n        function set(part, value, fn) {\\n          var url = this;\\n\\n          switch (part) {\\n            case 'query':\\n              if ('string' === typeof value && value.length) {\\n                value = (fn || qs.parse)(value);\\n              }\\n\\n              url[part] = value;\\n              break;\\n\\n            case 'port':\\n              url[part] = value;\\n\\n              if (!required(value, url.protocol)) {\\n                url.host = url.hostname;\\n                url[part] = '';\\n              } else if (value) {\\n                url.host = url.hostname + ':' + value;\\n              }\\n\\n              break;\\n\\n            case 'hostname':\\n              url[part] = value;\\n\\n              if (url.port) value += ':' + url.port;\\n              url.host = value;\\n              break;\\n\\n            case 'host':\\n              url[part] = value;\\n\\n              if (/:\\\\d+$/.test(value)) {\\n                value = value.split(':');\\n                url.port = value.pop();\\n                url.hostname = value.join(':');\\n              } else {\\n                url.hostname = value;\\n                url.port = '';\\n              }\\n\\n              break;\\n\\n            case 'protocol':\\n              url.protocol = value.toLowerCase();\\n              url.slashes = !fn;\\n              break;\\n\\n            case 'pathname':\\n            case 'hash':\\n              if (value) {\\n                var char = part === 'pathname' ? '/' : '#';\\n                url[part] = value.charAt(0) !== char ? char + value : value;\\n              } else {\\n                url[part] = value;\\n              }\\n              break;\\n\\n            default:\\n              url[part] = value;\\n          }\\n\\n          for (var i = 0; i < rules.length; i++) {\\n            var ins = rules[i];\\n\\n            if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();\\n          }\\n\\n          url.origin = url.protocol && url.host && url.protocol !== 'file:' ? url.protocol + '//' + url.host : 'null';\\n\\n          url.href = url.toString();\\n\\n          return url;\\n        }\\n\\n        /**\\r\\n         * Transform the properties back in to a valid and full URL string.\\r\\n         *\\r\\n         * @param {Function} stringify Optional query stringify function.\\r\\n         * @returns {String}\\r\\n         * @api public\\r\\n         */\\n        function toString(stringify) {\\n          if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;\\n\\n          var query,\\n              url = this,\\n              protocol = url.protocol;\\n\\n          if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';\\n\\n          var result = protocol + (url.slashes ? '//' : '');\\n\\n          if (url.username) {\\n            result += url.username;\\n            if (url.password) result += ':' + url.password;\\n            result += '@';\\n          }\\n\\n          result += url.host + url.pathname;\\n\\n          query = 'object' === typeof url.query ? stringify(url.query) : url.query;\\n          if (query) result += '?' !== query.charAt(0) ? '?' + query : query;\\n\\n          if (url.hash) result += url.hash;\\n\\n          return result;\\n        }\\n\\n        URL.prototype = { set: set, toString: toString };\\n\\n        //\\n        // Expose the URL parser and some additional properties that might be useful for\\n        // others or testing.\\n        //\\n        URL.extractProtocol = extractProtocol;\\n        URL.location = lolcation;\\n        URL.qs = qs;\\n\\n        module.exports = URL;\\n      }).call(this, typeof global !== \\\"undefined\\\" ? global : typeof self !== \\\"undefined\\\" ? self : typeof window !== \\\"undefined\\\" ? window : {});\\n    }, { \\\"querystringify\\\": 59, \\\"requires-port\\\": 60 }] }, {}, [1])(1);\\n});\\n\\n//# sourceMappingURL=sockjs.js.map\\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(0)))//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc29ja2pzLWNsaWVudC9kaXN0L3NvY2tqcy5qcz85YmUyIl0sIm5hbWVzIjpbImYiLCJtb2R1bGUiLCJleHBvcnRzIiwiZGVmaW5lIiwiciIsImUiLCJuIiwidCIsIm8iLCJpIiwiYyIsInJlcXVpcmUiLCJ1IiwiYSIsIkVycm9yIiwiY29kZSIsInAiLCJjYWxsIiwibGVuZ3RoIiwiZ2xvYmFsIiwidHJhbnNwb3J0TGlzdCIsInNldFRpbWVvdXQiLCJfc29ja2pzX29ubG9hZCIsInNlbGYiLCJ3aW5kb3ciLCJpbmhlcml0cyIsIkV2ZW50IiwiQ2xvc2VFdmVudCIsImluaXRFdmVudCIsIndhc0NsZWFuIiwicmVhc29uIiwiRXZlbnRUYXJnZXQiLCJFdmVudEVtaXR0ZXIiLCJwcm90b3R5cGUiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJ0eXBlIiwiX2xpc3RlbmVycyIsIm9uY2UiLCJsaXN0ZW5lciIsImZpcmVkIiwiZyIsInJlbW92ZUxpc3RlbmVyIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJvbiIsImVtaXQiLCJsaXN0ZW5lcnMiLCJsIiwiYXJncyIsIkFycmF5IiwiYWkiLCJhZGRMaXN0ZW5lciIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZXZlbnRUeXBlIiwiY2FuQnViYmxlIiwiY2FuY2VsYWJsZSIsImJ1YmJsZXMiLCJ0aW1lU3RhbXAiLCJEYXRlIiwic3RvcFByb3BhZ2F0aW9uIiwicHJldmVudERlZmF1bHQiLCJDQVBUVVJJTkdfUEhBU0UiLCJBVF9UQVJHRVQiLCJCVUJCTElOR19QSEFTRSIsImFyciIsImluZGV4T2YiLCJjb25jYXQiLCJpZHgiLCJzbGljZSIsImRpc3BhdGNoRXZlbnQiLCJldmVudCIsIlRyYW5zcG9ydE1lc3NhZ2VFdmVudCIsImRhdGEiLCJKU09OMyIsImlmcmFtZVV0aWxzIiwiRmFjYWRlSlMiLCJ0cmFuc3BvcnQiLCJfdHJhbnNwb3J0IiwiX3RyYW5zcG9ydE1lc3NhZ2UiLCJiaW5kIiwiX3RyYW5zcG9ydENsb3NlIiwicG9zdE1lc3NhZ2UiLCJzdHJpbmdpZnkiLCJmcmFtZSIsIl9zZW5kIiwic2VuZCIsIl9jbG9zZSIsImNsb3NlIiwicHJvY2VzcyIsInVybFV0aWxzIiwiZXZlbnRVdGlscyIsIkluZm9JZnJhbWVSZWNlaXZlciIsImxvYyIsImRlYnVnIiwiZW52IiwiTk9ERV9FTlYiLCJTb2NrSlMiLCJhdmFpbGFibGVUcmFuc3BvcnRzIiwidHJhbnNwb3J0TWFwIiwiZm9yRWFjaCIsImF0IiwiZmFjYWRlVHJhbnNwb3J0IiwidHJhbnNwb3J0TmFtZSIsInBhcmVudE9yaWdpbiIsImJvb3RzdHJhcF9pZnJhbWUiLCJmYWNhZGUiLCJjdXJyZW50V2luZG93SWQiLCJoYXNoIiwib25NZXNzYWdlIiwic291cmNlIiwicGFyZW50Iiwib3JpZ2luIiwiaWZyYW1lTWVzc2FnZSIsInBhcnNlIiwiaWdub3JlZCIsIndpbmRvd0lkIiwidmVyc2lvbiIsInRyYW5zVXJsIiwiYmFzZVVybCIsImlzT3JpZ2luRXF1YWwiLCJocmVmIiwiYXR0YWNoRXZlbnQiLCJvYmplY3RVdGlscyIsIkluZm9BamF4IiwidXJsIiwiQWpheE9iamVjdCIsInQwIiwieG8iLCJzdGF0dXMiLCJ0ZXh0IiwiaW5mbyIsInJ0dCIsImlzT2JqZWN0IiwiWEhSTG9jYWxPYmplY3QiLCJJbmZvUmVjZWl2ZXJJZnJhbWUiLCJpciIsInV0aWxzIiwiSWZyYW1lVHJhbnNwb3J0IiwiSW5mb0lmcmFtZSIsImdvIiwiaWZyIiwibXNnIiwiZCIsImRvY3VtZW50IiwiYm9keSIsImVuYWJsZWQiLCJYRFIiLCJYSFJDb3JzIiwiWEhSTG9jYWwiLCJYSFJGYWtlIiwiSW5mb1JlY2VpdmVyIiwidXJsSW5mbyIsImRvWGhyIiwiX2dldFJlY2VpdmVyIiwic2FtZU9yaWdpbiIsInNhbWVTY2hlbWUiLCJhZGRQYXRoIiwidGltZW91dFJlZiIsIl9jbGVhbnVwIiwidGltZW91dCIsImNsZWFyVGltZW91dCIsImxvY2F0aW9uIiwicHJvdG9jb2wiLCJob3N0IiwicG9ydCIsIlVSTCIsInJhbmRvbSIsImVzY2FwZSIsImJyb3dzZXIiLCJsb2ciLCJ0cmFuc3BvcnRzIiwicHJvdG9jb2xzIiwib3B0aW9ucyIsIlR5cGVFcnJvciIsInJlYWR5U3RhdGUiLCJDT05ORUNUSU5HIiwiZXh0ZW5zaW9ucyIsInByb3RvY29sc193aGl0ZWxpc3QiLCJ3YXJuIiwiX3RyYW5zcG9ydHNXaGl0ZWxpc3QiLCJfdHJhbnNwb3J0T3B0aW9ucyIsInRyYW5zcG9ydE9wdGlvbnMiLCJzZXNzaW9uSWQiLCJfZ2VuZXJhdGVTZXNzaW9uSWQiLCJzdHJpbmciLCJfc2VydmVyIiwic2VydmVyIiwibnVtYmVyU3RyaW5nIiwicGFyc2VkVXJsIiwiU3ludGF4RXJyb3IiLCJzZWN1cmUiLCJpc0FycmF5Iiwic29ydGVkUHJvdG9jb2xzIiwic29ydCIsInByb3RvIiwiZ2V0T3JpZ2luIiwiX29yaWdpbiIsInRvTG93ZXJDYXNlIiwic2V0IiwicGF0aG5hbWUiLCJyZXBsYWNlIiwiX3VybEluZm8iLCJudWxsT3JpZ2luIiwiaGFzRG9tYWluIiwiaXNTY2hlbWVFcXVhbCIsIl9pciIsIl9yZWNlaXZlSW5mbyIsInVzZXJTZXRDb2RlIiwiQ0xPU0lORyIsIkNMT1NFRCIsIk9QRU4iLCJxdW90ZSIsIl9ydG8iLCJjb3VudFJUTyIsIl90cmFuc1VybCIsImJhc2VfdXJsIiwiZXh0ZW5kIiwiZW5hYmxlZFRyYW5zcG9ydHMiLCJmaWx0ZXJUb0VuYWJsZWQiLCJfdHJhbnNwb3J0cyIsIm1haW4iLCJfY29ubmVjdCIsIlRyYW5zcG9ydCIsInNoaWZ0IiwibmVlZEJvZHkiLCJ1bnNoaWZ0IiwidGltZW91dE1zIiwicm91bmRUcmlwcyIsIl90cmFuc3BvcnRUaW1lb3V0SWQiLCJfdHJhbnNwb3J0VGltZW91dCIsInRyYW5zcG9ydFVybCIsInRyYW5zcG9ydE9iaiIsImNvbnRlbnQiLCJwYXlsb2FkIiwiX29wZW4iLCJmb3JjZUZhaWwiLCJvbm1lc3NhZ2UiLCJvbmNsb3NlIiwib25lcnJvciIsIkFycmF5UHJvdG90eXBlIiwiT2JqZWN0UHJvdG90eXBlIiwiT2JqZWN0IiwiRnVuY3Rpb25Qcm90b3R5cGUiLCJGdW5jdGlvbiIsIlN0cmluZ1Byb3RvdHlwZSIsIlN0cmluZyIsImFycmF5X3NsaWNlIiwiX3RvU3RyaW5nIiwidG9TdHJpbmciLCJpc0Z1bmN0aW9uIiwidmFsIiwib2JqIiwiaXNTdHJpbmciLCJzdXBwb3J0c0Rlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydHkiLCJvYmplY3QiLCJuYW1lIiwibWV0aG9kIiwiZm9yY2VBc3NpZ24iLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwid3JpdGFibGUiLCJ2YWx1ZSIsImRlZmluZVByb3BlcnRpZXMiLCJtYXAiLCJoYXNPd25Qcm9wZXJ0eSIsInRvT2JqZWN0IiwidG9JbnRlZ2VyIiwibnVtIiwiTWF0aCIsImZsb29yIiwiYWJzIiwiVG9VaW50MzIiLCJ4IiwiRW1wdHkiLCJ0aGF0IiwidGFyZ2V0IiwiYmluZGVyIiwiYm91bmQiLCJyZXN1bHQiLCJib3VuZExlbmd0aCIsIm1heCIsImJvdW5kQXJncyIsInB1c2giLCJqb2luIiwiYm94ZWRTdHJpbmciLCJzcGxpdFN0cmluZyIsInByb3Blcmx5Qm94ZXNDb250ZXh0IiwicHJvcGVybHlCb3hlZCIsInByb3Blcmx5Qm94ZXNOb25TdHJpY3QiLCJwcm9wZXJseUJveGVzU3RyaWN0IiwiXyIsIl9fIiwiY29udGV4dCIsImZ1biIsInNwbGl0IiwidGhpc3AiLCJoYXNGaXJlZm94MkluZGV4T2ZCdWciLCJzb3VnaHQiLCJzdHJpbmdfc3BsaXQiLCJjb21wbGlhbnRFeGVjTnBjZyIsImV4ZWMiLCJzZXBhcmF0b3IiLCJsaW1pdCIsIm91dHB1dCIsImZsYWdzIiwiaWdub3JlQ2FzZSIsIm11bHRpbGluZSIsImV4dGVuZGVkIiwic3RpY2t5IiwibGFzdExhc3RJbmRleCIsInNlcGFyYXRvcjIiLCJtYXRjaCIsImxhc3RJbmRleCIsImxhc3RMZW5ndGgiLCJSZWdFeHAiLCJpbmRleCIsInRlc3QiLCJzdHJpbmdfc3Vic3RyIiwic3Vic3RyIiwiaGFzTmVnYXRpdmVTdWJzdHJCdWciLCJzdGFydCIsIlhIUiIsIlhNTEh0dHBSZXF1ZXN0IiwiQWJzdHJhY3RYSFJPYmplY3QiLCJvcHRzIiwiX3N0YXJ0IiwieGhyIiwiYWRkUXVlcnkiLCJ1bmxvYWRSZWYiLCJ1bmxvYWRBZGQiLCJvcGVuIiwib250aW1lb3V0Iiwibm9DcmVkZW50aWFscyIsInN1cHBvcnRzQ09SUyIsIndpdGhDcmVkZW50aWFscyIsImhlYWRlcnMiLCJrZXkiLCJzZXRSZXF1ZXN0SGVhZGVyIiwib25yZWFkeXN0YXRlY2hhbmdlIiwicmVzcG9uc2VUZXh0IiwiYWJvcnQiLCJ1bmxvYWREZWwiLCJheG8iLCJjb3JzIiwiRXZlbnRTb3VyY2UiLCJEcml2ZXIiLCJXZWJTb2NrZXQiLCJNb3pXZWJTb2NrZXQiLCJXZWJTb2NrZXRCcm93c2VyRHJpdmVyIiwidW5kZWZpbmVkIiwiQWpheEJhc2VkVHJhbnNwb3J0IiwiRXZlbnRTb3VyY2VSZWNlaXZlciIsIlhIUkNvcnNPYmplY3QiLCJFdmVudFNvdXJjZURyaXZlciIsIkV2ZW50U291cmNlVHJhbnNwb3J0IiwiSHRtbGZpbGVSZWNlaXZlciIsIkh0bWxGaWxlVHJhbnNwb3J0IiwiaWZyYW1lVXJsIiwiaWZyYW1lT2JqIiwiY3JlYXRlSWZyYW1lIiwib25tZXNzYWdlQ2FsbGJhY2siLCJfbWVzc2FnZSIsImRldGFjaEV2ZW50IiwiY2xlYW51cCIsImxvYWRlZCIsImNkYXRhIiwicG9zdCIsIm1lc3NhZ2UiLCJpZnJhbWVFbmFibGVkIiwiU2VuZGVyUmVjZWl2ZXIiLCJKc29ucFJlY2VpdmVyIiwianNvbnBTZW5kZXIiLCJKc29uUFRyYW5zcG9ydCIsImNyZWF0ZUFqYXhTZW5kZXIiLCJjYWxsYmFjayIsIm9wdCIsImFqYXhVcmwiLCJlcnIiLCJ1cmxTdWZmaXgiLCJSZWNlaXZlciIsIkJ1ZmZlcmVkU2VuZGVyIiwic2VuZGVyIiwic2VuZEJ1ZmZlciIsInNlbmRTdG9wIiwic2VuZFNjaGVkdWxlIiwic2VuZFNjaGVkdWxlV2FpdCIsInRyZWYiLCJJZnJhbWVXcmFwVHJhbnNwb3J0IiwiaWZyYW1lSW5mbyIsIlBvbGxpbmciLCJyZWNlaXZlVXJsIiwiX3NjaGVkdWxlUmVjZWl2ZXIiLCJwb2xsIiwicG9sbElzQ2xvc2luZyIsInNlbmRlckZ1bmMiLCJwb2xsVXJsIiwiZXMiLCJkZWNvZGVVUkkiLCJwb2xsdXRlR2xvYmFsTmFtZXNwYWNlIiwiaWQiLCJkZWNvZGVVUklDb21wb25lbnQiLCJXUHJlZml4IiwiaHRtbGZpbGVFbmFibGVkIiwiY29uc3RydWN0RnVuYyIsImNyZWF0ZUh0bWxmaWxlIiwic3RvcCIsInVybFdpdGhJZCIsImVuY29kZVVSSUNvbXBvbmVudCIsIl9jYWxsYmFjayIsIl9jcmVhdGVTY3JpcHQiLCJ0aW1lb3V0SWQiLCJfYWJvcnQiLCJzY3JpcHRFcnJvclRpbWVvdXQiLCJhYm9ydGluZyIsInNjcmlwdDIiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJzY3JpcHQiLCJvbmxvYWQiLCJvbmNsaWNrIiwiX3NjcmlwdEVycm9yIiwiZXJyb3JUaW1lciIsImxvYWRlZE9rYXkiLCJjcmVhdGVFbGVtZW50Iiwic3JjIiwiY2hhcnNldCIsImh0bWxGb3IiLCJhc3luYyIsImlzT3BlcmEiLCJoZWFkIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJpbnNlcnRCZWZvcmUiLCJmaXJzdENoaWxkIiwiWGhyUmVjZWl2ZXIiLCJidWZmZXJQb3NpdGlvbiIsIl9jaHVua0hhbmRsZXIiLCJidWYiLCJmb3JtIiwiYXJlYSIsImlmcmFtZSIsImNyZWF0ZUZvcm0iLCJzdHlsZSIsImRpc3BsYXkiLCJwb3NpdGlvbiIsImVuY3R5cGUiLCJhY2NlcHRDaGFyc2V0IiwiYXBwZW5kQ2hpbGQiLCJhY3Rpb24iLCJzdWJtaXQiLCJjb21wbGV0ZWQiLCJYRFJPYmplY3QiLCJ4ZHIiLCJYRG9tYWluUmVxdWVzdCIsIl9lcnJvciIsIm9ucHJvZ3Jlc3MiLCJYaHJEcml2ZXIiLCJ0byIsIldlYnNvY2tldERyaXZlciIsIldlYlNvY2tldFRyYW5zcG9ydCIsImlnbm9yZSIsIndzIiwiWGRyU3RyZWFtaW5nVHJhbnNwb3J0IiwiWGRyUG9sbGluZ1RyYW5zcG9ydCIsImNvb2tpZV9uZWVkZWQiLCJYaHJQb2xsaW5nVHJhbnNwb3J0IiwiWGhyU3RyZWFtaW5nVHJhbnNwb3J0IiwiY3J5cHRvIiwiZ2V0UmFuZG9tVmFsdWVzIiwicmFuZG9tQnl0ZXMiLCJieXRlcyIsIlVpbnQ4QXJyYXkiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJpc0tvbnF1ZXJvciIsImRvbWFpbiIsImV4dHJhRXNjYXBhYmxlIiwiZXh0cmFMb29rdXAiLCJ1bnJvbGxMb29rdXAiLCJlc2NhcGFibGUiLCJ1bnJvbGxlZCIsImZyb21DaGFyQ29kZSIsImNoYXJDb2RlQXQiLCJxdW90ZWQiLCJvblVubG9hZCIsImFmdGVyVW5sb2FkIiwiaXNDaHJvbWVQYWNrYWdlZEFwcCIsImNocm9tZSIsImFwcCIsInJ1bnRpbWUiLCJyZWYiLCJ0cmlnZ2VyVW5sb2FkQ2FsbGJhY2tzIiwidW5sb2FkVHJpZ2dlcmVkIiwiZXJyb3JDYWxsYmFjayIsInVuYXR0YWNoIiwiY29udGVudFdpbmRvdyIsImRvYyIsIkNvbGxlY3RHYXJiYWdlIiwid3JpdGUiLCJwYXJlbnRXaW5kb3ciLCJsb2dPYmplY3QiLCJsZXZlbCIsImxldmVsRXhpc3RzIiwiY29uc29sZSIsInByb3AiLCJfcmFuZG9tU3RyaW5nQ2hhcnMiLCJyZXQiLCJudW1iZXIiLCJ0cmFuc3BvcnRzV2hpdGVsaXN0IiwidHJhbnMiLCJ3ZWJzb2NrZXQiLCJob3N0bmFtZSIsImIiLCJyZXMiLCJwYXRoIiwicXMiLCJxIiwiZm9ybWF0QXJncyIsInNhdmUiLCJsb2FkIiwidXNlQ29sb3JzIiwic3RvcmFnZSIsImxvY2FsIiwibG9jYWxzdG9yYWdlIiwiY29sb3JzIiwiZG9jdW1lbnRFbGVtZW50IiwiV2Via2l0QXBwZWFyYW5jZSIsImZpcmVidWciLCJleGNlcHRpb24iLCJ0YWJsZSIsInBhcnNlSW50IiwiJDEiLCJmb3JtYXR0ZXJzIiwiaiIsInYiLCJKU09OIiwibmFtZXNwYWNlIiwiaHVtYW5pemUiLCJkaWZmIiwiY29sb3IiLCJzcGxpY2UiLCJsYXN0QyIsIm5hbWVzcGFjZXMiLCJyZW1vdmVJdGVtIiwiREVCVUciLCJlbmFibGUiLCJsb2NhbFN0b3JhZ2UiLCJjcmVhdGVEZWJ1ZyIsImNvZXJjZSIsImRpc2FibGUiLCJuYW1lcyIsInNraXBzIiwicHJldlRpbWUiLCJzZWxlY3RDb2xvciIsImN1cnIiLCJtcyIsInByZXYiLCJmb3JtYXQiLCJmb3JtYXR0ZXIiLCJsb2dGbiIsImluaXQiLCJsZW4iLCJzdGFjayIsImNyZWF0ZSIsImN0b3IiLCJzdXBlckN0b3IiLCJzdXBlcl8iLCJjb25zdHJ1Y3RvciIsIlRlbXBDdG9yIiwiaXNMb2FkZXIiLCJhbWQiLCJvYmplY3RUeXBlcyIsImZyZWVFeHBvcnRzIiwibm9kZVR5cGUiLCJyb290IiwiZnJlZUdsb2JhbCIsInJ1bkluQ29udGV4dCIsIk51bWJlciIsIm5hdGl2ZUpTT04iLCJvYmplY3RQcm90byIsImdldENsYXNzIiwiaXNQcm9wZXJ0eSIsInVuZGVmIiwiaXNFeHRlbmRlZCIsImdldFVUQ0Z1bGxZZWFyIiwiZ2V0VVRDTW9udGgiLCJnZXRVVENEYXRlIiwiZ2V0VVRDSG91cnMiLCJnZXRVVENNaW51dGVzIiwiZ2V0VVRDU2Vjb25kcyIsImdldFVUQ01pbGxpc2Vjb25kcyIsImhhcyIsImlzU3VwcG9ydGVkIiwic2VyaWFsaXplZCIsInN0cmluZ2lmeVN1cHBvcnRlZCIsInRvSlNPTiIsInBhcnNlU3VwcG9ydGVkIiwiZnVuY3Rpb25DbGFzcyIsImRhdGVDbGFzcyIsIm51bWJlckNsYXNzIiwic3RyaW5nQ2xhc3MiLCJhcnJheUNsYXNzIiwiYm9vbGVhbkNsYXNzIiwiY2hhckluZGV4QnVnZ3kiLCJNb250aHMiLCJnZXREYXkiLCJ5ZWFyIiwibW9udGgiLCJwcm9wZXJ0eSIsIm1lbWJlcnMiLCJfX3Byb3RvX18iLCJvcmlnaW5hbCIsInNpemUiLCJQcm9wZXJ0aWVzIiwidmFsdWVPZiIsImhhc1Byb3BlcnR5IiwiaXNDb25zdHJ1Y3RvciIsIkVzY2FwZXMiLCJsZWFkaW5nWmVyb2VzIiwidG9QYWRkZWRTdHJpbmciLCJ3aWR0aCIsInVuaWNvZGVQcmVmaXgiLCJ1c2VDaGFySW5kZXgiLCJzeW1ib2xzIiwiY2hhckNvZGUiLCJjaGFyQXQiLCJzZXJpYWxpemUiLCJwcm9wZXJ0aWVzIiwid2hpdGVzcGFjZSIsImluZGVudGF0aW9uIiwiY2xhc3NOYW1lIiwiZGF0ZSIsInRpbWUiLCJob3VycyIsIm1pbnV0ZXMiLCJzZWNvbmRzIiwibWlsbGlzZWNvbmRzIiwicmVzdWx0cyIsImVsZW1lbnQiLCJwcmVmaXgiLCJwb3AiLCJmaWx0ZXIiLCJVbmVzY2FwZXMiLCJJbmRleCIsIlNvdXJjZSIsImxleCIsImJlZ2luIiwiaXNTaWduZWQiLCJnZXQiLCJoYXNNZW1iZXJzIiwidXBkYXRlIiwid2FsayIsInByZXZpb3VzSlNPTiIsImlzUmVzdG9yZWQiLCJzIiwibSIsImgiLCJ5IiwiaXNOYU4iLCJsb25nIiwiZm10TG9uZyIsImZtdFNob3J0Iiwic3RyIiwicGFyc2VGbG9hdCIsInJvdW5kIiwicGx1cmFsIiwiY2VpbCIsImRlY29kZSIsImlucHV0IiwicXVlcnlzdHJpbmciLCJxdWVyeSIsInBhcnNlciIsInBhcnQiLCJxdWVyeXN0cmluZ2lmeSIsInBhaXJzIiwicmVxdWlyZWQiLCJwcm90b2NvbHJlIiwic2xhc2hlcyIsInJ1bGVzIiwiTmFOIiwibG9sY2F0aW9uIiwiZmluYWxkZXN0aW5hdGlvbiIsInVuZXNjYXBlIiwiZXh0cmFjdFByb3RvY29sIiwiYWRkcmVzcyIsInJlc3QiLCJyZXNvbHZlIiwicmVsYXRpdmUiLCJiYXNlIiwibGFzdCIsInVwIiwiZXh0cmFjdGVkIiwiaW5zdHJ1Y3Rpb24iLCJpbnN0cnVjdGlvbnMiLCJ1c2VybmFtZSIsInBhc3N3b3JkIiwiYXV0aCIsImZuIiwiY2hhciIsImlucyJd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Z0IsU0FBZjtBQUNBbmdCLFlBQUk4VixFQUFKLEdBQVNBLEVBQVQ7O0FBRUFuZ0IsZUFBT0MsT0FBUCxHQUFpQm9LLEdBQWpCO0FBRUMsT0E5WkQsRUE4WkdySixJQTlaSCxDQThaUSxJQTlaUixFQThaYSxPQUFPRSxNQUFQLEtBQWtCLFdBQWxCLEdBQWdDQSxNQUFoQyxHQUF5QyxPQUFPSSxJQUFQLEtBQWdCLFdBQWhCLEdBQThCQSxJQUE5QixHQUFxQyxPQUFPQyxNQUFQLEtBQWtCLFdBQWxCLEdBQWdDQSxNQUFoQyxHQUF5QyxFQTlacEk7QUFnYUMsS0FqYVEsRUFpYVAsRUFBQyxrQkFBaUIsRUFBbEIsRUFBcUIsaUJBQWdCLEVBQXJDLEVBamFPLENBanRLaXpCLEVBQTVjLEVBa25MalUsRUFsbkxpVSxFQWtuTDlULENBQUMsQ0FBRCxDQWxuTDhULEVBa25MelQsQ0Fsbkx5VCxDQUFQO0FBbW5MdFcsQ0FubkxEOztBQXNuTEEsa0MiLCJmaWxlIjoiMTUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBzb2NranMtY2xpZW50IHYxLjEuNSB8IGh0dHA6Ly9zb2NranMub3JnIHwgTUlUIGxpY2Vuc2UgKi9cclxuKGZ1bmN0aW9uKGYpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIiYmdHlwZW9mIG1vZHVsZSE9PVwidW5kZWZpbmVkXCIpe21vZHVsZS5leHBvcnRzPWYoKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXSxmKX1lbHNle3ZhciBnO2lmKHR5cGVvZiB3aW5kb3chPT1cInVuZGVmaW5lZFwiKXtnPXdpbmRvd31lbHNlIGlmKHR5cGVvZiBnbG9iYWwhPT1cInVuZGVmaW5lZFwiKXtnPWdsb2JhbH1lbHNlIGlmKHR5cGVvZiBzZWxmIT09XCJ1bmRlZmluZWRcIil7Zz1zZWxmfWVsc2V7Zz10aGlzfWcuU29ja0pTID0gZigpfX0pKGZ1bmN0aW9uKCl7dmFyIGRlZmluZSxtb2R1bGUsZXhwb3J0cztyZXR1cm4gKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSh7MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbihmdW5jdGlvbiAoZ2xvYmFsKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIHRyYW5zcG9ydExpc3QgPSByZXF1aXJlKCcuL3RyYW5zcG9ydC1saXN0Jyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbWFpbicpKHRyYW5zcG9ydExpc3QpO1xyXG5cclxuLy8gVE9ETyBjYW4ndCBnZXQgcmlkIG9mIHRoaXMgdW50aWwgYWxsIHNlcnZlcnMgZG9cclxuaWYgKCdfc29ja2pzX29ubG9hZCcgaW4gZ2xvYmFsKSB7XHJcbiAgc2V0VGltZW91dChnbG9iYWwuX3NvY2tqc19vbmxvYWQsIDEpO1xyXG59XHJcblxyXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcclxuXHJcbn0se1wiLi9tYWluXCI6MTQsXCIuL3RyYW5zcG9ydC1saXN0XCI6MTZ9XSwyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxyXG4gICwgRXZlbnQgPSByZXF1aXJlKCcuL2V2ZW50JylcclxuICA7XHJcblxyXG5mdW5jdGlvbiBDbG9zZUV2ZW50KCkge1xyXG4gIEV2ZW50LmNhbGwodGhpcyk7XHJcbiAgdGhpcy5pbml0RXZlbnQoJ2Nsb3NlJywgZmFsc2UsIGZhbHNlKTtcclxuICB0aGlzLndhc0NsZWFuID0gZmFsc2U7XHJcbiAgdGhpcy5jb2RlID0gMDtcclxuICB0aGlzLnJlYXNvbiA9ICcnO1xyXG59XHJcblxyXG5pbmhlcml0cyhDbG9zZUV2ZW50LCBFdmVudCk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENsb3NlRXZlbnQ7XHJcblxyXG59LHtcIi4vZXZlbnRcIjo0LFwiaW5oZXJpdHNcIjo1Nn1dLDM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXHJcbiAgLCBFdmVudFRhcmdldCA9IHJlcXVpcmUoJy4vZXZlbnR0YXJnZXQnKVxyXG4gIDtcclxuXHJcbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcclxuICBFdmVudFRhcmdldC5jYWxsKHRoaXMpO1xyXG59XHJcblxyXG5pbmhlcml0cyhFdmVudEVtaXR0ZXIsIEV2ZW50VGFyZ2V0KTtcclxuXHJcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xyXG4gIGlmICh0eXBlKSB7XHJcbiAgICBkZWxldGUgdGhpcy5fbGlzdGVuZXJzW3R5cGVdO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcclxuICB9XHJcbn07XHJcblxyXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xyXG4gIHZhciBzZWxmID0gdGhpc1xyXG4gICAgLCBmaXJlZCA9IGZhbHNlO1xyXG5cclxuICBmdW5jdGlvbiBnKCkge1xyXG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcclxuXHJcbiAgICBpZiAoIWZpcmVkKSB7XHJcbiAgICAgIGZpcmVkID0gdHJ1ZTtcclxuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHRoaXMub24odHlwZSwgZyk7XHJcbn07XHJcblxyXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbigpIHtcclxuICB2YXIgdHlwZSA9IGFyZ3VtZW50c1swXTtcclxuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzW3R5cGVdO1xyXG4gIGlmICghbGlzdGVuZXJzKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIC8vIGVxdWl2YWxlbnQgb2YgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuICB2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XHJcbiAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkobCAtIDEpO1xyXG4gIGZvciAodmFyIGFpID0gMTsgYWkgPCBsOyBhaSsrKSB7XHJcbiAgICBhcmdzW2FpIC0gMV0gPSBhcmd1bWVudHNbYWldO1xyXG4gIH1cclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gIH1cclxufTtcclxuXHJcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gRXZlbnRUYXJnZXQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXI7XHJcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBFdmVudFRhcmdldC5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lcjtcclxuXHJcbm1vZHVsZS5leHBvcnRzLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcclxuXHJcbn0se1wiLi9ldmVudHRhcmdldFwiOjUsXCJpbmhlcml0c1wiOjU2fV0sNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbmZ1bmN0aW9uIEV2ZW50KGV2ZW50VHlwZSkge1xyXG4gIHRoaXMudHlwZSA9IGV2ZW50VHlwZTtcclxufVxyXG5cclxuRXZlbnQucHJvdG90eXBlLmluaXRFdmVudCA9IGZ1bmN0aW9uKGV2ZW50VHlwZSwgY2FuQnViYmxlLCBjYW5jZWxhYmxlKSB7XHJcbiAgdGhpcy50eXBlID0gZXZlbnRUeXBlO1xyXG4gIHRoaXMuYnViYmxlcyA9IGNhbkJ1YmJsZTtcclxuICB0aGlzLmNhbmNlbGFibGUgPSBjYW5jZWxhYmxlO1xyXG4gIHRoaXMudGltZVN0YW1wID0gK25ldyBEYXRlKCk7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5FdmVudC5wcm90b3R5cGUuc3RvcFByb3BhZ2F0aW9uID0gZnVuY3Rpb24oKSB7fTtcclxuRXZlbnQucHJvdG90eXBlLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24oKSB7fTtcclxuXHJcbkV2ZW50LkNBUFRVUklOR19QSEFTRSA9IDE7XHJcbkV2ZW50LkFUX1RBUkdFVCA9IDI7XHJcbkV2ZW50LkJVQkJMSU5HX1BIQVNFID0gMztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRXZlbnQ7XHJcblxyXG59LHt9XSw1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuLyogU2ltcGxpZmllZCBpbXBsZW1lbnRhdGlvbiBvZiBET00yIEV2ZW50VGFyZ2V0LlxyXG4gKiAgIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0yLUV2ZW50cy9ldmVudHMuaHRtbCNFdmVudHMtRXZlbnRUYXJnZXRcclxuICovXHJcblxyXG5mdW5jdGlvbiBFdmVudFRhcmdldCgpIHtcclxuICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcclxufVxyXG5cclxuRXZlbnRUYXJnZXQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudFR5cGUsIGxpc3RlbmVyKSB7XHJcbiAgaWYgKCEoZXZlbnRUeXBlIGluIHRoaXMuX2xpc3RlbmVycykpIHtcclxuICAgIHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdID0gW107XHJcbiAgfVxyXG4gIHZhciBhcnIgPSB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXTtcclxuICAvLyAjNFxyXG4gIGlmIChhcnIuaW5kZXhPZihsaXN0ZW5lcikgPT09IC0xKSB7XHJcbiAgICAvLyBNYWtlIGEgY29weSBzbyBhcyBub3QgdG8gaW50ZXJmZXJlIHdpdGggYSBjdXJyZW50IGRpc3BhdGNoRXZlbnQuXHJcbiAgICBhcnIgPSBhcnIuY29uY2F0KFtsaXN0ZW5lcl0pO1xyXG4gIH1cclxuICB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXSA9IGFycjtcclxufTtcclxuXHJcbkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnRUeXBlLCBsaXN0ZW5lcikge1xyXG4gIHZhciBhcnIgPSB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXTtcclxuICBpZiAoIWFycikge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICB2YXIgaWR4ID0gYXJyLmluZGV4T2YobGlzdGVuZXIpO1xyXG4gIGlmIChpZHggIT09IC0xKSB7XHJcbiAgICBpZiAoYXJyLmxlbmd0aCA+IDEpIHtcclxuICAgICAgLy8gTWFrZSBhIGNvcHkgc28gYXMgbm90IHRvIGludGVyZmVyZSB3aXRoIGEgY3VycmVudCBkaXNwYXRjaEV2ZW50LlxyXG4gICAgICB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXSA9IGFyci5zbGljZSgwLCBpZHgpLmNvbmNhdChhcnIuc2xpY2UoaWR4ICsgMSkpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZGVsZXRlIHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxufTtcclxuXHJcbkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24oKSB7XHJcbiAgdmFyIGV2ZW50ID0gYXJndW1lbnRzWzBdO1xyXG4gIHZhciB0ID0gZXZlbnQudHlwZTtcclxuICAvLyBlcXVpdmFsZW50IG9mIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XHJcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gW2V2ZW50XSA6IEFycmF5LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcbiAgLy8gVE9ETzogVGhpcyBkb2Vzbid0IG1hdGNoIHRoZSByZWFsIGJlaGF2aW9yOyBwZXIgc3BlYywgb25mb28gZ2V0XHJcbiAgLy8gdGhlaXIgcGxhY2UgaW4gbGluZSBmcm9tIHRoZSAvZmlyc3QvIHRpbWUgdGhleSdyZSBzZXQgZnJvbVxyXG4gIC8vIG5vbi1udWxsLiBBbHRob3VnaCBXZWJLaXQgYnVtcHMgaXQgdG8gdGhlIGVuZCBldmVyeSB0aW1lIGl0J3NcclxuICAvLyBzZXQuXHJcbiAgaWYgKHRoaXNbJ29uJyArIHRdKSB7XHJcbiAgICB0aGlzWydvbicgKyB0XS5hcHBseSh0aGlzLCBhcmdzKTtcclxuICB9XHJcbiAgaWYgKHQgaW4gdGhpcy5fbGlzdGVuZXJzKSB7XHJcbiAgICAvLyBHcmFiIGEgcmVmZXJlbmNlIHRvIHRoZSBsaXN0ZW5lcnMgbGlzdC4gcmVtb3ZlRXZlbnRMaXN0ZW5lciBtYXkgYWx0ZXIgdGhlIGxpc3QuXHJcbiAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzW3RdO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRXZlbnRUYXJnZXQ7XHJcblxyXG59LHt9XSw2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxyXG4gICwgRXZlbnQgPSByZXF1aXJlKCcuL2V2ZW50JylcclxuICA7XHJcblxyXG5mdW5jdGlvbiBUcmFuc3BvcnRNZXNzYWdlRXZlbnQoZGF0YSkge1xyXG4gIEV2ZW50LmNhbGwodGhpcyk7XHJcbiAgdGhpcy5pbml0RXZlbnQoJ21lc3NhZ2UnLCBmYWxzZSwgZmFsc2UpO1xyXG4gIHRoaXMuZGF0YSA9IGRhdGE7XHJcbn1cclxuXHJcbmluaGVyaXRzKFRyYW5zcG9ydE1lc3NhZ2VFdmVudCwgRXZlbnQpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc3BvcnRNZXNzYWdlRXZlbnQ7XHJcblxyXG59LHtcIi4vZXZlbnRcIjo0LFwiaW5oZXJpdHNcIjo1Nn1dLDc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpXHJcbiAgLCBpZnJhbWVVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvaWZyYW1lJylcclxuICA7XHJcblxyXG5mdW5jdGlvbiBGYWNhZGVKUyh0cmFuc3BvcnQpIHtcclxuICB0aGlzLl90cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XHJcbiAgdHJhbnNwb3J0Lm9uKCdtZXNzYWdlJywgdGhpcy5fdHJhbnNwb3J0TWVzc2FnZS5iaW5kKHRoaXMpKTtcclxuICB0cmFuc3BvcnQub24oJ2Nsb3NlJywgdGhpcy5fdHJhbnNwb3J0Q2xvc2UuYmluZCh0aGlzKSk7XHJcbn1cclxuXHJcbkZhY2FkZUpTLnByb3RvdHlwZS5fdHJhbnNwb3J0Q2xvc2UgPSBmdW5jdGlvbihjb2RlLCByZWFzb24pIHtcclxuICBpZnJhbWVVdGlscy5wb3N0TWVzc2FnZSgnYycsIEpTT04zLnN0cmluZ2lmeShbY29kZSwgcmVhc29uXSkpO1xyXG59O1xyXG5GYWNhZGVKUy5wcm90b3R5cGUuX3RyYW5zcG9ydE1lc3NhZ2UgPSBmdW5jdGlvbihmcmFtZSkge1xyXG4gIGlmcmFtZVV0aWxzLnBvc3RNZXNzYWdlKCd0JywgZnJhbWUpO1xyXG59O1xyXG5GYWNhZGVKUy5wcm90b3R5cGUuX3NlbmQgPSBmdW5jdGlvbihkYXRhKSB7XHJcbiAgdGhpcy5fdHJhbnNwb3J0LnNlbmQoZGF0YSk7XHJcbn07XHJcbkZhY2FkZUpTLnByb3RvdHlwZS5fY2xvc2UgPSBmdW5jdGlvbigpIHtcclxuICB0aGlzLl90cmFuc3BvcnQuY2xvc2UoKTtcclxuICB0aGlzLl90cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEZhY2FkZUpTO1xyXG5cclxufSx7XCIuL3V0aWxzL2lmcmFtZVwiOjQ3LFwianNvbjNcIjo1N31dLDg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgdXJsVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL3VybCcpXHJcbiAgLCBldmVudFV0aWxzID0gcmVxdWlyZSgnLi91dGlscy9ldmVudCcpXHJcbiAgLCBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJylcclxuICAsIEZhY2FkZUpTID0gcmVxdWlyZSgnLi9mYWNhZGUnKVxyXG4gICwgSW5mb0lmcmFtZVJlY2VpdmVyID0gcmVxdWlyZSgnLi9pbmZvLWlmcmFtZS1yZWNlaXZlcicpXHJcbiAgLCBpZnJhbWVVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvaWZyYW1lJylcclxuICAsIGxvYyA9IHJlcXVpcmUoJy4vbG9jYXRpb24nKVxyXG4gIDtcclxuXHJcbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XHJcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OmlmcmFtZS1ib290c3RyYXAnKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihTb2NrSlMsIGF2YWlsYWJsZVRyYW5zcG9ydHMpIHtcclxuICB2YXIgdHJhbnNwb3J0TWFwID0ge307XHJcbiAgYXZhaWxhYmxlVHJhbnNwb3J0cy5mb3JFYWNoKGZ1bmN0aW9uKGF0KSB7XHJcbiAgICBpZiAoYXQuZmFjYWRlVHJhbnNwb3J0KSB7XHJcbiAgICAgIHRyYW5zcG9ydE1hcFthdC5mYWNhZGVUcmFuc3BvcnQudHJhbnNwb3J0TmFtZV0gPSBhdC5mYWNhZGVUcmFuc3BvcnQ7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIC8vIGhhcmQtY29kZWQgZm9yIHRoZSBpbmZvIGlmcmFtZVxyXG4gIC8vIFRPRE8gc2VlIGlmIHdlIGNhbiBtYWtlIHRoaXMgbW9yZSBkeW5hbWljXHJcbiAgdHJhbnNwb3J0TWFwW0luZm9JZnJhbWVSZWNlaXZlci50cmFuc3BvcnROYW1lXSA9IEluZm9JZnJhbWVSZWNlaXZlcjtcclxuICB2YXIgcGFyZW50T3JpZ2luO1xyXG5cclxuICAvKiBlc2xpbnQtZGlzYWJsZSBjYW1lbGNhc2UgKi9cclxuICBTb2NrSlMuYm9vdHN0cmFwX2lmcmFtZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgLyogZXNsaW50LWVuYWJsZSBjYW1lbGNhc2UgKi9cclxuICAgIHZhciBmYWNhZGU7XHJcbiAgICBpZnJhbWVVdGlscy5jdXJyZW50V2luZG93SWQgPSBsb2MuaGFzaC5zbGljZSgxKTtcclxuICAgIHZhciBvbk1lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XHJcbiAgICAgIGlmIChlLnNvdXJjZSAhPT0gcGFyZW50KSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0eXBlb2YgcGFyZW50T3JpZ2luID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHBhcmVudE9yaWdpbiA9IGUub3JpZ2luO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChlLm9yaWdpbiAhPT0gcGFyZW50T3JpZ2luKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgaWZyYW1lTWVzc2FnZTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBpZnJhbWVNZXNzYWdlID0gSlNPTjMucGFyc2UoZS5kYXRhKTtcclxuICAgICAgfSBjYXRjaCAoaWdub3JlZCkge1xyXG4gICAgICAgIGRlYnVnKCdiYWQganNvbicsIGUuZGF0YSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoaWZyYW1lTWVzc2FnZS53aW5kb3dJZCAhPT0gaWZyYW1lVXRpbHMuY3VycmVudFdpbmRvd0lkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHN3aXRjaCAoaWZyYW1lTWVzc2FnZS50eXBlKSB7XHJcbiAgICAgIGNhc2UgJ3MnOlxyXG4gICAgICAgIHZhciBwO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBwID0gSlNPTjMucGFyc2UoaWZyYW1lTWVzc2FnZS5kYXRhKTtcclxuICAgICAgICB9IGNhdGNoIChpZ25vcmVkKSB7XHJcbiAgICAgICAgICBkZWJ1ZygnYmFkIGpzb24nLCBpZnJhbWVNZXNzYWdlLmRhdGEpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB2ZXJzaW9uID0gcFswXTtcclxuICAgICAgICB2YXIgdHJhbnNwb3J0ID0gcFsxXTtcclxuICAgICAgICB2YXIgdHJhbnNVcmwgPSBwWzJdO1xyXG4gICAgICAgIHZhciBiYXNlVXJsID0gcFszXTtcclxuICAgICAgICBkZWJ1Zyh2ZXJzaW9uLCB0cmFuc3BvcnQsIHRyYW5zVXJsLCBiYXNlVXJsKTtcclxuICAgICAgICAvLyBjaGFuZ2UgdGhpcyB0byBzZW12ZXIgbG9naWNcclxuICAgICAgICBpZiAodmVyc2lvbiAhPT0gU29ja0pTLnZlcnNpb24pIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb21wYXRpYmxlIFNvY2tKUyEgTWFpbiBzaXRlIHVzZXM6JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJyBcIicgKyB2ZXJzaW9uICsgJ1wiLCB0aGUgaWZyYW1lOicgK1xyXG4gICAgICAgICAgICAgICAgICAgICcgXCInICsgU29ja0pTLnZlcnNpb24gKyAnXCIuJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIXVybFV0aWxzLmlzT3JpZ2luRXF1YWwodHJhbnNVcmwsIGxvYy5ocmVmKSB8fFxyXG4gICAgICAgICAgICAhdXJsVXRpbHMuaXNPcmlnaW5FcXVhbChiYXNlVXJsLCBsb2MuaHJlZikpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCBjb25uZWN0IHRvIGRpZmZlcmVudCBkb21haW4gZnJvbSB3aXRoaW4gYW4gJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJ2lmcmFtZS4gKCcgKyBsb2MuaHJlZiArICcsICcgKyB0cmFuc1VybCArICcsICcgKyBiYXNlVXJsICsgJyknKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmFjYWRlID0gbmV3IEZhY2FkZUpTKG5ldyB0cmFuc3BvcnRNYXBbdHJhbnNwb3J0XSh0cmFuc1VybCwgYmFzZVVybCkpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdtJzpcclxuICAgICAgICBmYWNhZGUuX3NlbmQoaWZyYW1lTWVzc2FnZS5kYXRhKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnYyc6XHJcbiAgICAgICAgaWYgKGZhY2FkZSkge1xyXG4gICAgICAgICAgZmFjYWRlLl9jbG9zZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmYWNhZGUgPSBudWxsO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGV2ZW50VXRpbHMuYXR0YWNoRXZlbnQoJ21lc3NhZ2UnLCBvbk1lc3NhZ2UpO1xyXG5cclxuICAgIC8vIFN0YXJ0XHJcbiAgICBpZnJhbWVVdGlscy5wb3N0TWVzc2FnZSgncycpO1xyXG4gIH07XHJcbn07XHJcblxyXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXHJcblxyXG59LHtcIi4vZmFjYWRlXCI6NyxcIi4vaW5mby1pZnJhbWUtcmVjZWl2ZXJcIjoxMCxcIi4vbG9jYXRpb25cIjoxMyxcIi4vdXRpbHMvZXZlbnRcIjo0NixcIi4vdXRpbHMvaWZyYW1lXCI6NDcsXCIuL3V0aWxzL3VybFwiOjUyLFwiZGVidWdcIjo1NCxcImpzb24zXCI6NTd9XSw5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuKGZ1bmN0aW9uIChwcm9jZXNzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxyXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXHJcbiAgLCBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJylcclxuICAsIG9iamVjdFV0aWxzID0gcmVxdWlyZSgnLi91dGlscy9vYmplY3QnKVxyXG4gIDtcclxuXHJcbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XHJcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OmluZm8tYWpheCcpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBJbmZvQWpheCh1cmwsIEFqYXhPYmplY3QpIHtcclxuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcclxuXHJcbiAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gIHZhciB0MCA9ICtuZXcgRGF0ZSgpO1xyXG4gIHRoaXMueG8gPSBuZXcgQWpheE9iamVjdCgnR0VUJywgdXJsKTtcclxuXHJcbiAgdGhpcy54by5vbmNlKCdmaW5pc2gnLCBmdW5jdGlvbihzdGF0dXMsIHRleHQpIHtcclxuICAgIHZhciBpbmZvLCBydHQ7XHJcbiAgICBpZiAoc3RhdHVzID09PSAyMDApIHtcclxuICAgICAgcnR0ID0gKCtuZXcgRGF0ZSgpKSAtIHQwO1xyXG4gICAgICBpZiAodGV4dCkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBpbmZvID0gSlNPTjMucGFyc2UodGV4dCk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgZGVidWcoJ2JhZCBqc29uJywgdGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIW9iamVjdFV0aWxzLmlzT2JqZWN0KGluZm8pKSB7XHJcbiAgICAgICAgaW5mbyA9IHt9O1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcsIGluZm8sIHJ0dCk7XHJcbiAgICBzZWxmLnJlbW92ZUFsbExpc3RlbmVycygpO1xyXG4gIH0pO1xyXG59XHJcblxyXG5pbmhlcml0cyhJbmZvQWpheCwgRXZlbnRFbWl0dGVyKTtcclxuXHJcbkluZm9BamF4LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xyXG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XHJcbiAgdGhpcy54by5jbG9zZSgpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJbmZvQWpheDtcclxuXHJcbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcclxuXHJcbn0se1wiLi91dGlscy9vYmplY3RcIjo0OSxcImRlYnVnXCI6NTQsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1NixcImpzb24zXCI6NTd9XSwxMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcclxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxyXG4gICwgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpXHJcbiAgLCBYSFJMb2NhbE9iamVjdCA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0L3NlbmRlci94aHItbG9jYWwnKVxyXG4gICwgSW5mb0FqYXggPSByZXF1aXJlKCcuL2luZm8tYWpheCcpXHJcbiAgO1xyXG5cclxuZnVuY3Rpb24gSW5mb1JlY2VpdmVySWZyYW1lKHRyYW5zVXJsKSB7XHJcbiAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xyXG5cclxuICB0aGlzLmlyID0gbmV3IEluZm9BamF4KHRyYW5zVXJsLCBYSFJMb2NhbE9iamVjdCk7XHJcbiAgdGhpcy5pci5vbmNlKCdmaW5pc2gnLCBmdW5jdGlvbihpbmZvLCBydHQpIHtcclxuICAgIHNlbGYuaXIgPSBudWxsO1xyXG4gICAgc2VsZi5lbWl0KCdtZXNzYWdlJywgSlNPTjMuc3RyaW5naWZ5KFtpbmZvLCBydHRdKSk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbmluaGVyaXRzKEluZm9SZWNlaXZlcklmcmFtZSwgRXZlbnRFbWl0dGVyKTtcclxuXHJcbkluZm9SZWNlaXZlcklmcmFtZS50cmFuc3BvcnROYW1lID0gJ2lmcmFtZS1pbmZvLXJlY2VpdmVyJztcclxuXHJcbkluZm9SZWNlaXZlcklmcmFtZS5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcclxuICBpZiAodGhpcy5pcikge1xyXG4gICAgdGhpcy5pci5jbG9zZSgpO1xyXG4gICAgdGhpcy5pciA9IG51bGw7XHJcbiAgfVxyXG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEluZm9SZWNlaXZlcklmcmFtZTtcclxuXHJcbn0se1wiLi9pbmZvLWFqYXhcIjo5LFwiLi90cmFuc3BvcnQvc2VuZGVyL3hoci1sb2NhbFwiOjM3LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTYsXCJqc29uM1wiOjU3fV0sMTE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxyXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXHJcbiAgLCBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJylcclxuICAsIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscy9ldmVudCcpXHJcbiAgLCBJZnJhbWVUcmFuc3BvcnQgPSByZXF1aXJlKCcuL3RyYW5zcG9ydC9pZnJhbWUnKVxyXG4gICwgSW5mb1JlY2VpdmVySWZyYW1lID0gcmVxdWlyZSgnLi9pbmZvLWlmcmFtZS1yZWNlaXZlcicpXHJcbiAgO1xyXG5cclxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcclxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6aW5mby1pZnJhbWUnKTtcclxufVxyXG5cclxuZnVuY3Rpb24gSW5mb0lmcmFtZShiYXNlVXJsLCB1cmwpIHtcclxuICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XHJcblxyXG4gIHZhciBnbyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIGlmciA9IHNlbGYuaWZyID0gbmV3IElmcmFtZVRyYW5zcG9ydChJbmZvUmVjZWl2ZXJJZnJhbWUudHJhbnNwb3J0TmFtZSwgdXJsLCBiYXNlVXJsKTtcclxuXHJcbiAgICBpZnIub25jZSgnbWVzc2FnZScsIGZ1bmN0aW9uKG1zZykge1xyXG4gICAgICBpZiAobXNnKSB7XHJcbiAgICAgICAgdmFyIGQ7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGQgPSBKU09OMy5wYXJzZShtc2cpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgIGRlYnVnKCdiYWQganNvbicsIG1zZyk7XHJcbiAgICAgICAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcpO1xyXG4gICAgICAgICAgc2VsZi5jbG9zZSgpO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGluZm8gPSBkWzBdLCBydHQgPSBkWzFdO1xyXG4gICAgICAgIHNlbGYuZW1pdCgnZmluaXNoJywgaW5mbywgcnR0KTtcclxuICAgICAgfVxyXG4gICAgICBzZWxmLmNsb3NlKCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpZnIub25jZSgnY2xvc2UnLCBmdW5jdGlvbigpIHtcclxuICAgICAgc2VsZi5lbWl0KCdmaW5pc2gnKTtcclxuICAgICAgc2VsZi5jbG9zZSgpO1xyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgLy8gVE9ETyB0aGlzIHNlZW1zIHRoZSBzYW1lIGFzIHRoZSAnbmVlZEJvZHknIGZyb20gdHJhbnNwb3J0c1xyXG4gIGlmICghZ2xvYmFsLmRvY3VtZW50LmJvZHkpIHtcclxuICAgIHV0aWxzLmF0dGFjaEV2ZW50KCdsb2FkJywgZ28pO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBnbygpO1xyXG4gIH1cclxufVxyXG5cclxuaW5oZXJpdHMoSW5mb0lmcmFtZSwgRXZlbnRFbWl0dGVyKTtcclxuXHJcbkluZm9JZnJhbWUuZW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xyXG4gIHJldHVybiBJZnJhbWVUcmFuc3BvcnQuZW5hYmxlZCgpO1xyXG59O1xyXG5cclxuSW5mb0lmcmFtZS5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcclxuICBpZiAodGhpcy5pZnIpIHtcclxuICAgIHRoaXMuaWZyLmNsb3NlKCk7XHJcbiAgfVxyXG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XHJcbiAgdGhpcy5pZnIgPSBudWxsO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJbmZvSWZyYW1lO1xyXG5cclxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9LHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXHJcblxyXG59LHtcIi4vaW5mby1pZnJhbWUtcmVjZWl2ZXJcIjoxMCxcIi4vdHJhbnNwb3J0L2lmcmFtZVwiOjIyLFwiLi91dGlscy9ldmVudFwiOjQ2LFwiZGVidWdcIjo1NCxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU2LFwianNvbjNcIjo1N31dLDEyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuKGZ1bmN0aW9uIChwcm9jZXNzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxyXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXHJcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvdXJsJylcclxuICAsIFhEUiA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0L3NlbmRlci94ZHInKVxyXG4gICwgWEhSQ29ycyA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0L3NlbmRlci94aHItY29ycycpXHJcbiAgLCBYSFJMb2NhbCA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0L3NlbmRlci94aHItbG9jYWwnKVxyXG4gICwgWEhSRmFrZSA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0L3NlbmRlci94aHItZmFrZScpXHJcbiAgLCBJbmZvSWZyYW1lID0gcmVxdWlyZSgnLi9pbmZvLWlmcmFtZScpXHJcbiAgLCBJbmZvQWpheCA9IHJlcXVpcmUoJy4vaW5mby1hamF4JylcclxuICA7XHJcblxyXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xyXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDppbmZvLXJlY2VpdmVyJyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIEluZm9SZWNlaXZlcihiYXNlVXJsLCB1cmxJbmZvKSB7XHJcbiAgZGVidWcoYmFzZVVybCk7XHJcbiAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xyXG5cclxuICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgc2VsZi5kb1hocihiYXNlVXJsLCB1cmxJbmZvKTtcclxuICB9LCAwKTtcclxufVxyXG5cclxuaW5oZXJpdHMoSW5mb1JlY2VpdmVyLCBFdmVudEVtaXR0ZXIpO1xyXG5cclxuLy8gVE9ETyB0aGlzIGlzIGN1cnJlbnRseSBpZ25vcmluZyB0aGUgbGlzdCBvZiBhdmFpbGFibGUgdHJhbnNwb3J0cyBhbmQgdGhlIHdoaXRlbGlzdFxyXG5cclxuSW5mb1JlY2VpdmVyLl9nZXRSZWNlaXZlciA9IGZ1bmN0aW9uKGJhc2VVcmwsIHVybCwgdXJsSW5mbykge1xyXG4gIC8vIGRldGVybWluZSBtZXRob2Qgb2YgQ09SUyBzdXBwb3J0IChpZiBuZWVkZWQpXHJcbiAgaWYgKHVybEluZm8uc2FtZU9yaWdpbikge1xyXG4gICAgcmV0dXJuIG5ldyBJbmZvQWpheCh1cmwsIFhIUkxvY2FsKTtcclxuICB9XHJcbiAgaWYgKFhIUkNvcnMuZW5hYmxlZCkge1xyXG4gICAgcmV0dXJuIG5ldyBJbmZvQWpheCh1cmwsIFhIUkNvcnMpO1xyXG4gIH1cclxuICBpZiAoWERSLmVuYWJsZWQgJiYgdXJsSW5mby5zYW1lU2NoZW1lKSB7XHJcbiAgICByZXR1cm4gbmV3IEluZm9BamF4KHVybCwgWERSKTtcclxuICB9XHJcbiAgaWYgKEluZm9JZnJhbWUuZW5hYmxlZCgpKSB7XHJcbiAgICByZXR1cm4gbmV3IEluZm9JZnJhbWUoYmFzZVVybCwgdXJsKTtcclxuICB9XHJcbiAgcmV0dXJuIG5ldyBJbmZvQWpheCh1cmwsIFhIUkZha2UpO1xyXG59O1xyXG5cclxuSW5mb1JlY2VpdmVyLnByb3RvdHlwZS5kb1hociA9IGZ1bmN0aW9uKGJhc2VVcmwsIHVybEluZm8pIHtcclxuICB2YXIgc2VsZiA9IHRoaXNcclxuICAgICwgdXJsID0gdXJsVXRpbHMuYWRkUGF0aChiYXNlVXJsLCAnL2luZm8nKVxyXG4gICAgO1xyXG4gIGRlYnVnKCdkb1hocicsIHVybCk7XHJcblxyXG4gIHRoaXMueG8gPSBJbmZvUmVjZWl2ZXIuX2dldFJlY2VpdmVyKGJhc2VVcmwsIHVybCwgdXJsSW5mbyk7XHJcblxyXG4gIHRoaXMudGltZW91dFJlZiA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICBkZWJ1ZygndGltZW91dCcpO1xyXG4gICAgc2VsZi5fY2xlYW51cChmYWxzZSk7XHJcbiAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcpO1xyXG4gIH0sIEluZm9SZWNlaXZlci50aW1lb3V0KTtcclxuXHJcbiAgdGhpcy54by5vbmNlKCdmaW5pc2gnLCBmdW5jdGlvbihpbmZvLCBydHQpIHtcclxuICAgIGRlYnVnKCdmaW5pc2gnLCBpbmZvLCBydHQpO1xyXG4gICAgc2VsZi5fY2xlYW51cCh0cnVlKTtcclxuICAgIHNlbGYuZW1pdCgnZmluaXNoJywgaW5mbywgcnR0KTtcclxuICB9KTtcclxufTtcclxuXHJcbkluZm9SZWNlaXZlci5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbih3YXNDbGVhbikge1xyXG4gIGRlYnVnKCdfY2xlYW51cCcpO1xyXG4gIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRSZWYpO1xyXG4gIHRoaXMudGltZW91dFJlZiA9IG51bGw7XHJcbiAgaWYgKCF3YXNDbGVhbiAmJiB0aGlzLnhvKSB7XHJcbiAgICB0aGlzLnhvLmNsb3NlKCk7XHJcbiAgfVxyXG4gIHRoaXMueG8gPSBudWxsO1xyXG59O1xyXG5cclxuSW5mb1JlY2VpdmVyLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xyXG4gIGRlYnVnKCdjbG9zZScpO1xyXG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XHJcbiAgdGhpcy5fY2xlYW51cChmYWxzZSk7XHJcbn07XHJcblxyXG5JbmZvUmVjZWl2ZXIudGltZW91dCA9IDgwMDA7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEluZm9SZWNlaXZlcjtcclxuXHJcbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcclxuXHJcbn0se1wiLi9pbmZvLWFqYXhcIjo5LFwiLi9pbmZvLWlmcmFtZVwiOjExLFwiLi90cmFuc3BvcnQvc2VuZGVyL3hkclwiOjM0LFwiLi90cmFuc3BvcnQvc2VuZGVyL3hoci1jb3JzXCI6MzUsXCIuL3RyYW5zcG9ydC9zZW5kZXIveGhyLWZha2VcIjozNixcIi4vdHJhbnNwb3J0L3NlbmRlci94aHItbG9jYWxcIjozNyxcIi4vdXRpbHMvdXJsXCI6NTIsXCJkZWJ1Z1wiOjU0LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTZ9XSwxMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbihmdW5jdGlvbiAoZ2xvYmFsKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwubG9jYXRpb24gfHwge1xyXG4gIG9yaWdpbjogJ2h0dHA6Ly9sb2NhbGhvc3Q6ODAnXHJcbiwgcHJvdG9jb2w6ICdodHRwOidcclxuLCBob3N0OiAnbG9jYWxob3N0J1xyXG4sIHBvcnQ6IDgwXHJcbiwgaHJlZjogJ2h0dHA6Ly9sb2NhbGhvc3QvJ1xyXG4sIGhhc2g6ICcnXHJcbn07XHJcblxyXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcclxuXHJcbn0se31dLDE0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnJlcXVpcmUoJy4vc2hpbXMnKTtcclxuXHJcbnZhciBVUkwgPSByZXF1aXJlKCd1cmwtcGFyc2UnKVxyXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXHJcbiAgLCBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJylcclxuICAsIHJhbmRvbSA9IHJlcXVpcmUoJy4vdXRpbHMvcmFuZG9tJylcclxuICAsIGVzY2FwZSA9IHJlcXVpcmUoJy4vdXRpbHMvZXNjYXBlJylcclxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi91dGlscy91cmwnKVxyXG4gICwgZXZlbnRVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvZXZlbnQnKVxyXG4gICwgdHJhbnNwb3J0ID0gcmVxdWlyZSgnLi91dGlscy90cmFuc3BvcnQnKVxyXG4gICwgb2JqZWN0VXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL29iamVjdCcpXHJcbiAgLCBicm93c2VyID0gcmVxdWlyZSgnLi91dGlscy9icm93c2VyJylcclxuICAsIGxvZyA9IHJlcXVpcmUoJy4vdXRpbHMvbG9nJylcclxuICAsIEV2ZW50ID0gcmVxdWlyZSgnLi9ldmVudC9ldmVudCcpXHJcbiAgLCBFdmVudFRhcmdldCA9IHJlcXVpcmUoJy4vZXZlbnQvZXZlbnR0YXJnZXQnKVxyXG4gICwgbG9jID0gcmVxdWlyZSgnLi9sb2NhdGlvbicpXHJcbiAgLCBDbG9zZUV2ZW50ID0gcmVxdWlyZSgnLi9ldmVudC9jbG9zZScpXHJcbiAgLCBUcmFuc3BvcnRNZXNzYWdlRXZlbnQgPSByZXF1aXJlKCcuL2V2ZW50L3RyYW5zLW1lc3NhZ2UnKVxyXG4gICwgSW5mb1JlY2VpdmVyID0gcmVxdWlyZSgnLi9pbmZvLXJlY2VpdmVyJylcclxuICA7XHJcblxyXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xyXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDptYWluJyk7XHJcbn1cclxuXHJcbnZhciB0cmFuc3BvcnRzO1xyXG5cclxuLy8gZm9sbG93IGNvbnN0cnVjdG9yIHN0ZXBzIGRlZmluZWQgYXQgaHR0cDovL2Rldi53My5vcmcvaHRtbDUvd2Vic29ja2V0cy8jdGhlLXdlYnNvY2tldC1pbnRlcmZhY2VcclxuZnVuY3Rpb24gU29ja0pTKHVybCwgcHJvdG9jb2xzLCBvcHRpb25zKSB7XHJcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNvY2tKUykpIHtcclxuICAgIHJldHVybiBuZXcgU29ja0pTKHVybCwgcHJvdG9jb2xzLCBvcHRpb25zKTtcclxuICB9XHJcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxKSB7XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmFpbGVkIHRvIGNvbnN0cnVjdCAnU29ja0pTOiAxIGFyZ3VtZW50IHJlcXVpcmVkLCBidXQgb25seSAwIHByZXNlbnRcIik7XHJcbiAgfVxyXG4gIEV2ZW50VGFyZ2V0LmNhbGwodGhpcyk7XHJcblxyXG4gIHRoaXMucmVhZHlTdGF0ZSA9IFNvY2tKUy5DT05ORUNUSU5HO1xyXG4gIHRoaXMuZXh0ZW5zaW9ucyA9ICcnO1xyXG4gIHRoaXMucHJvdG9jb2wgPSAnJztcclxuXHJcbiAgLy8gbm9uLXN0YW5kYXJkIGV4dGVuc2lvblxyXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gIGlmIChvcHRpb25zLnByb3RvY29sc193aGl0ZWxpc3QpIHtcclxuICAgIGxvZy53YXJuKFwiJ3Byb3RvY29sc193aGl0ZWxpc3QnIGlzIERFUFJFQ0FURUQuIFVzZSAndHJhbnNwb3J0cycgaW5zdGVhZC5cIik7XHJcbiAgfVxyXG4gIHRoaXMuX3RyYW5zcG9ydHNXaGl0ZWxpc3QgPSBvcHRpb25zLnRyYW5zcG9ydHM7XHJcbiAgdGhpcy5fdHJhbnNwb3J0T3B0aW9ucyA9IG9wdGlvbnMudHJhbnNwb3J0T3B0aW9ucyB8fCB7fTtcclxuXHJcbiAgdmFyIHNlc3Npb25JZCA9IG9wdGlvbnMuc2Vzc2lvbklkIHx8IDg7XHJcbiAgaWYgKHR5cGVvZiBzZXNzaW9uSWQgPT09ICdmdW5jdGlvbicpIHtcclxuICAgIHRoaXMuX2dlbmVyYXRlU2Vzc2lvbklkID0gc2Vzc2lvbklkO1xyXG4gIH0gZWxzZSBpZiAodHlwZW9mIHNlc3Npb25JZCA9PT0gJ251bWJlcicpIHtcclxuICAgIHRoaXMuX2dlbmVyYXRlU2Vzc2lvbklkID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiByYW5kb20uc3RyaW5nKHNlc3Npb25JZCk7XHJcbiAgICB9O1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJZiBzZXNzaW9uSWQgaXMgdXNlZCBpbiB0aGUgb3B0aW9ucywgaXQgbmVlZHMgdG8gYmUgYSBudW1iZXIgb3IgYSBmdW5jdGlvbi4nKTtcclxuICB9XHJcblxyXG4gIHRoaXMuX3NlcnZlciA9IG9wdGlvbnMuc2VydmVyIHx8IHJhbmRvbS5udW1iZXJTdHJpbmcoMTAwMCk7XHJcblxyXG4gIC8vIFN0ZXAgMSBvZiBXUyBzcGVjIC0gcGFyc2UgYW5kIHZhbGlkYXRlIHRoZSB1cmwuIElzc3VlICM4XHJcbiAgdmFyIHBhcnNlZFVybCA9IG5ldyBVUkwodXJsKTtcclxuICBpZiAoIXBhcnNlZFVybC5ob3N0IHx8ICFwYXJzZWRVcmwucHJvdG9jb2wpIHtcclxuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIlRoZSBVUkwgJ1wiICsgdXJsICsgXCInIGlzIGludmFsaWRcIik7XHJcbiAgfSBlbHNlIGlmIChwYXJzZWRVcmwuaGFzaCkge1xyXG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdUaGUgVVJMIG11c3Qgbm90IGNvbnRhaW4gYSBmcmFnbWVudCcpO1xyXG4gIH0gZWxzZSBpZiAocGFyc2VkVXJsLnByb3RvY29sICE9PSAnaHR0cDonICYmIHBhcnNlZFVybC5wcm90b2NvbCAhPT0gJ2h0dHBzOicpIHtcclxuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIlRoZSBVUkwncyBzY2hlbWUgbXVzdCBiZSBlaXRoZXIgJ2h0dHA6JyBvciAnaHR0cHM6Jy4gJ1wiICsgcGFyc2VkVXJsLnByb3RvY29sICsgXCInIGlzIG5vdCBhbGxvd2VkLlwiKTtcclxuICB9XHJcblxyXG4gIHZhciBzZWN1cmUgPSBwYXJzZWRVcmwucHJvdG9jb2wgPT09ICdodHRwczonO1xyXG4gIC8vIFN0ZXAgMiAtIGRvbid0IGFsbG93IHNlY3VyZSBvcmlnaW4gd2l0aCBhbiBpbnNlY3VyZSBwcm90b2NvbFxyXG4gIGlmIChsb2MucHJvdG9jb2wgPT09ICdodHRwczonICYmICFzZWN1cmUpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignU2VjdXJpdHlFcnJvcjogQW4gaW5zZWN1cmUgU29ja0pTIGNvbm5lY3Rpb24gbWF5IG5vdCBiZSBpbml0aWF0ZWQgZnJvbSBhIHBhZ2UgbG9hZGVkIG92ZXIgSFRUUFMnKTtcclxuICB9XHJcblxyXG4gIC8vIFN0ZXAgMyAtIGNoZWNrIHBvcnQgYWNjZXNzIC0gbm8gbmVlZCBoZXJlXHJcbiAgLy8gU3RlcCA0IC0gcGFyc2UgcHJvdG9jb2xzIGFyZ3VtZW50XHJcbiAgaWYgKCFwcm90b2NvbHMpIHtcclxuICAgIHByb3RvY29scyA9IFtdO1xyXG4gIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkocHJvdG9jb2xzKSkge1xyXG4gICAgcHJvdG9jb2xzID0gW3Byb3RvY29sc107XHJcbiAgfVxyXG5cclxuICAvLyBTdGVwIDUgLSBjaGVjayBwcm90b2NvbHMgYXJndW1lbnRcclxuICB2YXIgc29ydGVkUHJvdG9jb2xzID0gcHJvdG9jb2xzLnNvcnQoKTtcclxuICBzb3J0ZWRQcm90b2NvbHMuZm9yRWFjaChmdW5jdGlvbihwcm90bywgaSkge1xyXG4gICAgaWYgKCFwcm90bykge1xyXG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJUaGUgcHJvdG9jb2xzIGVudHJ5ICdcIiArIHByb3RvICsgXCInIGlzIGludmFsaWQuXCIpO1xyXG4gICAgfVxyXG4gICAgaWYgKGkgPCAoc29ydGVkUHJvdG9jb2xzLmxlbmd0aCAtIDEpICYmIHByb3RvID09PSBzb3J0ZWRQcm90b2NvbHNbaSArIDFdKSB7XHJcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIlRoZSBwcm90b2NvbHMgZW50cnkgJ1wiICsgcHJvdG8gKyBcIicgaXMgZHVwbGljYXRlZC5cIik7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIC8vIFN0ZXAgNiAtIGNvbnZlcnQgb3JpZ2luXHJcbiAgdmFyIG8gPSB1cmxVdGlscy5nZXRPcmlnaW4obG9jLmhyZWYpO1xyXG4gIHRoaXMuX29yaWdpbiA9IG8gPyBvLnRvTG93ZXJDYXNlKCkgOiBudWxsO1xyXG5cclxuICAvLyByZW1vdmUgdGhlIHRyYWlsaW5nIHNsYXNoXHJcbiAgcGFyc2VkVXJsLnNldCgncGF0aG5hbWUnLCBwYXJzZWRVcmwucGF0aG5hbWUucmVwbGFjZSgvXFwvKyQvLCAnJykpO1xyXG5cclxuICAvLyBzdG9yZSB0aGUgc2FuaXRpemVkIHVybFxyXG4gIHRoaXMudXJsID0gcGFyc2VkVXJsLmhyZWY7XHJcbiAgZGVidWcoJ3VzaW5nIHVybCcsIHRoaXMudXJsKTtcclxuXHJcbiAgLy8gU3RlcCA3IC0gc3RhcnQgY29ubmVjdGlvbiBpbiBiYWNrZ3JvdW5kXHJcbiAgLy8gb2J0YWluIHNlcnZlciBpbmZvXHJcbiAgLy8gaHR0cDovL3NvY2tqcy5naXRodWIuaW8vc29ja2pzLXByb3RvY29sL3NvY2tqcy1wcm90b2NvbC0wLjMuMy5odG1sI3NlY3Rpb24tMjZcclxuICB0aGlzLl91cmxJbmZvID0ge1xyXG4gICAgbnVsbE9yaWdpbjogIWJyb3dzZXIuaGFzRG9tYWluKClcclxuICAsIHNhbWVPcmlnaW46IHVybFV0aWxzLmlzT3JpZ2luRXF1YWwodGhpcy51cmwsIGxvYy5ocmVmKVxyXG4gICwgc2FtZVNjaGVtZTogdXJsVXRpbHMuaXNTY2hlbWVFcXVhbCh0aGlzLnVybCwgbG9jLmhyZWYpXHJcbiAgfTtcclxuXHJcbiAgdGhpcy5faXIgPSBuZXcgSW5mb1JlY2VpdmVyKHRoaXMudXJsLCB0aGlzLl91cmxJbmZvKTtcclxuICB0aGlzLl9pci5vbmNlKCdmaW5pc2gnLCB0aGlzLl9yZWNlaXZlSW5mby5iaW5kKHRoaXMpKTtcclxufVxyXG5cclxuaW5oZXJpdHMoU29ja0pTLCBFdmVudFRhcmdldCk7XHJcblxyXG5mdW5jdGlvbiB1c2VyU2V0Q29kZShjb2RlKSB7XHJcbiAgcmV0dXJuIGNvZGUgPT09IDEwMDAgfHwgKGNvZGUgPj0gMzAwMCAmJiBjb2RlIDw9IDQ5OTkpO1xyXG59XHJcblxyXG5Tb2NrSlMucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oY29kZSwgcmVhc29uKSB7XHJcbiAgLy8gU3RlcCAxXHJcbiAgaWYgKGNvZGUgJiYgIXVzZXJTZXRDb2RlKGNvZGUpKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWRBY2Nlc3NFcnJvcjogSW52YWxpZCBjb2RlJyk7XHJcbiAgfVxyXG4gIC8vIFN0ZXAgMi40IHN0YXRlcyB0aGUgbWF4IGlzIDEyMyBieXRlcywgYnV0IHdlIGFyZSBqdXN0IGNoZWNraW5nIGxlbmd0aFxyXG4gIGlmIChyZWFzb24gJiYgcmVhc29uLmxlbmd0aCA+IDEyMykge1xyXG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdyZWFzb24gYXJndW1lbnQgaGFzIGFuIGludmFsaWQgbGVuZ3RoJyk7XHJcbiAgfVxyXG5cclxuICAvLyBTdGVwIDMuMVxyXG4gIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFNvY2tKUy5DTE9TSU5HIHx8IHRoaXMucmVhZHlTdGF0ZSA9PT0gU29ja0pTLkNMT1NFRCkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgLy8gVE9ETyBsb29rIGF0IGRvY3MgdG8gZGV0ZXJtaW5lIGhvdyB0byBzZXQgdGhpc1xyXG4gIHZhciB3YXNDbGVhbiA9IHRydWU7XHJcbiAgdGhpcy5fY2xvc2UoY29kZSB8fCAxMDAwLCByZWFzb24gfHwgJ05vcm1hbCBjbG9zdXJlJywgd2FzQ2xlYW4pO1xyXG59O1xyXG5cclxuU29ja0pTLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24oZGF0YSkge1xyXG4gIC8vICMxMyAtIGNvbnZlcnQgYW55dGhpbmcgbm9uLXN0cmluZyB0byBzdHJpbmdcclxuICAvLyBUT0RPIHRoaXMgY3VycmVudGx5IHR1cm5zIG9iamVjdHMgaW50byBbb2JqZWN0IE9iamVjdF1cclxuICBpZiAodHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnKSB7XHJcbiAgICBkYXRhID0gJycgKyBkYXRhO1xyXG4gIH1cclxuICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ09OTkVDVElORykge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkU3RhdGVFcnJvcjogVGhlIGNvbm5lY3Rpb24gaGFzIG5vdCBiZWVuIGVzdGFibGlzaGVkIHlldCcpO1xyXG4gIH1cclxuICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSBTb2NrSlMuT1BFTikge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICB0aGlzLl90cmFuc3BvcnQuc2VuZChlc2NhcGUucXVvdGUoZGF0YSkpO1xyXG59O1xyXG5cclxuU29ja0pTLnZlcnNpb24gPSByZXF1aXJlKCcuL3ZlcnNpb24nKTtcclxuXHJcblNvY2tKUy5DT05ORUNUSU5HID0gMDtcclxuU29ja0pTLk9QRU4gPSAxO1xyXG5Tb2NrSlMuQ0xPU0lORyA9IDI7XHJcblNvY2tKUy5DTE9TRUQgPSAzO1xyXG5cclxuU29ja0pTLnByb3RvdHlwZS5fcmVjZWl2ZUluZm8gPSBmdW5jdGlvbihpbmZvLCBydHQpIHtcclxuICBkZWJ1ZygnX3JlY2VpdmVJbmZvJywgcnR0KTtcclxuICB0aGlzLl9pciA9IG51bGw7XHJcbiAgaWYgKCFpbmZvKSB7XHJcbiAgICB0aGlzLl9jbG9zZSgxMDAyLCAnQ2Fubm90IGNvbm5lY3QgdG8gc2VydmVyJyk7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICAvLyBlc3RhYmxpc2ggYSByb3VuZC10cmlwIHRpbWVvdXQgKFJUTykgYmFzZWQgb24gdGhlXHJcbiAgLy8gcm91bmQtdHJpcCB0aW1lIChSVFQpXHJcbiAgdGhpcy5fcnRvID0gdGhpcy5jb3VudFJUTyhydHQpO1xyXG4gIC8vIGFsbG93IHNlcnZlciB0byBvdmVycmlkZSB1cmwgdXNlZCBmb3IgdGhlIGFjdHVhbCB0cmFuc3BvcnRcclxuICB0aGlzLl90cmFuc1VybCA9IGluZm8uYmFzZV91cmwgPyBpbmZvLmJhc2VfdXJsIDogdGhpcy51cmw7XHJcbiAgaW5mbyA9IG9iamVjdFV0aWxzLmV4dGVuZChpbmZvLCB0aGlzLl91cmxJbmZvKTtcclxuICBkZWJ1ZygnaW5mbycsIGluZm8pO1xyXG4gIC8vIGRldGVybWluZSBsaXN0IG9mIGRlc2lyZWQgYW5kIHN1cHBvcnRlZCB0cmFuc3BvcnRzXHJcbiAgdmFyIGVuYWJsZWRUcmFuc3BvcnRzID0gdHJhbnNwb3J0cy5maWx0ZXJUb0VuYWJsZWQodGhpcy5fdHJhbnNwb3J0c1doaXRlbGlzdCwgaW5mbyk7XHJcbiAgdGhpcy5fdHJhbnNwb3J0cyA9IGVuYWJsZWRUcmFuc3BvcnRzLm1haW47XHJcbiAgZGVidWcodGhpcy5fdHJhbnNwb3J0cy5sZW5ndGggKyAnIGVuYWJsZWQgdHJhbnNwb3J0cycpO1xyXG5cclxuICB0aGlzLl9jb25uZWN0KCk7XHJcbn07XHJcblxyXG5Tb2NrSlMucHJvdG90eXBlLl9jb25uZWN0ID0gZnVuY3Rpb24oKSB7XHJcbiAgZm9yICh2YXIgVHJhbnNwb3J0ID0gdGhpcy5fdHJhbnNwb3J0cy5zaGlmdCgpOyBUcmFuc3BvcnQ7IFRyYW5zcG9ydCA9IHRoaXMuX3RyYW5zcG9ydHMuc2hpZnQoKSkge1xyXG4gICAgZGVidWcoJ2F0dGVtcHQnLCBUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSk7XHJcbiAgICBpZiAoVHJhbnNwb3J0Lm5lZWRCb2R5KSB7XHJcbiAgICAgIGlmICghZ2xvYmFsLmRvY3VtZW50LmJvZHkgfHxcclxuICAgICAgICAgICh0eXBlb2YgZ2xvYmFsLmRvY3VtZW50LnJlYWR5U3RhdGUgIT09ICd1bmRlZmluZWQnICYmXHJcbiAgICAgICAgICAgIGdsb2JhbC5kb2N1bWVudC5yZWFkeVN0YXRlICE9PSAnY29tcGxldGUnICYmXHJcbiAgICAgICAgICAgIGdsb2JhbC5kb2N1bWVudC5yZWFkeVN0YXRlICE9PSAnaW50ZXJhY3RpdmUnKSkge1xyXG4gICAgICAgIGRlYnVnKCd3YWl0aW5nIGZvciBib2R5Jyk7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0cy51bnNoaWZ0KFRyYW5zcG9ydCk7XHJcbiAgICAgICAgZXZlbnRVdGlscy5hdHRhY2hFdmVudCgnbG9hZCcsIHRoaXMuX2Nvbm5lY3QuYmluZCh0aGlzKSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gY2FsY3VsYXRlIHRpbWVvdXQgYmFzZWQgb24gUlRPIGFuZCByb3VuZCB0cmlwcy4gRGVmYXVsdCB0byA1c1xyXG4gICAgdmFyIHRpbWVvdXRNcyA9ICh0aGlzLl9ydG8gKiBUcmFuc3BvcnQucm91bmRUcmlwcykgfHwgNTAwMDtcclxuICAgIHRoaXMuX3RyYW5zcG9ydFRpbWVvdXRJZCA9IHNldFRpbWVvdXQodGhpcy5fdHJhbnNwb3J0VGltZW91dC5iaW5kKHRoaXMpLCB0aW1lb3V0TXMpO1xyXG4gICAgZGVidWcoJ3VzaW5nIHRpbWVvdXQnLCB0aW1lb3V0TXMpO1xyXG5cclxuICAgIHZhciB0cmFuc3BvcnRVcmwgPSB1cmxVdGlscy5hZGRQYXRoKHRoaXMuX3RyYW5zVXJsLCAnLycgKyB0aGlzLl9zZXJ2ZXIgKyAnLycgKyB0aGlzLl9nZW5lcmF0ZVNlc3Npb25JZCgpKTtcclxuICAgIHZhciBvcHRpb25zID0gdGhpcy5fdHJhbnNwb3J0T3B0aW9uc1tUcmFuc3BvcnQudHJhbnNwb3J0TmFtZV07XHJcbiAgICBkZWJ1ZygndHJhbnNwb3J0IHVybCcsIHRyYW5zcG9ydFVybCk7XHJcbiAgICB2YXIgdHJhbnNwb3J0T2JqID0gbmV3IFRyYW5zcG9ydCh0cmFuc3BvcnRVcmwsIHRoaXMuX3RyYW5zVXJsLCBvcHRpb25zKTtcclxuICAgIHRyYW5zcG9ydE9iai5vbignbWVzc2FnZScsIHRoaXMuX3RyYW5zcG9ydE1lc3NhZ2UuYmluZCh0aGlzKSk7XHJcbiAgICB0cmFuc3BvcnRPYmoub25jZSgnY2xvc2UnLCB0aGlzLl90cmFuc3BvcnRDbG9zZS5iaW5kKHRoaXMpKTtcclxuICAgIHRyYW5zcG9ydE9iai50cmFuc3BvcnROYW1lID0gVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWU7XHJcbiAgICB0aGlzLl90cmFuc3BvcnQgPSB0cmFuc3BvcnRPYmo7XHJcblxyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICB0aGlzLl9jbG9zZSgyMDAwLCAnQWxsIHRyYW5zcG9ydHMgZmFpbGVkJywgZmFsc2UpO1xyXG59O1xyXG5cclxuU29ja0pTLnByb3RvdHlwZS5fdHJhbnNwb3J0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xyXG4gIGRlYnVnKCdfdHJhbnNwb3J0VGltZW91dCcpO1xyXG4gIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFNvY2tKUy5DT05ORUNUSU5HKSB7XHJcbiAgICBpZiAodGhpcy5fdHJhbnNwb3J0KSB7XHJcbiAgICAgIHRoaXMuX3RyYW5zcG9ydC5jbG9zZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX3RyYW5zcG9ydENsb3NlKDIwMDcsICdUcmFuc3BvcnQgdGltZWQgb3V0Jyk7XHJcbiAgfVxyXG59O1xyXG5cclxuU29ja0pTLnByb3RvdHlwZS5fdHJhbnNwb3J0TWVzc2FnZSA9IGZ1bmN0aW9uKG1zZykge1xyXG4gIGRlYnVnKCdfdHJhbnNwb3J0TWVzc2FnZScsIG1zZyk7XHJcbiAgdmFyIHNlbGYgPSB0aGlzXHJcbiAgICAsIHR5cGUgPSBtc2cuc2xpY2UoMCwgMSlcclxuICAgICwgY29udGVudCA9IG1zZy5zbGljZSgxKVxyXG4gICAgLCBwYXlsb2FkXHJcbiAgICA7XHJcblxyXG4gIC8vIGZpcnN0IGNoZWNrIGZvciBtZXNzYWdlcyB0aGF0IGRvbid0IG5lZWQgYSBwYXlsb2FkXHJcbiAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICBjYXNlICdvJzpcclxuICAgICAgdGhpcy5fb3BlbigpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICBjYXNlICdoJzpcclxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnaGVhcnRiZWF0JykpO1xyXG4gICAgICBkZWJ1ZygnaGVhcnRiZWF0JywgdGhpcy50cmFuc3BvcnQpO1xyXG4gICAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBpZiAoY29udGVudCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgcGF5bG9hZCA9IEpTT04zLnBhcnNlKGNvbnRlbnQpO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICBkZWJ1ZygnYmFkIGpzb24nLCBjb250ZW50KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmICh0eXBlb2YgcGF5bG9hZCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIGRlYnVnKCdlbXB0eSBwYXlsb2FkJywgY29udGVudCk7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgIGNhc2UgJ2EnOlxyXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXlsb2FkKSkge1xyXG4gICAgICAgIHBheWxvYWQuZm9yRWFjaChmdW5jdGlvbihwKSB7XHJcbiAgICAgICAgICBkZWJ1ZygnbWVzc2FnZScsIHNlbGYudHJhbnNwb3J0LCBwKTtcclxuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudChuZXcgVHJhbnNwb3J0TWVzc2FnZUV2ZW50KHApKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgJ20nOlxyXG4gICAgICBkZWJ1ZygnbWVzc2FnZScsIHRoaXMudHJhbnNwb3J0LCBwYXlsb2FkKTtcclxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBUcmFuc3BvcnRNZXNzYWdlRXZlbnQocGF5bG9hZCkpO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgJ2MnOlxyXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXlsb2FkKSAmJiBwYXlsb2FkLmxlbmd0aCA9PT0gMikge1xyXG4gICAgICAgIHRoaXMuX2Nsb3NlKHBheWxvYWRbMF0sIHBheWxvYWRbMV0sIHRydWUpO1xyXG4gICAgICB9XHJcbiAgICAgIGJyZWFrO1xyXG4gIH1cclxufTtcclxuXHJcblNvY2tKUy5wcm90b3R5cGUuX3RyYW5zcG9ydENsb3NlID0gZnVuY3Rpb24oY29kZSwgcmVhc29uKSB7XHJcbiAgZGVidWcoJ190cmFuc3BvcnRDbG9zZScsIHRoaXMudHJhbnNwb3J0LCBjb2RlLCByZWFzb24pO1xyXG4gIGlmICh0aGlzLl90cmFuc3BvcnQpIHtcclxuICAgIHRoaXMuX3RyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcclxuICAgIHRoaXMuX3RyYW5zcG9ydCA9IG51bGw7XHJcbiAgICB0aGlzLnRyYW5zcG9ydCA9IG51bGw7XHJcbiAgfVxyXG5cclxuICBpZiAoIXVzZXJTZXRDb2RlKGNvZGUpICYmIGNvZGUgIT09IDIwMDAgJiYgdGhpcy5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ09OTkVDVElORykge1xyXG4gICAgdGhpcy5fY29ubmVjdCgpO1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgdGhpcy5fY2xvc2UoY29kZSwgcmVhc29uKTtcclxufTtcclxuXHJcblNvY2tKUy5wcm90b3R5cGUuX29wZW4gPSBmdW5jdGlvbigpIHtcclxuICBkZWJ1ZygnX29wZW4nLCB0aGlzLl90cmFuc3BvcnQudHJhbnNwb3J0TmFtZSwgdGhpcy5yZWFkeVN0YXRlKTtcclxuICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ09OTkVDVElORykge1xyXG4gICAgaWYgKHRoaXMuX3RyYW5zcG9ydFRpbWVvdXRJZCkge1xyXG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fdHJhbnNwb3J0VGltZW91dElkKTtcclxuICAgICAgdGhpcy5fdHJhbnNwb3J0VGltZW91dElkID0gbnVsbDtcclxuICAgIH1cclxuICAgIHRoaXMucmVhZHlTdGF0ZSA9IFNvY2tKUy5PUEVOO1xyXG4gICAgdGhpcy50cmFuc3BvcnQgPSB0aGlzLl90cmFuc3BvcnQudHJhbnNwb3J0TmFtZTtcclxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ29wZW4nKSk7XHJcbiAgICBkZWJ1ZygnY29ubmVjdGVkJywgdGhpcy50cmFuc3BvcnQpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICAvLyBUaGUgc2VydmVyIG1pZ2h0IGhhdmUgYmVlbiByZXN0YXJ0ZWQsIGFuZCBsb3N0IHRyYWNrIG9mIG91clxyXG4gICAgLy8gY29ubmVjdGlvbi5cclxuICAgIHRoaXMuX2Nsb3NlKDEwMDYsICdTZXJ2ZXIgbG9zdCBzZXNzaW9uJyk7XHJcbiAgfVxyXG59O1xyXG5cclxuU29ja0pTLnByb3RvdHlwZS5fY2xvc2UgPSBmdW5jdGlvbihjb2RlLCByZWFzb24sIHdhc0NsZWFuKSB7XHJcbiAgZGVidWcoJ19jbG9zZScsIHRoaXMudHJhbnNwb3J0LCBjb2RlLCByZWFzb24sIHdhc0NsZWFuLCB0aGlzLnJlYWR5U3RhdGUpO1xyXG4gIHZhciBmb3JjZUZhaWwgPSBmYWxzZTtcclxuXHJcbiAgaWYgKHRoaXMuX2lyKSB7XHJcbiAgICBmb3JjZUZhaWwgPSB0cnVlO1xyXG4gICAgdGhpcy5faXIuY2xvc2UoKTtcclxuICAgIHRoaXMuX2lyID0gbnVsbDtcclxuICB9XHJcbiAgaWYgKHRoaXMuX3RyYW5zcG9ydCkge1xyXG4gICAgdGhpcy5fdHJhbnNwb3J0LmNsb3NlKCk7XHJcbiAgICB0aGlzLl90cmFuc3BvcnQgPSBudWxsO1xyXG4gICAgdGhpcy50cmFuc3BvcnQgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gU29ja0pTLkNMT1NFRCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkU3RhdGVFcnJvcjogU29ja0pTIGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkJyk7XHJcbiAgfVxyXG5cclxuICB0aGlzLnJlYWR5U3RhdGUgPSBTb2NrSlMuQ0xPU0lORztcclxuICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5yZWFkeVN0YXRlID0gU29ja0pTLkNMT1NFRDtcclxuXHJcbiAgICBpZiAoZm9yY2VGYWlsKSB7XHJcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2Vycm9yJykpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBlID0gbmV3IENsb3NlRXZlbnQoJ2Nsb3NlJyk7XHJcbiAgICBlLndhc0NsZWFuID0gd2FzQ2xlYW4gfHwgZmFsc2U7XHJcbiAgICBlLmNvZGUgPSBjb2RlIHx8IDEwMDA7XHJcbiAgICBlLnJlYXNvbiA9IHJlYXNvbjtcclxuXHJcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZSk7XHJcbiAgICB0aGlzLm9ubWVzc2FnZSA9IHRoaXMub25jbG9zZSA9IHRoaXMub25lcnJvciA9IG51bGw7XHJcbiAgICBkZWJ1ZygnZGlzY29ubmVjdGVkJyk7XHJcbiAgfS5iaW5kKHRoaXMpLCAwKTtcclxufTtcclxuXHJcbi8vIFNlZTogaHR0cDovL3d3dy5lcmcuYWJkbi5hYy51ay9+Z2Vycml0L2RjY3Avbm90ZXMvY2NpZDIvcnRvX2VzdGltYXRvci9cclxuLy8gYW5kIFJGQyAyOTg4LlxyXG5Tb2NrSlMucHJvdG90eXBlLmNvdW50UlRPID0gZnVuY3Rpb24ocnR0KSB7XHJcbiAgLy8gSW4gYSBsb2NhbCBlbnZpcm9ubWVudCwgd2hlbiB1c2luZyBJRTgvOSBhbmQgdGhlIGBqc29ucC1wb2xsaW5nYFxyXG4gIC8vIHRyYW5zcG9ydCB0aGUgdGltZSBuZWVkZWQgdG8gZXN0YWJsaXNoIGEgY29ubmVjdGlvbiAodGhlIHRpbWUgdGhhdCBwYXNzXHJcbiAgLy8gZnJvbSB0aGUgb3BlbmluZyBvZiB0aGUgdHJhbnNwb3J0IHRvIHRoZSBjYWxsIG9mIGBfZGlzcGF0Y2hPcGVuYCkgaXNcclxuICAvLyBhcm91bmQgMjAwbXNlYyAodGhlIGxvd2VyIGJvdW5kIHVzZWQgaW4gdGhlIGFydGljbGUgYWJvdmUpIGFuZCB0aGlzXHJcbiAgLy8gY2F1c2VzIHNwdXJpb3VzIHRpbWVvdXRzLiBGb3IgdGhpcyByZWFzb24gd2UgY2FsY3VsYXRlIGEgdmFsdWUgc2xpZ2h0bHlcclxuICAvLyBsYXJnZXIgdGhhbiB0aGF0IHVzZWQgaW4gdGhlIGFydGljbGUuXHJcbiAgaWYgKHJ0dCA+IDEwMCkge1xyXG4gICAgcmV0dXJuIDQgKiBydHQ7IC8vIHJ0byA+IDQwMG1zZWNcclxuICB9XHJcbiAgcmV0dXJuIDMwMCArIHJ0dDsgLy8gMzAwbXNlYyA8IHJ0byA8PSA0MDBtc2VjXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGF2YWlsYWJsZVRyYW5zcG9ydHMpIHtcclxuICB0cmFuc3BvcnRzID0gdHJhbnNwb3J0KGF2YWlsYWJsZVRyYW5zcG9ydHMpO1xyXG4gIHJlcXVpcmUoJy4vaWZyYW1lLWJvb3RzdHJhcCcpKFNvY2tKUywgYXZhaWxhYmxlVHJhbnNwb3J0cyk7XHJcbiAgcmV0dXJuIFNvY2tKUztcclxufTtcclxuXHJcbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxyXG5cclxufSx7XCIuL2V2ZW50L2Nsb3NlXCI6MixcIi4vZXZlbnQvZXZlbnRcIjo0LFwiLi9ldmVudC9ldmVudHRhcmdldFwiOjUsXCIuL2V2ZW50L3RyYW5zLW1lc3NhZ2VcIjo2LFwiLi9pZnJhbWUtYm9vdHN0cmFwXCI6OCxcIi4vaW5mby1yZWNlaXZlclwiOjEyLFwiLi9sb2NhdGlvblwiOjEzLFwiLi9zaGltc1wiOjE1LFwiLi91dGlscy9icm93c2VyXCI6NDQsXCIuL3V0aWxzL2VzY2FwZVwiOjQ1LFwiLi91dGlscy9ldmVudFwiOjQ2LFwiLi91dGlscy9sb2dcIjo0OCxcIi4vdXRpbHMvb2JqZWN0XCI6NDksXCIuL3V0aWxzL3JhbmRvbVwiOjUwLFwiLi91dGlscy90cmFuc3BvcnRcIjo1MSxcIi4vdXRpbHMvdXJsXCI6NTIsXCIuL3ZlcnNpb25cIjo1MyxcImRlYnVnXCI6NTQsXCJpbmhlcml0c1wiOjU2LFwianNvbjNcIjo1NyxcInVybC1wYXJzZVwiOjYxfV0sMTU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xyXG4vKiBqc2NzOiBkaXNhYmxlICovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbi8vIHB1bGxlZCBzcGVjaWZpYyBzaGltcyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbVxyXG5cclxudmFyIEFycmF5UHJvdG90eXBlID0gQXJyYXkucHJvdG90eXBlO1xyXG52YXIgT2JqZWN0UHJvdG90eXBlID0gT2JqZWN0LnByb3RvdHlwZTtcclxudmFyIEZ1bmN0aW9uUHJvdG90eXBlID0gRnVuY3Rpb24ucHJvdG90eXBlO1xyXG52YXIgU3RyaW5nUHJvdG90eXBlID0gU3RyaW5nLnByb3RvdHlwZTtcclxudmFyIGFycmF5X3NsaWNlID0gQXJyYXlQcm90b3R5cGUuc2xpY2U7XHJcblxyXG52YXIgX3RvU3RyaW5nID0gT2JqZWN0UHJvdG90eXBlLnRvU3RyaW5nO1xyXG52YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uICh2YWwpIHtcclxuICAgIHJldHVybiBPYmplY3RQcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xyXG59O1xyXG52YXIgaXNBcnJheSA9IGZ1bmN0aW9uIGlzQXJyYXkob2JqKSB7XHJcbiAgICByZXR1cm4gX3RvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcclxufTtcclxudmFyIGlzU3RyaW5nID0gZnVuY3Rpb24gaXNTdHJpbmcob2JqKSB7XHJcbiAgICByZXR1cm4gX3RvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7XHJcbn07XHJcblxyXG52YXIgc3VwcG9ydHNEZXNjcmlwdG9ycyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiAoZnVuY3Rpb24gKCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICd4Jywge30pO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSBjYXRjaCAoZSkgeyAvKiB0aGlzIGlzIEVTMyAqL1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufSgpKTtcclxuXHJcbi8vIERlZmluZSBjb25maWd1cmFibGUsIHdyaXRhYmxlIGFuZCBub24tZW51bWVyYWJsZSBwcm9wc1xyXG4vLyBpZiB0aGV5IGRvbid0IGV4aXN0LlxyXG52YXIgZGVmaW5lUHJvcGVydHk7XHJcbmlmIChzdXBwb3J0c0Rlc2NyaXB0b3JzKSB7XHJcbiAgICBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWUsIG1ldGhvZCwgZm9yY2VBc3NpZ24pIHtcclxuICAgICAgICBpZiAoIWZvcmNlQXNzaWduICYmIChuYW1lIGluIG9iamVjdCkpIHsgcmV0dXJuOyB9XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgbmFtZSwge1xyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IG1ldGhvZFxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxufSBlbHNlIHtcclxuICAgIGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZSwgbWV0aG9kLCBmb3JjZUFzc2lnbikge1xyXG4gICAgICAgIGlmICghZm9yY2VBc3NpZ24gJiYgKG5hbWUgaW4gb2JqZWN0KSkgeyByZXR1cm47IH1cclxuICAgICAgICBvYmplY3RbbmFtZV0gPSBtZXRob2Q7XHJcbiAgICB9O1xyXG59XHJcbnZhciBkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKG9iamVjdCwgbWFwLCBmb3JjZUFzc2lnbikge1xyXG4gICAgZm9yICh2YXIgbmFtZSBpbiBtYXApIHtcclxuICAgICAgICBpZiAoT2JqZWN0UHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobWFwLCBuYW1lKSkge1xyXG4gICAgICAgICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCBtYXBbbmFtZV0sIGZvcmNlQXNzaWduKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG52YXIgdG9PYmplY3QgPSBmdW5jdGlvbiAobykge1xyXG4gICAgaWYgKG8gPT0gbnVsbCkgeyAvLyB0aGlzIG1hdGNoZXMgYm90aCBudWxsIGFuZCB1bmRlZmluZWRcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2FuJ3QgY29udmVydCBcIiArIG8gKyAnIHRvIG9iamVjdCcpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIE9iamVjdChvKTtcclxufTtcclxuXHJcbi8vXHJcbi8vIFV0aWxcclxuLy8gPT09PT09XHJcbi8vXHJcblxyXG4vLyBFUzUgOS40XHJcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDkuNFxyXG4vLyBodHRwOi8vanNwZXJmLmNvbS90by1pbnRlZ2VyXHJcblxyXG5mdW5jdGlvbiB0b0ludGVnZXIobnVtKSB7XHJcbiAgICB2YXIgbiA9ICtudW07XHJcbiAgICBpZiAobiAhPT0gbikgeyAvLyBpc05hTlxyXG4gICAgICAgIG4gPSAwO1xyXG4gICAgfSBlbHNlIGlmIChuICE9PSAwICYmIG4gIT09ICgxIC8gMCkgJiYgbiAhPT0gLSgxIC8gMCkpIHtcclxuICAgICAgICBuID0gKG4gPiAwIHx8IC0xKSAqIE1hdGguZmxvb3IoTWF0aC5hYnMobikpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG47XHJcbn1cclxuXHJcbmZ1bmN0aW9uIFRvVWludDMyKHgpIHtcclxuICAgIHJldHVybiB4ID4+PiAwO1xyXG59XHJcblxyXG4vL1xyXG4vLyBGdW5jdGlvblxyXG4vLyA9PT09PT09PVxyXG4vL1xyXG5cclxuLy8gRVMtNSAxNS4zLjQuNVxyXG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS4zLjQuNVxyXG5cclxuZnVuY3Rpb24gRW1wdHkoKSB7fVxyXG5cclxuZGVmaW5lUHJvcGVydGllcyhGdW5jdGlvblByb3RvdHlwZSwge1xyXG4gICAgYmluZDogZnVuY3Rpb24gYmluZCh0aGF0KSB7IC8vIC5sZW5ndGggaXMgMVxyXG4gICAgICAgIC8vIDEuIExldCBUYXJnZXQgYmUgdGhlIHRoaXMgdmFsdWUuXHJcbiAgICAgICAgdmFyIHRhcmdldCA9IHRoaXM7XHJcbiAgICAgICAgLy8gMi4gSWYgSXNDYWxsYWJsZShUYXJnZXQpIGlzIGZhbHNlLCB0aHJvdyBhIFR5cGVFcnJvciBleGNlcHRpb24uXHJcbiAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKHRhcmdldCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgY2FsbGVkIG9uIGluY29tcGF0aWJsZSAnICsgdGFyZ2V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gMy4gTGV0IEEgYmUgYSBuZXcgKHBvc3NpYmx5IGVtcHR5KSBpbnRlcm5hbCBsaXN0IG9mIGFsbCBvZiB0aGVcclxuICAgICAgICAvLyAgIGFyZ3VtZW50IHZhbHVlcyBwcm92aWRlZCBhZnRlciB0aGlzQXJnIChhcmcxLCBhcmcyIGV0YyksIGluIG9yZGVyLlxyXG4gICAgICAgIC8vIFhYWCBzbGljZWRBcmdzIHdpbGwgc3RhbmQgaW4gZm9yIFwiQVwiIGlmIHVzZWRcclxuICAgICAgICB2YXIgYXJncyA9IGFycmF5X3NsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTsgLy8gZm9yIG5vcm1hbCBjYWxsXHJcbiAgICAgICAgLy8gNC4gTGV0IEYgYmUgYSBuZXcgbmF0aXZlIEVDTUFTY3JpcHQgb2JqZWN0LlxyXG4gICAgICAgIC8vIDExLiBTZXQgdGhlIFtbUHJvdG90eXBlXV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgRiB0byB0aGUgc3RhbmRhcmRcclxuICAgICAgICAvLyAgIGJ1aWx0LWluIEZ1bmN0aW9uIHByb3RvdHlwZSBvYmplY3QgYXMgc3BlY2lmaWVkIGluIDE1LjMuMy4xLlxyXG4gICAgICAgIC8vIDEyLiBTZXQgdGhlIFtbQ2FsbF1dIGludGVybmFsIHByb3BlcnR5IG9mIEYgYXMgZGVzY3JpYmVkIGluXHJcbiAgICAgICAgLy8gICAxNS4zLjQuNS4xLlxyXG4gICAgICAgIC8vIDEzLiBTZXQgdGhlIFtbQ29uc3RydWN0XV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgRiBhcyBkZXNjcmliZWQgaW5cclxuICAgICAgICAvLyAgIDE1LjMuNC41LjIuXHJcbiAgICAgICAgLy8gMTQuIFNldCB0aGUgW1tIYXNJbnN0YW5jZV1dIGludGVybmFsIHByb3BlcnR5IG9mIEYgYXMgZGVzY3JpYmVkIGluXHJcbiAgICAgICAgLy8gICAxNS4zLjQuNS4zLlxyXG4gICAgICAgIHZhciBiaW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSB7XHJcbiAgICAgICAgICAgICAgICAvLyAxNS4zLjQuNS4yIFtbQ29uc3RydWN0XV1cclxuICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlIFtbQ29uc3RydWN0XV0gaW50ZXJuYWwgbWV0aG9kIG9mIGEgZnVuY3Rpb24gb2JqZWN0LFxyXG4gICAgICAgICAgICAgICAgLy8gRiB0aGF0IHdhcyBjcmVhdGVkIHVzaW5nIHRoZSBiaW5kIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIGFcclxuICAgICAgICAgICAgICAgIC8vIGxpc3Qgb2YgYXJndW1lbnRzIEV4dHJhQXJncywgdGhlIGZvbGxvd2luZyBzdGVwcyBhcmUgdGFrZW46XHJcbiAgICAgICAgICAgICAgICAvLyAxLiBMZXQgdGFyZ2V0IGJlIHRoZSB2YWx1ZSBvZiBGJ3MgW1tUYXJnZXRGdW5jdGlvbl1dXHJcbiAgICAgICAgICAgICAgICAvLyAgIGludGVybmFsIHByb3BlcnR5LlxyXG4gICAgICAgICAgICAgICAgLy8gMi4gSWYgdGFyZ2V0IGhhcyBubyBbW0NvbnN0cnVjdF1dIGludGVybmFsIG1ldGhvZCwgYVxyXG4gICAgICAgICAgICAgICAgLy8gICBUeXBlRXJyb3IgZXhjZXB0aW9uIGlzIHRocm93bi5cclxuICAgICAgICAgICAgICAgIC8vIDMuIExldCBib3VuZEFyZ3MgYmUgdGhlIHZhbHVlIG9mIEYncyBbW0JvdW5kQXJnc11dIGludGVybmFsXHJcbiAgICAgICAgICAgICAgICAvLyAgIHByb3BlcnR5LlxyXG4gICAgICAgICAgICAgICAgLy8gNC4gTGV0IGFyZ3MgYmUgYSBuZXcgbGlzdCBjb250YWluaW5nIHRoZSBzYW1lIHZhbHVlcyBhcyB0aGVcclxuICAgICAgICAgICAgICAgIC8vICAgbGlzdCBib3VuZEFyZ3MgaW4gdGhlIHNhbWUgb3JkZXIgZm9sbG93ZWQgYnkgdGhlIHNhbWVcclxuICAgICAgICAgICAgICAgIC8vICAgdmFsdWVzIGFzIHRoZSBsaXN0IEV4dHJhQXJncyBpbiB0aGUgc2FtZSBvcmRlci5cclxuICAgICAgICAgICAgICAgIC8vIDUuIFJldHVybiB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgdGhlIFtbQ29uc3RydWN0XV0gaW50ZXJuYWxcclxuICAgICAgICAgICAgICAgIC8vICAgbWV0aG9kIG9mIHRhcmdldCBwcm92aWRpbmcgYXJncyBhcyB0aGUgYXJndW1lbnRzLlxyXG5cclxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0YXJnZXQuYXBwbHkoXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcyxcclxuICAgICAgICAgICAgICAgICAgICBhcmdzLmNvbmNhdChhcnJheV9zbGljZS5jYWxsKGFyZ3VtZW50cykpXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdChyZXN1bHQpID09PSByZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gMTUuMy40LjUuMSBbW0NhbGxdXVxyXG4gICAgICAgICAgICAgICAgLy8gV2hlbiB0aGUgW1tDYWxsXV0gaW50ZXJuYWwgbWV0aG9kIG9mIGEgZnVuY3Rpb24gb2JqZWN0LCBGLFxyXG4gICAgICAgICAgICAgICAgLy8gd2hpY2ggd2FzIGNyZWF0ZWQgdXNpbmcgdGhlIGJpbmQgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggYVxyXG4gICAgICAgICAgICAgICAgLy8gdGhpcyB2YWx1ZSBhbmQgYSBsaXN0IG9mIGFyZ3VtZW50cyBFeHRyYUFyZ3MsIHRoZSBmb2xsb3dpbmdcclxuICAgICAgICAgICAgICAgIC8vIHN0ZXBzIGFyZSB0YWtlbjpcclxuICAgICAgICAgICAgICAgIC8vIDEuIExldCBib3VuZEFyZ3MgYmUgdGhlIHZhbHVlIG9mIEYncyBbW0JvdW5kQXJnc11dIGludGVybmFsXHJcbiAgICAgICAgICAgICAgICAvLyAgIHByb3BlcnR5LlxyXG4gICAgICAgICAgICAgICAgLy8gMi4gTGV0IGJvdW5kVGhpcyBiZSB0aGUgdmFsdWUgb2YgRidzIFtbQm91bmRUaGlzXV0gaW50ZXJuYWxcclxuICAgICAgICAgICAgICAgIC8vICAgcHJvcGVydHkuXHJcbiAgICAgICAgICAgICAgICAvLyAzLiBMZXQgdGFyZ2V0IGJlIHRoZSB2YWx1ZSBvZiBGJ3MgW1tUYXJnZXRGdW5jdGlvbl1dIGludGVybmFsXHJcbiAgICAgICAgICAgICAgICAvLyAgIHByb3BlcnR5LlxyXG4gICAgICAgICAgICAgICAgLy8gNC4gTGV0IGFyZ3MgYmUgYSBuZXcgbGlzdCBjb250YWluaW5nIHRoZSBzYW1lIHZhbHVlcyBhcyB0aGVcclxuICAgICAgICAgICAgICAgIC8vICAgbGlzdCBib3VuZEFyZ3MgaW4gdGhlIHNhbWUgb3JkZXIgZm9sbG93ZWQgYnkgdGhlIHNhbWVcclxuICAgICAgICAgICAgICAgIC8vICAgdmFsdWVzIGFzIHRoZSBsaXN0IEV4dHJhQXJncyBpbiB0aGUgc2FtZSBvcmRlci5cclxuICAgICAgICAgICAgICAgIC8vIDUuIFJldHVybiB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgdGhlIFtbQ2FsbF1dIGludGVybmFsIG1ldGhvZFxyXG4gICAgICAgICAgICAgICAgLy8gICBvZiB0YXJnZXQgcHJvdmlkaW5nIGJvdW5kVGhpcyBhcyB0aGUgdGhpcyB2YWx1ZSBhbmRcclxuICAgICAgICAgICAgICAgIC8vICAgcHJvdmlkaW5nIGFyZ3MgYXMgdGhlIGFyZ3VtZW50cy5cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBlcXVpdjogdGFyZ2V0LmNhbGwodGhpcywgLi4uYm91bmRBcmdzLCAuLi5hcmdzKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseShcclxuICAgICAgICAgICAgICAgICAgICB0aGF0LFxyXG4gICAgICAgICAgICAgICAgICAgIGFyZ3MuY29uY2F0KGFycmF5X3NsaWNlLmNhbGwoYXJndW1lbnRzKSlcclxuICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIDE1LiBJZiB0aGUgW1tDbGFzc11dIGludGVybmFsIHByb3BlcnR5IG9mIFRhcmdldCBpcyBcIkZ1bmN0aW9uXCIsIHRoZW5cclxuICAgICAgICAvLyAgICAgYS4gTGV0IEwgYmUgdGhlIGxlbmd0aCBwcm9wZXJ0eSBvZiBUYXJnZXQgbWludXMgdGhlIGxlbmd0aCBvZiBBLlxyXG4gICAgICAgIC8vICAgICBiLiBTZXQgdGhlIGxlbmd0aCBvd24gcHJvcGVydHkgb2YgRiB0byBlaXRoZXIgMCBvciBMLCB3aGljaGV2ZXIgaXNcclxuICAgICAgICAvLyAgICAgICBsYXJnZXIuXHJcbiAgICAgICAgLy8gMTYuIEVsc2Ugc2V0IHRoZSBsZW5ndGggb3duIHByb3BlcnR5IG9mIEYgdG8gMC5cclxuXHJcbiAgICAgICAgdmFyIGJvdW5kTGVuZ3RoID0gTWF0aC5tYXgoMCwgdGFyZ2V0Lmxlbmd0aCAtIGFyZ3MubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgLy8gMTcuIFNldCB0aGUgYXR0cmlidXRlcyBvZiB0aGUgbGVuZ3RoIG93biBwcm9wZXJ0eSBvZiBGIHRvIHRoZSB2YWx1ZXNcclxuICAgICAgICAvLyAgIHNwZWNpZmllZCBpbiAxNS4zLjUuMS5cclxuICAgICAgICB2YXIgYm91bmRBcmdzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib3VuZExlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGJvdW5kQXJncy5wdXNoKCckJyArIGkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gWFhYIEJ1aWxkIGEgZHluYW1pYyBmdW5jdGlvbiB3aXRoIGRlc2lyZWQgYW1vdW50IG9mIGFyZ3VtZW50cyBpcyB0aGUgb25seVxyXG4gICAgICAgIC8vIHdheSB0byBzZXQgdGhlIGxlbmd0aCBwcm9wZXJ0eSBvZiBhIGZ1bmN0aW9uLlxyXG4gICAgICAgIC8vIEluIGVudmlyb25tZW50cyB3aGVyZSBDb250ZW50IFNlY3VyaXR5IFBvbGljaWVzIGVuYWJsZWQgKENocm9tZSBleHRlbnNpb25zLFxyXG4gICAgICAgIC8vIGZvciBleC4pIGFsbCB1c2Ugb2YgZXZhbCBvciBGdW5jdGlvbiBjb3N0cnVjdG9yIHRocm93cyBhbiBleGNlcHRpb24uXHJcbiAgICAgICAgLy8gSG93ZXZlciBpbiBhbGwgb2YgdGhlc2UgZW52aXJvbm1lbnRzIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIGV4aXN0c1xyXG4gICAgICAgIC8vIGFuZCBzbyB0aGlzIGNvZGUgd2lsbCBuZXZlciBiZSBleGVjdXRlZC5cclxuICAgICAgICB2YXIgYm91bmQgPSBGdW5jdGlvbignYmluZGVyJywgJ3JldHVybiBmdW5jdGlvbiAoJyArIGJvdW5kQXJncy5qb2luKCcsJykgKyAnKXsgcmV0dXJuIGJpbmRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9JykoYmluZGVyKTtcclxuXHJcbiAgICAgICAgaWYgKHRhcmdldC5wcm90b3R5cGUpIHtcclxuICAgICAgICAgICAgRW1wdHkucHJvdG90eXBlID0gdGFyZ2V0LnByb3RvdHlwZTtcclxuICAgICAgICAgICAgYm91bmQucHJvdG90eXBlID0gbmV3IEVtcHR5KCk7XHJcbiAgICAgICAgICAgIC8vIENsZWFuIHVwIGRhbmdsaW5nIHJlZmVyZW5jZXMuXHJcbiAgICAgICAgICAgIEVtcHR5LnByb3RvdHlwZSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBUT0RPXHJcbiAgICAgICAgLy8gMTguIFNldCB0aGUgW1tFeHRlbnNpYmxlXV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgRiB0byB0cnVlLlxyXG5cclxuICAgICAgICAvLyBUT0RPXHJcbiAgICAgICAgLy8gMTkuIExldCB0aHJvd2VyIGJlIHRoZSBbW1Rocm93VHlwZUVycm9yXV0gZnVuY3Rpb24gT2JqZWN0ICgxMy4yLjMpLlxyXG4gICAgICAgIC8vIDIwLiBDYWxsIHRoZSBbW0RlZmluZU93blByb3BlcnR5XV0gaW50ZXJuYWwgbWV0aG9kIG9mIEYgd2l0aFxyXG4gICAgICAgIC8vICAgYXJndW1lbnRzIFwiY2FsbGVyXCIsIFByb3BlcnR5RGVzY3JpcHRvciB7W1tHZXRdXTogdGhyb3dlciwgW1tTZXRdXTpcclxuICAgICAgICAvLyAgIHRocm93ZXIsIFtbRW51bWVyYWJsZV1dOiBmYWxzZSwgW1tDb25maWd1cmFibGVdXTogZmFsc2V9LCBhbmRcclxuICAgICAgICAvLyAgIGZhbHNlLlxyXG4gICAgICAgIC8vIDIxLiBDYWxsIHRoZSBbW0RlZmluZU93blByb3BlcnR5XV0gaW50ZXJuYWwgbWV0aG9kIG9mIEYgd2l0aFxyXG4gICAgICAgIC8vICAgYXJndW1lbnRzIFwiYXJndW1lbnRzXCIsIFByb3BlcnR5RGVzY3JpcHRvciB7W1tHZXRdXTogdGhyb3dlcixcclxuICAgICAgICAvLyAgIFtbU2V0XV06IHRocm93ZXIsIFtbRW51bWVyYWJsZV1dOiBmYWxzZSwgW1tDb25maWd1cmFibGVdXTogZmFsc2V9LFxyXG4gICAgICAgIC8vICAgYW5kIGZhbHNlLlxyXG5cclxuICAgICAgICAvLyBUT0RPXHJcbiAgICAgICAgLy8gTk9URSBGdW5jdGlvbiBvYmplY3RzIGNyZWF0ZWQgdXNpbmcgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgZG8gbm90XHJcbiAgICAgICAgLy8gaGF2ZSBhIHByb3RvdHlwZSBwcm9wZXJ0eSBvciB0aGUgW1tDb2RlXV0sIFtbRm9ybWFsUGFyYW1ldGVyc11dLCBhbmRcclxuICAgICAgICAvLyBbW1Njb3BlXV0gaW50ZXJuYWwgcHJvcGVydGllcy5cclxuICAgICAgICAvLyBYWFggY2FuJ3QgZGVsZXRlIHByb3RvdHlwZSBpbiBwdXJlLWpzLlxyXG5cclxuICAgICAgICAvLyAyMi4gUmV0dXJuIEYuXHJcbiAgICAgICAgcmV0dXJuIGJvdW5kO1xyXG4gICAgfVxyXG59KTtcclxuXHJcbi8vXHJcbi8vIEFycmF5XHJcbi8vID09PT09XHJcbi8vXHJcblxyXG4vLyBFUzUgMTUuNC4zLjJcclxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNC4zLjJcclxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvaXNBcnJheVxyXG5kZWZpbmVQcm9wZXJ0aWVzKEFycmF5LCB7IGlzQXJyYXk6IGlzQXJyYXkgfSk7XHJcblxyXG5cclxudmFyIGJveGVkU3RyaW5nID0gT2JqZWN0KCdhJyk7XHJcbnZhciBzcGxpdFN0cmluZyA9IGJveGVkU3RyaW5nWzBdICE9PSAnYScgfHwgISgwIGluIGJveGVkU3RyaW5nKTtcclxuXHJcbnZhciBwcm9wZXJseUJveGVzQ29udGV4dCA9IGZ1bmN0aW9uIHByb3Blcmx5Qm94ZWQobWV0aG9kKSB7XHJcbiAgICAvLyBDaGVjayBub2RlIDAuNi4yMSBidWcgd2hlcmUgdGhpcmQgcGFyYW1ldGVyIGlzIG5vdCBib3hlZFxyXG4gICAgdmFyIHByb3Blcmx5Qm94ZXNOb25TdHJpY3QgPSB0cnVlO1xyXG4gICAgdmFyIHByb3Blcmx5Qm94ZXNTdHJpY3QgPSB0cnVlO1xyXG4gICAgaWYgKG1ldGhvZCkge1xyXG4gICAgICAgIG1ldGhvZC5jYWxsKCdmb28nLCBmdW5jdGlvbiAoXywgX18sIGNvbnRleHQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZXh0ICE9PSAnb2JqZWN0JykgeyBwcm9wZXJseUJveGVzTm9uU3RyaWN0ID0gZmFsc2U7IH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgbWV0aG9kLmNhbGwoWzFdLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICd1c2Ugc3RyaWN0JztcclxuICAgICAgICAgICAgcHJvcGVybHlCb3hlc1N0cmljdCA9IHR5cGVvZiB0aGlzID09PSAnc3RyaW5nJztcclxuICAgICAgICB9LCAneCcpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuICEhbWV0aG9kICYmIHByb3Blcmx5Qm94ZXNOb25TdHJpY3QgJiYgcHJvcGVybHlCb3hlc1N0cmljdDtcclxufTtcclxuXHJcbmRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHtcclxuICAgIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goZnVuIC8qLCB0aGlzcCovKSB7XHJcbiAgICAgICAgdmFyIG9iamVjdCA9IHRvT2JqZWN0KHRoaXMpLFxyXG4gICAgICAgICAgICBzZWxmID0gc3BsaXRTdHJpbmcgJiYgaXNTdHJpbmcodGhpcykgPyB0aGlzLnNwbGl0KCcnKSA6IG9iamVjdCxcclxuICAgICAgICAgICAgdGhpc3AgPSBhcmd1bWVudHNbMV0sXHJcbiAgICAgICAgICAgIGkgPSAtMSxcclxuICAgICAgICAgICAgbGVuZ3RoID0gc2VsZi5sZW5ndGggPj4+IDA7XHJcblxyXG4gICAgICAgIC8vIElmIG5vIGNhbGxiYWNrIGZ1bmN0aW9uIG9yIGlmIGNhbGxiYWNrIGlzIG5vdCBhIGNhbGxhYmxlIGZ1bmN0aW9uXHJcbiAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKGZ1bikpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpOyAvLyBUT0RPIG1lc3NhZ2VcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHdoaWxlICgrK2kgPCBsZW5ndGgpIHtcclxuICAgICAgICAgICAgaWYgKGkgaW4gc2VsZikge1xyXG4gICAgICAgICAgICAgICAgLy8gSW52b2tlIHRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aXRoIGNhbGwsIHBhc3NpbmcgYXJndW1lbnRzOlxyXG4gICAgICAgICAgICAgICAgLy8gY29udGV4dCwgcHJvcGVydHkgdmFsdWUsIHByb3BlcnR5IGtleSwgdGhpc0FyZyBvYmplY3RcclxuICAgICAgICAgICAgICAgIC8vIGNvbnRleHRcclxuICAgICAgICAgICAgICAgIGZ1bi5jYWxsKHRoaXNwLCBzZWxmW2ldLCBpLCBvYmplY3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59LCAhcHJvcGVybHlCb3hlc0NvbnRleHQoQXJyYXlQcm90b3R5cGUuZm9yRWFjaCkpO1xyXG5cclxuLy8gRVM1IDE1LjQuNC4xNFxyXG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjQuMTRcclxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvaW5kZXhPZlxyXG52YXIgaGFzRmlyZWZveDJJbmRleE9mQnVnID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2YgJiYgWzAsIDFdLmluZGV4T2YoMSwgMikgIT09IC0xO1xyXG5kZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XHJcbiAgICBpbmRleE9mOiBmdW5jdGlvbiBpbmRleE9mKHNvdWdodCAvKiwgZnJvbUluZGV4ICovICkge1xyXG4gICAgICAgIHZhciBzZWxmID0gc3BsaXRTdHJpbmcgJiYgaXNTdHJpbmcodGhpcykgPyB0aGlzLnNwbGl0KCcnKSA6IHRvT2JqZWN0KHRoaXMpLFxyXG4gICAgICAgICAgICBsZW5ndGggPSBzZWxmLmxlbmd0aCA+Pj4gMDtcclxuXHJcbiAgICAgICAgaWYgKCFsZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICBpID0gdG9JbnRlZ2VyKGFyZ3VtZW50c1sxXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBoYW5kbGUgbmVnYXRpdmUgaW5kaWNlc1xyXG4gICAgICAgIGkgPSBpID49IDAgPyBpIDogTWF0aC5tYXgoMCwgbGVuZ3RoICsgaSk7XHJcbiAgICAgICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoaSBpbiBzZWxmICYmIHNlbGZbaV0gPT09IHNvdWdodCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG59LCBoYXNGaXJlZm94MkluZGV4T2ZCdWcpO1xyXG5cclxuLy9cclxuLy8gU3RyaW5nXHJcbi8vID09PT09PVxyXG4vL1xyXG5cclxuLy8gRVM1IDE1LjUuNC4xNFxyXG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS41LjQuMTRcclxuXHJcbi8vIFtidWdmaXgsIElFIGx0IDksIGZpcmVmb3ggNCwgS29ucXVlcm9yLCBPcGVyYSwgb2JzY3VyZSBicm93c2Vyc11cclxuLy8gTWFueSBicm93c2VycyBkbyBub3Qgc3BsaXQgcHJvcGVybHkgd2l0aCByZWd1bGFyIGV4cHJlc3Npb25zIG9yIHRoZXlcclxuLy8gZG8gbm90IHBlcmZvcm0gdGhlIHNwbGl0IGNvcnJlY3RseSB1bmRlciBvYnNjdXJlIGNvbmRpdGlvbnMuXHJcbi8vIFNlZSBodHRwOi8vYmxvZy5zdGV2ZW5sZXZpdGhhbi5jb20vYXJjaGl2ZXMvY3Jvc3MtYnJvd3Nlci1zcGxpdFxyXG4vLyBJJ3ZlIHRlc3RlZCBpbiBtYW55IGJyb3dzZXJzIGFuZCB0aGlzIHNlZW1zIHRvIGNvdmVyIHRoZSBkZXZpYW50IG9uZXM6XHJcbi8vICAgICdhYicuc3BsaXQoLyg/OmFiKSovKSBzaG91bGQgYmUgW1wiXCIsIFwiXCJdLCBub3QgW1wiXCJdXHJcbi8vICAgICcuJy5zcGxpdCgvKC4/KSguPykvKSBzaG91bGQgYmUgW1wiXCIsIFwiLlwiLCBcIlwiLCBcIlwiXSwgbm90IFtcIlwiLCBcIlwiXVxyXG4vLyAgICAndGVzc3QnLnNwbGl0KC8ocykqLykgc2hvdWxkIGJlIFtcInRcIiwgdW5kZWZpbmVkLCBcImVcIiwgXCJzXCIsIFwidFwiXSwgbm90XHJcbi8vICAgICAgIFt1bmRlZmluZWQsIFwidFwiLCB1bmRlZmluZWQsIFwiZVwiLCAuLi5dXHJcbi8vICAgICcnLnNwbGl0KC8uPy8pIHNob3VsZCBiZSBbXSwgbm90IFtcIlwiXVxyXG4vLyAgICAnLicuc3BsaXQoLygpKCkvKSBzaG91bGQgYmUgW1wiLlwiXSwgbm90IFtcIlwiLCBcIlwiLCBcIi5cIl1cclxuXHJcbnZhciBzdHJpbmdfc3BsaXQgPSBTdHJpbmdQcm90b3R5cGUuc3BsaXQ7XHJcbmlmIChcclxuICAgICdhYicuc3BsaXQoLyg/OmFiKSovKS5sZW5ndGggIT09IDIgfHxcclxuICAgICcuJy5zcGxpdCgvKC4/KSguPykvKS5sZW5ndGggIT09IDQgfHxcclxuICAgICd0ZXNzdCcuc3BsaXQoLyhzKSovKVsxXSA9PT0gJ3QnIHx8XHJcbiAgICAndGVzdCcuc3BsaXQoLyg/OikvLCAtMSkubGVuZ3RoICE9PSA0IHx8XHJcbiAgICAnJy5zcGxpdCgvLj8vKS5sZW5ndGggfHxcclxuICAgICcuJy5zcGxpdCgvKCkoKS8pLmxlbmd0aCA+IDFcclxuKSB7XHJcbiAgICAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBjb21wbGlhbnRFeGVjTnBjZyA9IC8oKT8/Ly5leGVjKCcnKVsxXSA9PT0gdm9pZCAwOyAvLyBOUENHOiBub25wYXJ0aWNpcGF0aW5nIGNhcHR1cmluZyBncm91cFxyXG5cclxuICAgICAgICBTdHJpbmdQcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiAoc2VwYXJhdG9yLCBsaW1pdCkge1xyXG4gICAgICAgICAgICB2YXIgc3RyaW5nID0gdGhpcztcclxuICAgICAgICAgICAgaWYgKHNlcGFyYXRvciA9PT0gdm9pZCAwICYmIGxpbWl0ID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIElmIGBzZXBhcmF0b3JgIGlzIG5vdCBhIHJlZ2V4LCB1c2UgbmF0aXZlIHNwbGl0XHJcbiAgICAgICAgICAgIGlmIChfdG9TdHJpbmcuY2FsbChzZXBhcmF0b3IpICE9PSAnW29iamVjdCBSZWdFeHBdJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ19zcGxpdC5jYWxsKHRoaXMsIHNlcGFyYXRvciwgbGltaXQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gW10sXHJcbiAgICAgICAgICAgICAgICBmbGFncyA9IChzZXBhcmF0b3IuaWdub3JlQ2FzZSA/ICdpJyA6ICcnKSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3IubXVsdGlsaW5lICA/ICdtJyA6ICcnKSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3IuZXh0ZW5kZWQgICA/ICd4JyA6ICcnKSArIC8vIFByb3Bvc2VkIGZvciBFUzZcclxuICAgICAgICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5zdGlja3kgICAgID8gJ3knIDogJycpLCAvLyBGaXJlZm94IDMrXHJcbiAgICAgICAgICAgICAgICBsYXN0TGFzdEluZGV4ID0gMCxcclxuICAgICAgICAgICAgICAgIC8vIE1ha2UgYGdsb2JhbGAgYW5kIGF2b2lkIGBsYXN0SW5kZXhgIGlzc3VlcyBieSB3b3JraW5nIHdpdGggYSBjb3B5XHJcbiAgICAgICAgICAgICAgICBzZXBhcmF0b3IyLCBtYXRjaCwgbGFzdEluZGV4LCBsYXN0TGVuZ3RoO1xyXG4gICAgICAgICAgICBzZXBhcmF0b3IgPSBuZXcgUmVnRXhwKHNlcGFyYXRvci5zb3VyY2UsIGZsYWdzICsgJ2cnKTtcclxuICAgICAgICAgICAgc3RyaW5nICs9ICcnOyAvLyBUeXBlLWNvbnZlcnRcclxuICAgICAgICAgICAgaWYgKCFjb21wbGlhbnRFeGVjTnBjZykge1xyXG4gICAgICAgICAgICAgICAgLy8gRG9lc24ndCBuZWVkIGZsYWdzIGd5LCBidXQgdGhleSBkb24ndCBodXJ0XHJcbiAgICAgICAgICAgICAgICBzZXBhcmF0b3IyID0gbmV3IFJlZ0V4cCgnXicgKyBzZXBhcmF0b3Iuc291cmNlICsgJyQoPyFcXFxccyknLCBmbGFncyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLyogVmFsdWVzIGZvciBgbGltaXRgLCBwZXIgdGhlIHNwZWM6XHJcbiAgICAgICAgICAgICAqIElmIHVuZGVmaW5lZDogNDI5NDk2NzI5NSAvLyBNYXRoLnBvdygyLCAzMikgLSAxXHJcbiAgICAgICAgICAgICAqIElmIDAsIEluZmluaXR5LCBvciBOYU46IDBcclxuICAgICAgICAgICAgICogSWYgcG9zaXRpdmUgbnVtYmVyOiBsaW1pdCA9IE1hdGguZmxvb3IobGltaXQpOyBpZiAobGltaXQgPiA0Mjk0OTY3Mjk1KSBsaW1pdCAtPSA0Mjk0OTY3Mjk2O1xyXG4gICAgICAgICAgICAgKiBJZiBuZWdhdGl2ZSBudW1iZXI6IDQyOTQ5NjcyOTYgLSBNYXRoLmZsb29yKE1hdGguYWJzKGxpbWl0KSlcclxuICAgICAgICAgICAgICogSWYgb3RoZXI6IFR5cGUtY29udmVydCwgdGhlbiB1c2UgdGhlIGFib3ZlIHJ1bGVzXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBsaW1pdCA9IGxpbWl0ID09PSB2b2lkIDAgP1xyXG4gICAgICAgICAgICAgICAgLTEgPj4+IDAgOiAvLyBNYXRoLnBvdygyLCAzMikgLSAxXHJcbiAgICAgICAgICAgICAgICBUb1VpbnQzMihsaW1pdCk7XHJcbiAgICAgICAgICAgIHdoaWxlIChtYXRjaCA9IHNlcGFyYXRvci5leGVjKHN0cmluZykpIHtcclxuICAgICAgICAgICAgICAgIC8vIGBzZXBhcmF0b3IubGFzdEluZGV4YCBpcyBub3QgcmVsaWFibGUgY3Jvc3MtYnJvd3NlclxyXG4gICAgICAgICAgICAgICAgbGFzdEluZGV4ID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBpZiAobGFzdEluZGV4ID4gbGFzdExhc3RJbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHN0cmluZy5zbGljZShsYXN0TGFzdEluZGV4LCBtYXRjaC5pbmRleCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpeCBicm93c2VycyB3aG9zZSBgZXhlY2AgbWV0aG9kcyBkb24ndCBjb25zaXN0ZW50bHkgcmV0dXJuIGB1bmRlZmluZWRgIGZvclxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3Vwc1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghY29tcGxpYW50RXhlY05wY2cgJiYgbWF0Y2gubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFswXS5yZXBsYWNlKHNlcGFyYXRvcjIsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aCAtIDI7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHNbaV0gPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFtpXSA9IHZvaWQgMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2gubGVuZ3RoID4gMSAmJiBtYXRjaC5pbmRleCA8IHN0cmluZy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXlQcm90b3R5cGUucHVzaC5hcHBseShvdXRwdXQsIG1hdGNoLnNsaWNlKDEpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdExlbmd0aCA9IG1hdGNoWzBdLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBsYXN0TGFzdEluZGV4ID0gbGFzdEluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXRwdXQubGVuZ3RoID49IGxpbWl0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChzZXBhcmF0b3IubGFzdEluZGV4ID09PSBtYXRjaC5pbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlcGFyYXRvci5sYXN0SW5kZXgrKzsgLy8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChsYXN0TGFzdEluZGV4ID09PSBzdHJpbmcubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobGFzdExlbmd0aCB8fCAhc2VwYXJhdG9yLnRlc3QoJycpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goJycpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goc3RyaW5nLnNsaWNlKGxhc3RMYXN0SW5kZXgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0Lmxlbmd0aCA+IGxpbWl0ID8gb3V0cHV0LnNsaWNlKDAsIGxpbWl0KSA6IG91dHB1dDtcclxuICAgICAgICB9O1xyXG4gICAgfSgpKTtcclxuXHJcbi8vIFtidWdmaXgsIGNocm9tZV1cclxuLy8gSWYgc2VwYXJhdG9yIGlzIHVuZGVmaW5lZCwgdGhlbiB0aGUgcmVzdWx0IGFycmF5IGNvbnRhaW5zIGp1c3Qgb25lIFN0cmluZyxcclxuLy8gd2hpY2ggaXMgdGhlIHRoaXMgdmFsdWUgKGNvbnZlcnRlZCB0byBhIFN0cmluZykuIElmIGxpbWl0IGlzIG5vdCB1bmRlZmluZWQsXHJcbi8vIHRoZW4gdGhlIG91dHB1dCBhcnJheSBpcyB0cnVuY2F0ZWQgc28gdGhhdCBpdCBjb250YWlucyBubyBtb3JlIHRoYW4gbGltaXRcclxuLy8gZWxlbWVudHMuXHJcbi8vIFwiMFwiLnNwbGl0KHVuZGVmaW5lZCwgMCkgLT4gW11cclxufSBlbHNlIGlmICgnMCcuc3BsaXQodm9pZCAwLCAwKS5sZW5ndGgpIHtcclxuICAgIFN0cmluZ1Byb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIHNwbGl0KHNlcGFyYXRvciwgbGltaXQpIHtcclxuICAgICAgICBpZiAoc2VwYXJhdG9yID09PSB2b2lkIDAgJiYgbGltaXQgPT09IDApIHsgcmV0dXJuIFtdOyB9XHJcbiAgICAgICAgcmV0dXJuIHN0cmluZ19zcGxpdC5jYWxsKHRoaXMsIHNlcGFyYXRvciwgbGltaXQpO1xyXG4gICAgfTtcclxufVxyXG5cclxuLy8gRUNNQS0yNjIsIDNyZCBCLjIuM1xyXG4vLyBOb3QgYW4gRUNNQVNjcmlwdCBzdGFuZGFyZCwgYWx0aG91Z2ggRUNNQVNjcmlwdCAzcmQgRWRpdGlvbiBoYXMgYVxyXG4vLyBub24tbm9ybWF0aXZlIHNlY3Rpb24gc3VnZ2VzdGluZyB1bmlmb3JtIHNlbWFudGljcyBhbmQgaXQgc2hvdWxkIGJlXHJcbi8vIG5vcm1hbGl6ZWQgYWNyb3NzIGFsbCBicm93c2Vyc1xyXG4vLyBbYnVnZml4LCBJRSBsdCA5XSBJRSA8IDkgc3Vic3RyKCkgd2l0aCBuZWdhdGl2ZSB2YWx1ZSBub3Qgd29ya2luZyBpbiBJRVxyXG52YXIgc3RyaW5nX3N1YnN0ciA9IFN0cmluZ1Byb3RvdHlwZS5zdWJzdHI7XHJcbnZhciBoYXNOZWdhdGl2ZVN1YnN0ckJ1ZyA9ICcnLnN1YnN0ciAmJiAnMGInLnN1YnN0cigtMSkgIT09ICdiJztcclxuZGVmaW5lUHJvcGVydGllcyhTdHJpbmdQcm90b3R5cGUsIHtcclxuICAgIHN1YnN0cjogZnVuY3Rpb24gc3Vic3RyKHN0YXJ0LCBsZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gc3RyaW5nX3N1YnN0ci5jYWxsKFxyXG4gICAgICAgICAgICB0aGlzLFxyXG4gICAgICAgICAgICBzdGFydCA8IDAgPyAoKHN0YXJ0ID0gdGhpcy5sZW5ndGggKyBzdGFydCkgPCAwID8gMCA6IHN0YXJ0KSA6IHN0YXJ0LFxyXG4gICAgICAgICAgICBsZW5ndGhcclxuICAgICAgICApO1xyXG4gICAgfVxyXG59LCBoYXNOZWdhdGl2ZVN1YnN0ckJ1Zyk7XHJcblxyXG59LHt9XSwxNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gW1xyXG4gIC8vIHN0cmVhbWluZyB0cmFuc3BvcnRzXHJcbiAgcmVxdWlyZSgnLi90cmFuc3BvcnQvd2Vic29ja2V0JylcclxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC94aHItc3RyZWFtaW5nJylcclxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC94ZHItc3RyZWFtaW5nJylcclxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC9ldmVudHNvdXJjZScpXHJcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQvbGliL2lmcmFtZS13cmFwJykocmVxdWlyZSgnLi90cmFuc3BvcnQvZXZlbnRzb3VyY2UnKSlcclxuXHJcbiAgLy8gcG9sbGluZyB0cmFuc3BvcnRzXHJcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQvaHRtbGZpbGUnKVxyXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L2xpYi9pZnJhbWUtd3JhcCcpKHJlcXVpcmUoJy4vdHJhbnNwb3J0L2h0bWxmaWxlJykpXHJcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQveGhyLXBvbGxpbmcnKVxyXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L3hkci1wb2xsaW5nJylcclxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC9saWIvaWZyYW1lLXdyYXAnKShyZXF1aXJlKCcuL3RyYW5zcG9ydC94aHItcG9sbGluZycpKVxyXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L2pzb25wLXBvbGxpbmcnKVxyXG5dO1xyXG5cclxufSx7XCIuL3RyYW5zcG9ydC9ldmVudHNvdXJjZVwiOjIwLFwiLi90cmFuc3BvcnQvaHRtbGZpbGVcIjoyMSxcIi4vdHJhbnNwb3J0L2pzb25wLXBvbGxpbmdcIjoyMyxcIi4vdHJhbnNwb3J0L2xpYi9pZnJhbWUtd3JhcFwiOjI2LFwiLi90cmFuc3BvcnQvd2Vic29ja2V0XCI6MzgsXCIuL3RyYW5zcG9ydC94ZHItcG9sbGluZ1wiOjM5LFwiLi90cmFuc3BvcnQveGRyLXN0cmVhbWluZ1wiOjQwLFwiLi90cmFuc3BvcnQveGhyLXBvbGxpbmdcIjo0MSxcIi4vdHJhbnNwb3J0L3hoci1zdHJlYW1pbmdcIjo0Mn1dLDE3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcclxuICAsIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxyXG4gICwgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy9ldmVudCcpXHJcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3VybCcpXHJcbiAgLCBYSFIgPSBnbG9iYWwuWE1MSHR0cFJlcXVlc3RcclxuICA7XHJcblxyXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xyXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpicm93c2VyOnhocicpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBBYnN0cmFjdFhIUk9iamVjdChtZXRob2QsIHVybCwgcGF5bG9hZCwgb3B0cykge1xyXG4gIGRlYnVnKG1ldGhvZCwgdXJsKTtcclxuICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XHJcblxyXG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgc2VsZi5fc3RhcnQobWV0aG9kLCB1cmwsIHBheWxvYWQsIG9wdHMpO1xyXG4gIH0sIDApO1xyXG59XHJcblxyXG5pbmhlcml0cyhBYnN0cmFjdFhIUk9iamVjdCwgRXZlbnRFbWl0dGVyKTtcclxuXHJcbkFic3RyYWN0WEhST2JqZWN0LnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbihtZXRob2QsIHVybCwgcGF5bG9hZCwgb3B0cykge1xyXG4gIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgdHJ5IHtcclxuICAgIHRoaXMueGhyID0gbmV3IFhIUigpO1xyXG4gIH0gY2F0Y2ggKHgpIHtcclxuICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcclxuICB9XHJcblxyXG4gIGlmICghdGhpcy54aHIpIHtcclxuICAgIGRlYnVnKCdubyB4aHInKTtcclxuICAgIHRoaXMuZW1pdCgnZmluaXNoJywgMCwgJ25vIHhociBzdXBwb3J0Jyk7XHJcbiAgICB0aGlzLl9jbGVhbnVwKCk7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICAvLyBzZXZlcmFsIGJyb3dzZXJzIGNhY2hlIFBPU1RzXHJcbiAgdXJsID0gdXJsVXRpbHMuYWRkUXVlcnkodXJsLCAndD0nICsgKCtuZXcgRGF0ZSgpKSk7XHJcblxyXG4gIC8vIEV4cGxvcmVyIHRlbmRzIHRvIGtlZXAgY29ubmVjdGlvbiBvcGVuLCBldmVuIGFmdGVyIHRoZVxyXG4gIC8vIHRhYiBnZXRzIGNsb3NlZDogaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvNTI4MFxyXG4gIHRoaXMudW5sb2FkUmVmID0gdXRpbHMudW5sb2FkQWRkKGZ1bmN0aW9uKCkge1xyXG4gICAgZGVidWcoJ3VubG9hZCBjbGVhbnVwJyk7XHJcbiAgICBzZWxmLl9jbGVhbnVwKHRydWUpO1xyXG4gIH0pO1xyXG4gIHRyeSB7XHJcbiAgICB0aGlzLnhoci5vcGVuKG1ldGhvZCwgdXJsLCB0cnVlKTtcclxuICAgIGlmICh0aGlzLnRpbWVvdXQgJiYgJ3RpbWVvdXQnIGluIHRoaXMueGhyKSB7XHJcbiAgICAgIHRoaXMueGhyLnRpbWVvdXQgPSB0aGlzLnRpbWVvdXQ7XHJcbiAgICAgIHRoaXMueGhyLm9udGltZW91dCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGRlYnVnKCd4aHIgdGltZW91dCcpO1xyXG4gICAgICAgIHNlbGYuZW1pdCgnZmluaXNoJywgMCwgJycpO1xyXG4gICAgICAgIHNlbGYuX2NsZWFudXAoZmFsc2UpO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH0gY2F0Y2ggKGUpIHtcclxuICAgIGRlYnVnKCdleGNlcHRpb24nLCBlKTtcclxuICAgIC8vIElFIHJhaXNlcyBhbiBleGNlcHRpb24gb24gd3JvbmcgcG9ydC5cclxuICAgIHRoaXMuZW1pdCgnZmluaXNoJywgMCwgJycpO1xyXG4gICAgdGhpcy5fY2xlYW51cChmYWxzZSk7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBpZiAoKCFvcHRzIHx8ICFvcHRzLm5vQ3JlZGVudGlhbHMpICYmIEFic3RyYWN0WEhST2JqZWN0LnN1cHBvcnRzQ09SUykge1xyXG4gICAgZGVidWcoJ3dpdGhDcmVkZW50aWFscycpO1xyXG4gICAgLy8gTW96aWxsYSBkb2NzIHNheXMgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vWE1MSHR0cFJlcXVlc3QgOlxyXG4gICAgLy8gXCJUaGlzIG5ldmVyIGFmZmVjdHMgc2FtZS1zaXRlIHJlcXVlc3RzLlwiXHJcblxyXG4gICAgdGhpcy54aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcclxuICB9XHJcbiAgaWYgKG9wdHMgJiYgb3B0cy5oZWFkZXJzKSB7XHJcbiAgICBmb3IgKHZhciBrZXkgaW4gb3B0cy5oZWFkZXJzKSB7XHJcbiAgICAgIHRoaXMueGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCBvcHRzLmhlYWRlcnNba2V5XSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB0aGlzLnhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcclxuICAgIGlmIChzZWxmLnhocikge1xyXG4gICAgICB2YXIgeCA9IHNlbGYueGhyO1xyXG4gICAgICB2YXIgdGV4dCwgc3RhdHVzO1xyXG4gICAgICBkZWJ1ZygncmVhZHlTdGF0ZScsIHgucmVhZHlTdGF0ZSk7XHJcbiAgICAgIHN3aXRjaCAoeC5yZWFkeVN0YXRlKSB7XHJcbiAgICAgIGNhc2UgMzpcclxuICAgICAgICAvLyBJRSBkb2Vzbid0IGxpa2UgcGVla2luZyBpbnRvIHJlc3BvbnNlVGV4dCBvciBzdGF0dXNcclxuICAgICAgICAvLyBvbiBNaWNyb3NvZnQuWE1MSFRUUCBhbmQgcmVhZHlzdGF0ZT0zXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIHN0YXR1cyA9IHguc3RhdHVzO1xyXG4gICAgICAgICAgdGV4dCA9IHgucmVzcG9uc2VUZXh0O1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcclxuICAgICAgICB9XHJcbiAgICAgICAgZGVidWcoJ3N0YXR1cycsIHN0YXR1cyk7XHJcbiAgICAgICAgLy8gSUUgcmV0dXJucyAxMjIzIGZvciAyMDQ6IGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzE0NTBcclxuICAgICAgICBpZiAoc3RhdHVzID09PSAxMjIzKSB7XHJcbiAgICAgICAgICBzdGF0dXMgPSAyMDQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJRSBkb2VzIHJldHVybiByZWFkeXN0YXRlID09IDMgZm9yIDQwNCBhbnN3ZXJzLlxyXG4gICAgICAgIGlmIChzdGF0dXMgPT09IDIwMCAmJiB0ZXh0ICYmIHRleHQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgZGVidWcoJ2NodW5rJyk7XHJcbiAgICAgICAgICBzZWxmLmVtaXQoJ2NodW5rJywgc3RhdHVzLCB0ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgNDpcclxuICAgICAgICBzdGF0dXMgPSB4LnN0YXR1cztcclxuICAgICAgICBkZWJ1Zygnc3RhdHVzJywgc3RhdHVzKTtcclxuICAgICAgICAvLyBJRSByZXR1cm5zIDEyMjMgZm9yIDIwNDogaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTQ1MFxyXG4gICAgICAgIGlmIChzdGF0dXMgPT09IDEyMjMpIHtcclxuICAgICAgICAgIHN0YXR1cyA9IDIwNDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSUUgcmV0dXJucyB0aGlzIGZvciBhIGJhZCBwb3J0XHJcbiAgICAgICAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L3dpbmRvd3MvZGVza3RvcC9hYTM4Mzc3MCh2PXZzLjg1KS5hc3B4XHJcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gMTIwMDUgfHwgc3RhdHVzID09PSAxMjAyOSkge1xyXG4gICAgICAgICAgc3RhdHVzID0gMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRlYnVnKCdmaW5pc2gnLCBzdGF0dXMsIHgucmVzcG9uc2VUZXh0KTtcclxuICAgICAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcsIHN0YXR1cywgeC5yZXNwb25zZVRleHQpO1xyXG4gICAgICAgIHNlbGYuX2NsZWFudXAoZmFsc2UpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgdHJ5IHtcclxuICAgIHNlbGYueGhyLnNlbmQocGF5bG9hZCk7XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgc2VsZi5lbWl0KCdmaW5pc2gnLCAwLCAnJyk7XHJcbiAgICBzZWxmLl9jbGVhbnVwKGZhbHNlKTtcclxuICB9XHJcbn07XHJcblxyXG5BYnN0cmFjdFhIUk9iamVjdC5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbihhYm9ydCkge1xyXG4gIGRlYnVnKCdjbGVhbnVwJyk7XHJcbiAgaWYgKCF0aGlzLnhocikge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xyXG4gIHV0aWxzLnVubG9hZERlbCh0aGlzLnVubG9hZFJlZik7XHJcblxyXG4gIC8vIElFIG5lZWRzIHRoaXMgZmllbGQgdG8gYmUgYSBmdW5jdGlvblxyXG4gIHRoaXMueGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge307XHJcbiAgaWYgKHRoaXMueGhyLm9udGltZW91dCkge1xyXG4gICAgdGhpcy54aHIub250aW1lb3V0ID0gbnVsbDtcclxuICB9XHJcblxyXG4gIGlmIChhYm9ydCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgdGhpcy54aHIuYWJvcnQoKTtcclxuICAgIH0gY2F0Y2ggKHgpIHtcclxuICAgICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxyXG4gICAgfVxyXG4gIH1cclxuICB0aGlzLnVubG9hZFJlZiA9IHRoaXMueGhyID0gbnVsbDtcclxufTtcclxuXHJcbkFic3RyYWN0WEhST2JqZWN0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xyXG4gIGRlYnVnKCdjbG9zZScpO1xyXG4gIHRoaXMuX2NsZWFudXAodHJ1ZSk7XHJcbn07XHJcblxyXG5BYnN0cmFjdFhIUk9iamVjdC5lbmFibGVkID0gISFYSFI7XHJcbi8vIG92ZXJyaWRlIFhNTEh0dHBSZXF1ZXN0IGZvciBJRTYvN1xyXG4vLyBvYmZ1c2NhdGUgdG8gYXZvaWQgZmlyZXdhbGxzXHJcbnZhciBheG8gPSBbJ0FjdGl2ZSddLmNvbmNhdCgnT2JqZWN0Jykuam9pbignWCcpO1xyXG5pZiAoIUFic3RyYWN0WEhST2JqZWN0LmVuYWJsZWQgJiYgKGF4byBpbiBnbG9iYWwpKSB7XHJcbiAgZGVidWcoJ292ZXJyaWRpbmcgeG1saHR0cHJlcXVlc3QnKTtcclxuICBYSFIgPSBmdW5jdGlvbigpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIHJldHVybiBuZXcgZ2xvYmFsW2F4b10oJ01pY3Jvc29mdC5YTUxIVFRQJyk7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gIH07XHJcbiAgQWJzdHJhY3RYSFJPYmplY3QuZW5hYmxlZCA9ICEhbmV3IFhIUigpO1xyXG59XHJcblxyXG52YXIgY29ycyA9IGZhbHNlO1xyXG50cnkge1xyXG4gIGNvcnMgPSAnd2l0aENyZWRlbnRpYWxzJyBpbiBuZXcgWEhSKCk7XHJcbn0gY2F0Y2ggKGlnbm9yZWQpIHtcclxuICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XHJcbn1cclxuXHJcbkFic3RyYWN0WEhST2JqZWN0LnN1cHBvcnRzQ09SUyA9IGNvcnM7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEFic3RyYWN0WEhST2JqZWN0O1xyXG5cclxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9LHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXHJcblxyXG59LHtcIi4uLy4uL3V0aWxzL2V2ZW50XCI6NDYsXCIuLi8uLi91dGlscy91cmxcIjo1MixcImRlYnVnXCI6NTQsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1Nn1dLDE4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuKGZ1bmN0aW9uIChnbG9iYWwpe1xyXG5tb2R1bGUuZXhwb3J0cyA9IGdsb2JhbC5FdmVudFNvdXJjZTtcclxuXHJcbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxyXG5cclxufSx7fV0sMTk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4oZnVuY3Rpb24gKGdsb2JhbCl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBEcml2ZXIgPSBnbG9iYWwuV2ViU29ja2V0IHx8IGdsb2JhbC5Nb3pXZWJTb2NrZXQ7XHJcbmlmIChEcml2ZXIpIHtcclxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIFdlYlNvY2tldEJyb3dzZXJEcml2ZXIodXJsKSB7XHJcblx0XHRyZXR1cm4gbmV3IERyaXZlcih1cmwpO1xyXG5cdH07XHJcbn0gZWxzZSB7XHJcblx0bW9kdWxlLmV4cG9ydHMgPSB1bmRlZmluZWQ7XHJcbn1cclxuXHJcbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxyXG5cclxufSx7fV0sMjA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXHJcbiAgLCBBamF4QmFzZWRUcmFuc3BvcnQgPSByZXF1aXJlKCcuL2xpYi9hamF4LWJhc2VkJylcclxuICAsIEV2ZW50U291cmNlUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3JlY2VpdmVyL2V2ZW50c291cmNlJylcclxuICAsIFhIUkNvcnNPYmplY3QgPSByZXF1aXJlKCcuL3NlbmRlci94aHItY29ycycpXHJcbiAgLCBFdmVudFNvdXJjZURyaXZlciA9IHJlcXVpcmUoJ2V2ZW50c291cmNlJylcclxuICA7XHJcblxyXG5mdW5jdGlvbiBFdmVudFNvdXJjZVRyYW5zcG9ydCh0cmFuc1VybCkge1xyXG4gIGlmICghRXZlbnRTb3VyY2VUcmFuc3BvcnQuZW5hYmxlZCgpKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcclxuICB9XHJcblxyXG4gIEFqYXhCYXNlZFRyYW5zcG9ydC5jYWxsKHRoaXMsIHRyYW5zVXJsLCAnL2V2ZW50c291cmNlJywgRXZlbnRTb3VyY2VSZWNlaXZlciwgWEhSQ29yc09iamVjdCk7XHJcbn1cclxuXHJcbmluaGVyaXRzKEV2ZW50U291cmNlVHJhbnNwb3J0LCBBamF4QmFzZWRUcmFuc3BvcnQpO1xyXG5cclxuRXZlbnRTb3VyY2VUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xyXG4gIHJldHVybiAhIUV2ZW50U291cmNlRHJpdmVyO1xyXG59O1xyXG5cclxuRXZlbnRTb3VyY2VUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICdldmVudHNvdXJjZSc7XHJcbkV2ZW50U291cmNlVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFNvdXJjZVRyYW5zcG9ydDtcclxuXHJcbn0se1wiLi9saWIvYWpheC1iYXNlZFwiOjI0LFwiLi9yZWNlaXZlci9ldmVudHNvdXJjZVwiOjI5LFwiLi9zZW5kZXIveGhyLWNvcnNcIjozNSxcImV2ZW50c291cmNlXCI6MTgsXCJpbmhlcml0c1wiOjU2fV0sMjE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXHJcbiAgLCBIdG1sZmlsZVJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlci9odG1sZmlsZScpXHJcbiAgLCBYSFJMb2NhbE9iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hoci1sb2NhbCcpXHJcbiAgLCBBamF4QmFzZWRUcmFuc3BvcnQgPSByZXF1aXJlKCcuL2xpYi9hamF4LWJhc2VkJylcclxuICA7XHJcblxyXG5mdW5jdGlvbiBIdG1sRmlsZVRyYW5zcG9ydCh0cmFuc1VybCkge1xyXG4gIGlmICghSHRtbGZpbGVSZWNlaXZlci5lbmFibGVkKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcclxuICB9XHJcbiAgQWpheEJhc2VkVHJhbnNwb3J0LmNhbGwodGhpcywgdHJhbnNVcmwsICcvaHRtbGZpbGUnLCBIdG1sZmlsZVJlY2VpdmVyLCBYSFJMb2NhbE9iamVjdCk7XHJcbn1cclxuXHJcbmluaGVyaXRzKEh0bWxGaWxlVHJhbnNwb3J0LCBBamF4QmFzZWRUcmFuc3BvcnQpO1xyXG5cclxuSHRtbEZpbGVUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKGluZm8pIHtcclxuICByZXR1cm4gSHRtbGZpbGVSZWNlaXZlci5lbmFibGVkICYmIGluZm8uc2FtZU9yaWdpbjtcclxufTtcclxuXHJcbkh0bWxGaWxlVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAnaHRtbGZpbGUnO1xyXG5IdG1sRmlsZVRyYW5zcG9ydC5yb3VuZFRyaXBzID0gMjtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSHRtbEZpbGVUcmFuc3BvcnQ7XHJcblxyXG59LHtcIi4vbGliL2FqYXgtYmFzZWRcIjoyNCxcIi4vcmVjZWl2ZXIvaHRtbGZpbGVcIjozMCxcIi4vc2VuZGVyL3hoci1sb2NhbFwiOjM3LFwiaW5oZXJpdHNcIjo1Nn1dLDIyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuKGZ1bmN0aW9uIChwcm9jZXNzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuLy8gRmV3IGNvb2wgdHJhbnNwb3J0cyBkbyB3b3JrIG9ubHkgZm9yIHNhbWUtb3JpZ2luLiBJbiBvcmRlciB0byBtYWtlXHJcbi8vIHRoZW0gd29yayBjcm9zcy1kb21haW4gd2Ugc2hhbGwgdXNlIGlmcmFtZSwgc2VydmVkIGZyb20gdGhlXHJcbi8vIHJlbW90ZSBkb21haW4uIE5ldyBicm93c2VycyBoYXZlIGNhcGFiaWxpdGllcyB0byBjb21tdW5pY2F0ZSB3aXRoXHJcbi8vIGNyb3NzIGRvbWFpbiBpZnJhbWUgdXNpbmcgcG9zdE1lc3NhZ2UoKS4gSW4gSUUgaXQgd2FzIGltcGxlbWVudGVkXHJcbi8vIGZyb20gSUUgOCssIGJ1dCBvZiBjb3Vyc2UsIElFIGdvdCBzb21lIGRldGFpbHMgd3Jvbmc6XHJcbi8vICAgIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9jYzE5NzAxNSh2PVZTLjg1KS5hc3B4XHJcbi8vICAgIGh0dHA6Ly9zdGV2ZXNvdWRlcnMuY29tL21pc2MvdGVzdC1wb3N0bWVzc2FnZS5waHBcclxuXHJcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcclxuICAsIEpTT04zID0gcmVxdWlyZSgnanNvbjMnKVxyXG4gICwgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXHJcbiAgLCB2ZXJzaW9uID0gcmVxdWlyZSgnLi4vdmVyc2lvbicpXHJcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL3VybCcpXHJcbiAgLCBpZnJhbWVVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2lmcmFtZScpXHJcbiAgLCBldmVudFV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvZXZlbnQnKVxyXG4gICwgcmFuZG9tID0gcmVxdWlyZSgnLi4vdXRpbHMvcmFuZG9tJylcclxuICA7XHJcblxyXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xyXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDp0cmFuc3BvcnQ6aWZyYW1lJyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIElmcmFtZVRyYW5zcG9ydCh0cmFuc3BvcnQsIHRyYW5zVXJsLCBiYXNlVXJsKSB7XHJcbiAgaWYgKCFJZnJhbWVUcmFuc3BvcnQuZW5hYmxlZCgpKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcclxuICB9XHJcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XHJcblxyXG4gIHZhciBzZWxmID0gdGhpcztcclxuICB0aGlzLm9yaWdpbiA9IHVybFV0aWxzLmdldE9yaWdpbihiYXNlVXJsKTtcclxuICB0aGlzLmJhc2VVcmwgPSBiYXNlVXJsO1xyXG4gIHRoaXMudHJhbnNVcmwgPSB0cmFuc1VybDtcclxuICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcclxuICB0aGlzLndpbmRvd0lkID0gcmFuZG9tLnN0cmluZyg4KTtcclxuXHJcbiAgdmFyIGlmcmFtZVVybCA9IHVybFV0aWxzLmFkZFBhdGgoYmFzZVVybCwgJy9pZnJhbWUuaHRtbCcpICsgJyMnICsgdGhpcy53aW5kb3dJZDtcclxuICBkZWJ1Zyh0cmFuc3BvcnQsIHRyYW5zVXJsLCBpZnJhbWVVcmwpO1xyXG5cclxuICB0aGlzLmlmcmFtZU9iaiA9IGlmcmFtZVV0aWxzLmNyZWF0ZUlmcmFtZShpZnJhbWVVcmwsIGZ1bmN0aW9uKHIpIHtcclxuICAgIGRlYnVnKCdlcnIgY2FsbGJhY2snKTtcclxuICAgIHNlbGYuZW1pdCgnY2xvc2UnLCAxMDA2LCAnVW5hYmxlIHRvIGxvYWQgYW4gaWZyYW1lICgnICsgciArICcpJyk7XHJcbiAgICBzZWxmLmNsb3NlKCk7XHJcbiAgfSk7XHJcblxyXG4gIHRoaXMub25tZXNzYWdlQ2FsbGJhY2sgPSB0aGlzLl9tZXNzYWdlLmJpbmQodGhpcyk7XHJcbiAgZXZlbnRVdGlscy5hdHRhY2hFdmVudCgnbWVzc2FnZScsIHRoaXMub25tZXNzYWdlQ2FsbGJhY2spO1xyXG59XHJcblxyXG5pbmhlcml0cyhJZnJhbWVUcmFuc3BvcnQsIEV2ZW50RW1pdHRlcik7XHJcblxyXG5JZnJhbWVUcmFuc3BvcnQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XHJcbiAgZGVidWcoJ2Nsb3NlJyk7XHJcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcclxuICBpZiAodGhpcy5pZnJhbWVPYmopIHtcclxuICAgIGV2ZW50VXRpbHMuZGV0YWNoRXZlbnQoJ21lc3NhZ2UnLCB0aGlzLm9ubWVzc2FnZUNhbGxiYWNrKTtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIFdoZW4gdGhlIGlmcmFtZSBpcyBub3QgbG9hZGVkLCBJRSByYWlzZXMgYW4gZXhjZXB0aW9uXHJcbiAgICAgIC8vIG9uICdjb250ZW50V2luZG93Jy5cclxuICAgICAgdGhpcy5wb3N0TWVzc2FnZSgnYycpO1xyXG4gICAgfSBjYXRjaCAoeCkge1xyXG4gICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XHJcbiAgICB9XHJcbiAgICB0aGlzLmlmcmFtZU9iai5jbGVhbnVwKCk7XHJcbiAgICB0aGlzLmlmcmFtZU9iaiA9IG51bGw7XHJcbiAgICB0aGlzLm9ubWVzc2FnZUNhbGxiYWNrID0gdGhpcy5pZnJhbWVPYmogPSBudWxsO1xyXG4gIH1cclxufTtcclxuXHJcbklmcmFtZVRyYW5zcG9ydC5wcm90b3R5cGUuX21lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XHJcbiAgZGVidWcoJ21lc3NhZ2UnLCBlLmRhdGEpO1xyXG4gIGlmICghdXJsVXRpbHMuaXNPcmlnaW5FcXVhbChlLm9yaWdpbiwgdGhpcy5vcmlnaW4pKSB7XHJcbiAgICBkZWJ1Zygnbm90IHNhbWUgb3JpZ2luJywgZS5vcmlnaW4sIHRoaXMub3JpZ2luKTtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIHZhciBpZnJhbWVNZXNzYWdlO1xyXG4gIHRyeSB7XHJcbiAgICBpZnJhbWVNZXNzYWdlID0gSlNPTjMucGFyc2UoZS5kYXRhKTtcclxuICB9IGNhdGNoIChpZ25vcmVkKSB7XHJcbiAgICBkZWJ1ZygnYmFkIGpzb24nLCBlLmRhdGEpO1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgaWYgKGlmcmFtZU1lc3NhZ2Uud2luZG93SWQgIT09IHRoaXMud2luZG93SWQpIHtcclxuICAgIGRlYnVnKCdtaXNtYXRjaGVkIHdpbmRvdyBpZCcsIGlmcmFtZU1lc3NhZ2Uud2luZG93SWQsIHRoaXMud2luZG93SWQpO1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgc3dpdGNoIChpZnJhbWVNZXNzYWdlLnR5cGUpIHtcclxuICBjYXNlICdzJzpcclxuICAgIHRoaXMuaWZyYW1lT2JqLmxvYWRlZCgpO1xyXG4gICAgLy8gd2luZG93IGdsb2JhbCBkZXBlbmRlbmN5XHJcbiAgICB0aGlzLnBvc3RNZXNzYWdlKCdzJywgSlNPTjMuc3RyaW5naWZ5KFtcclxuICAgICAgdmVyc2lvblxyXG4gICAgLCB0aGlzLnRyYW5zcG9ydFxyXG4gICAgLCB0aGlzLnRyYW5zVXJsXHJcbiAgICAsIHRoaXMuYmFzZVVybFxyXG4gICAgXSkpO1xyXG4gICAgYnJlYWs7XHJcbiAgY2FzZSAndCc6XHJcbiAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBpZnJhbWVNZXNzYWdlLmRhdGEpO1xyXG4gICAgYnJlYWs7XHJcbiAgY2FzZSAnYyc6XHJcbiAgICB2YXIgY2RhdGE7XHJcbiAgICB0cnkge1xyXG4gICAgICBjZGF0YSA9IEpTT04zLnBhcnNlKGlmcmFtZU1lc3NhZ2UuZGF0YSk7XHJcbiAgICB9IGNhdGNoIChpZ25vcmVkKSB7XHJcbiAgICAgIGRlYnVnKCdiYWQganNvbicsIGlmcmFtZU1lc3NhZ2UuZGF0YSk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHRoaXMuZW1pdCgnY2xvc2UnLCBjZGF0YVswXSwgY2RhdGFbMV0pO1xyXG4gICAgdGhpcy5jbG9zZSgpO1xyXG4gICAgYnJlYWs7XHJcbiAgfVxyXG59O1xyXG5cclxuSWZyYW1lVHJhbnNwb3J0LnByb3RvdHlwZS5wb3N0TWVzc2FnZSA9IGZ1bmN0aW9uKHR5cGUsIGRhdGEpIHtcclxuICBkZWJ1ZygncG9zdE1lc3NhZ2UnLCB0eXBlLCBkYXRhKTtcclxuICB0aGlzLmlmcmFtZU9iai5wb3N0KEpTT04zLnN0cmluZ2lmeSh7XHJcbiAgICB3aW5kb3dJZDogdGhpcy53aW5kb3dJZFxyXG4gICwgdHlwZTogdHlwZVxyXG4gICwgZGF0YTogZGF0YSB8fCAnJ1xyXG4gIH0pLCB0aGlzLm9yaWdpbik7XHJcbn07XHJcblxyXG5JZnJhbWVUcmFuc3BvcnQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihtZXNzYWdlKSB7XHJcbiAgZGVidWcoJ3NlbmQnLCBtZXNzYWdlKTtcclxuICB0aGlzLnBvc3RNZXNzYWdlKCdtJywgbWVzc2FnZSk7XHJcbn07XHJcblxyXG5JZnJhbWVUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xyXG4gIHJldHVybiBpZnJhbWVVdGlscy5pZnJhbWVFbmFibGVkO1xyXG59O1xyXG5cclxuSWZyYW1lVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAnaWZyYW1lJztcclxuSWZyYW1lVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJZnJhbWVUcmFuc3BvcnQ7XHJcblxyXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXHJcblxyXG59LHtcIi4uL3V0aWxzL2V2ZW50XCI6NDYsXCIuLi91dGlscy9pZnJhbWVcIjo0NyxcIi4uL3V0aWxzL3JhbmRvbVwiOjUwLFwiLi4vdXRpbHMvdXJsXCI6NTIsXCIuLi92ZXJzaW9uXCI6NTMsXCJkZWJ1Z1wiOjU0LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTYsXCJqc29uM1wiOjU3fV0sMjM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4oZnVuY3Rpb24gKGdsb2JhbCl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbi8vIFRoZSBzaW1wbGVzdCBhbmQgbW9zdCByb2J1c3QgdHJhbnNwb3J0LCB1c2luZyB0aGUgd2VsbC1rbm93IGNyb3NzXHJcbi8vIGRvbWFpbiBoYWNrIC0gSlNPTlAuIFRoaXMgdHJhbnNwb3J0IGlzIHF1aXRlIGluZWZmaWNpZW50IC0gb25lXHJcbi8vIG1lc3NhZ2UgY291bGQgdXNlIHVwIHRvIG9uZSBodHRwIHJlcXVlc3QuIEJ1dCBhdCBsZWFzdCBpdCB3b3JrcyBhbG1vc3RcclxuLy8gZXZlcnl3aGVyZS5cclxuLy8gS25vd24gbGltaXRhdGlvbnM6XHJcbi8vICAgbyB5b3Ugd2lsbCBnZXQgYSBzcGlubmluZyBjdXJzb3JcclxuLy8gICBvIGZvciBLb25xdWVyb3IgYSBkdW1iIHRpbWVyIGlzIG5lZWRlZCB0byBkZXRlY3QgZXJyb3JzXHJcblxyXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXHJcbiAgLCBTZW5kZXJSZWNlaXZlciA9IHJlcXVpcmUoJy4vbGliL3NlbmRlci1yZWNlaXZlcicpXHJcbiAgLCBKc29ucFJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlci9qc29ucCcpXHJcbiAgLCBqc29ucFNlbmRlciA9IHJlcXVpcmUoJy4vc2VuZGVyL2pzb25wJylcclxuICA7XHJcblxyXG5mdW5jdGlvbiBKc29uUFRyYW5zcG9ydCh0cmFuc1VybCkge1xyXG4gIGlmICghSnNvblBUcmFuc3BvcnQuZW5hYmxlZCgpKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcclxuICB9XHJcbiAgU2VuZGVyUmVjZWl2ZXIuY2FsbCh0aGlzLCB0cmFuc1VybCwgJy9qc29ucCcsIGpzb25wU2VuZGVyLCBKc29ucFJlY2VpdmVyKTtcclxufVxyXG5cclxuaW5oZXJpdHMoSnNvblBUcmFuc3BvcnQsIFNlbmRlclJlY2VpdmVyKTtcclxuXHJcbkpzb25QVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbigpIHtcclxuICByZXR1cm4gISFnbG9iYWwuZG9jdW1lbnQ7XHJcbn07XHJcblxyXG5Kc29uUFRyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ2pzb25wLXBvbGxpbmcnO1xyXG5Kc29uUFRyYW5zcG9ydC5yb3VuZFRyaXBzID0gMTtcclxuSnNvblBUcmFuc3BvcnQubmVlZEJvZHkgPSB0cnVlO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBKc29uUFRyYW5zcG9ydDtcclxuXHJcbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxyXG5cclxufSx7XCIuL2xpYi9zZW5kZXItcmVjZWl2ZXJcIjoyOCxcIi4vcmVjZWl2ZXIvanNvbnBcIjozMSxcIi4vc2VuZGVyL2pzb25wXCI6MzMsXCJpbmhlcml0c1wiOjU2fV0sMjQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXHJcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3VybCcpXHJcbiAgLCBTZW5kZXJSZWNlaXZlciA9IHJlcXVpcmUoJy4vc2VuZGVyLXJlY2VpdmVyJylcclxuICA7XHJcblxyXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xyXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDphamF4LWJhc2VkJyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUFqYXhTZW5kZXIoQWpheE9iamVjdCkge1xyXG4gIHJldHVybiBmdW5jdGlvbih1cmwsIHBheWxvYWQsIGNhbGxiYWNrKSB7XHJcbiAgICBkZWJ1ZygnY3JlYXRlIGFqYXggc2VuZGVyJywgdXJsLCBwYXlsb2FkKTtcclxuICAgIHZhciBvcHQgPSB7fTtcclxuICAgIGlmICh0eXBlb2YgcGF5bG9hZCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgb3B0LmhlYWRlcnMgPSB7J0NvbnRlbnQtdHlwZSc6ICd0ZXh0L3BsYWluJ307XHJcbiAgICB9XHJcbiAgICB2YXIgYWpheFVybCA9IHVybFV0aWxzLmFkZFBhdGgodXJsLCAnL3hocl9zZW5kJyk7XHJcbiAgICB2YXIgeG8gPSBuZXcgQWpheE9iamVjdCgnUE9TVCcsIGFqYXhVcmwsIHBheWxvYWQsIG9wdCk7XHJcbiAgICB4by5vbmNlKCdmaW5pc2gnLCBmdW5jdGlvbihzdGF0dXMpIHtcclxuICAgICAgZGVidWcoJ2ZpbmlzaCcsIHN0YXR1cyk7XHJcbiAgICAgIHhvID0gbnVsbDtcclxuXHJcbiAgICAgIGlmIChzdGF0dXMgIT09IDIwMCAmJiBzdGF0dXMgIT09IDIwNCkge1xyXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoJ2h0dHAgc3RhdHVzICcgKyBzdGF0dXMpKTtcclxuICAgICAgfVxyXG4gICAgICBjYWxsYmFjaygpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICAgIGRlYnVnKCdhYm9ydCcpO1xyXG4gICAgICB4by5jbG9zZSgpO1xyXG4gICAgICB4byA9IG51bGw7XHJcblxyXG4gICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdBYm9ydGVkJyk7XHJcbiAgICAgIGVyci5jb2RlID0gMTAwMDtcclxuICAgICAgY2FsbGJhY2soZXJyKTtcclxuICAgIH07XHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gQWpheEJhc2VkVHJhbnNwb3J0KHRyYW5zVXJsLCB1cmxTdWZmaXgsIFJlY2VpdmVyLCBBamF4T2JqZWN0KSB7XHJcbiAgU2VuZGVyUmVjZWl2ZXIuY2FsbCh0aGlzLCB0cmFuc1VybCwgdXJsU3VmZml4LCBjcmVhdGVBamF4U2VuZGVyKEFqYXhPYmplY3QpLCBSZWNlaXZlciwgQWpheE9iamVjdCk7XHJcbn1cclxuXHJcbmluaGVyaXRzKEFqYXhCYXNlZFRyYW5zcG9ydCwgU2VuZGVyUmVjZWl2ZXIpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBBamF4QmFzZWRUcmFuc3BvcnQ7XHJcblxyXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXHJcblxyXG59LHtcIi4uLy4uL3V0aWxzL3VybFwiOjUyLFwiLi9zZW5kZXItcmVjZWl2ZXJcIjoyOCxcImRlYnVnXCI6NTQsXCJpbmhlcml0c1wiOjU2fV0sMjU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXHJcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcclxuICA7XHJcblxyXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xyXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpidWZmZXJlZC1zZW5kZXInKTtcclxufVxyXG5cclxuZnVuY3Rpb24gQnVmZmVyZWRTZW5kZXIodXJsLCBzZW5kZXIpIHtcclxuICBkZWJ1Zyh1cmwpO1xyXG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xyXG4gIHRoaXMuc2VuZEJ1ZmZlciA9IFtdO1xyXG4gIHRoaXMuc2VuZGVyID0gc2VuZGVyO1xyXG4gIHRoaXMudXJsID0gdXJsO1xyXG59XHJcblxyXG5pbmhlcml0cyhCdWZmZXJlZFNlbmRlciwgRXZlbnRFbWl0dGVyKTtcclxuXHJcbkJ1ZmZlcmVkU2VuZGVyLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24obWVzc2FnZSkge1xyXG4gIGRlYnVnKCdzZW5kJywgbWVzc2FnZSk7XHJcbiAgdGhpcy5zZW5kQnVmZmVyLnB1c2gobWVzc2FnZSk7XHJcbiAgaWYgKCF0aGlzLnNlbmRTdG9wKSB7XHJcbiAgICB0aGlzLnNlbmRTY2hlZHVsZSgpO1xyXG4gIH1cclxufTtcclxuXHJcbi8vIEZvciBwb2xsaW5nIHRyYW5zcG9ydHMgaW4gYSBzaXR1YXRpb24gd2hlbiBpbiB0aGUgbWVzc2FnZSBjYWxsYmFjayxcclxuLy8gbmV3IG1lc3NhZ2UgaXMgYmVpbmcgc2VuZC4gSWYgdGhlIHNlbmRpbmcgY29ubmVjdGlvbiB3YXMgc3RhcnRlZFxyXG4vLyBiZWZvcmUgcmVjZWl2aW5nIG9uZSwgaXQgaXMgcG9zc2libGUgdG8gc2F0dXJhdGUgdGhlIG5ldHdvcmsgYW5kXHJcbi8vIHRpbWVvdXQgZHVlIHRvIHRoZSBsYWNrIG9mIHJlY2VpdmluZyBzb2NrZXQuIFRvIGF2b2lkIHRoYXQgd2UgZGVsYXlcclxuLy8gc2VuZGluZyBtZXNzYWdlcyBieSBzb21lIHNtYWxsIHRpbWUsIGluIG9yZGVyIHRvIGxldCByZWNlaXZpbmdcclxuLy8gY29ubmVjdGlvbiBiZSBzdGFydGVkIGJlZm9yZWhhbmQuIFRoaXMgaXMgb25seSBhIGhhbGZtZWFzdXJlIGFuZFxyXG4vLyBkb2VzIG5vdCBmaXggdGhlIGJpZyBwcm9ibGVtLCBidXQgaXQgZG9lcyBtYWtlIHRoZSB0ZXN0cyBnbyBtb3JlXHJcbi8vIHN0YWJsZSBvbiBzbG93IG5ldHdvcmtzLlxyXG5CdWZmZXJlZFNlbmRlci5wcm90b3R5cGUuc2VuZFNjaGVkdWxlV2FpdCA9IGZ1bmN0aW9uKCkge1xyXG4gIGRlYnVnKCdzZW5kU2NoZWR1bGVXYWl0Jyk7XHJcbiAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gIHZhciB0cmVmO1xyXG4gIHRoaXMuc2VuZFN0b3AgPSBmdW5jdGlvbigpIHtcclxuICAgIGRlYnVnKCdzZW5kU3RvcCcpO1xyXG4gICAgc2VsZi5zZW5kU3RvcCA9IG51bGw7XHJcbiAgICBjbGVhclRpbWVvdXQodHJlZik7XHJcbiAgfTtcclxuICB0cmVmID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgIGRlYnVnKCd0aW1lb3V0Jyk7XHJcbiAgICBzZWxmLnNlbmRTdG9wID0gbnVsbDtcclxuICAgIHNlbGYuc2VuZFNjaGVkdWxlKCk7XHJcbiAgfSwgMjUpO1xyXG59O1xyXG5cclxuQnVmZmVyZWRTZW5kZXIucHJvdG90eXBlLnNlbmRTY2hlZHVsZSA9IGZ1bmN0aW9uKCkge1xyXG4gIGRlYnVnKCdzZW5kU2NoZWR1bGUnLCB0aGlzLnNlbmRCdWZmZXIubGVuZ3RoKTtcclxuICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgaWYgKHRoaXMuc2VuZEJ1ZmZlci5sZW5ndGggPiAwKSB7XHJcbiAgICB2YXIgcGF5bG9hZCA9ICdbJyArIHRoaXMuc2VuZEJ1ZmZlci5qb2luKCcsJykgKyAnXSc7XHJcbiAgICB0aGlzLnNlbmRTdG9wID0gdGhpcy5zZW5kZXIodGhpcy51cmwsIHBheWxvYWQsIGZ1bmN0aW9uKGVycikge1xyXG4gICAgICBzZWxmLnNlbmRTdG9wID0gbnVsbDtcclxuICAgICAgaWYgKGVycikge1xyXG4gICAgICAgIGRlYnVnKCdlcnJvcicsIGVycik7XHJcbiAgICAgICAgc2VsZi5lbWl0KCdjbG9zZScsIGVyci5jb2RlIHx8IDEwMDYsICdTZW5kaW5nIGVycm9yOiAnICsgZXJyKTtcclxuICAgICAgICBzZWxmLmNsb3NlKCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc2VsZi5zZW5kU2NoZWR1bGVXYWl0KCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgdGhpcy5zZW5kQnVmZmVyID0gW107XHJcbiAgfVxyXG59O1xyXG5cclxuQnVmZmVyZWRTZW5kZXIucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24oKSB7XHJcbiAgZGVidWcoJ19jbGVhbnVwJyk7XHJcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcclxufTtcclxuXHJcbkJ1ZmZlcmVkU2VuZGVyLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xyXG4gIGRlYnVnKCdjbG9zZScpO1xyXG4gIHRoaXMuX2NsZWFudXAoKTtcclxuICBpZiAodGhpcy5zZW5kU3RvcCkge1xyXG4gICAgdGhpcy5zZW5kU3RvcCgpO1xyXG4gICAgdGhpcy5zZW5kU3RvcCA9IG51bGw7XHJcbiAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBCdWZmZXJlZFNlbmRlcjtcclxuXHJcbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcclxuXHJcbn0se1wiZGVidWdcIjo1NCxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU2fV0sMjY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4oZnVuY3Rpb24gKGdsb2JhbCl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcclxuICAsIElmcmFtZVRyYW5zcG9ydCA9IHJlcXVpcmUoJy4uL2lmcmFtZScpXHJcbiAgLCBvYmplY3RVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL29iamVjdCcpXHJcbiAgO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih0cmFuc3BvcnQpIHtcclxuXHJcbiAgZnVuY3Rpb24gSWZyYW1lV3JhcFRyYW5zcG9ydCh0cmFuc1VybCwgYmFzZVVybCkge1xyXG4gICAgSWZyYW1lVHJhbnNwb3J0LmNhbGwodGhpcywgdHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUsIHRyYW5zVXJsLCBiYXNlVXJsKTtcclxuICB9XHJcblxyXG4gIGluaGVyaXRzKElmcmFtZVdyYXBUcmFuc3BvcnQsIElmcmFtZVRyYW5zcG9ydCk7XHJcblxyXG4gIElmcmFtZVdyYXBUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKHVybCwgaW5mbykge1xyXG4gICAgaWYgKCFnbG9iYWwuZG9jdW1lbnQpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBpZnJhbWVJbmZvID0gb2JqZWN0VXRpbHMuZXh0ZW5kKHt9LCBpbmZvKTtcclxuICAgIGlmcmFtZUluZm8uc2FtZU9yaWdpbiA9IHRydWU7XHJcbiAgICByZXR1cm4gdHJhbnNwb3J0LmVuYWJsZWQoaWZyYW1lSW5mbykgJiYgSWZyYW1lVHJhbnNwb3J0LmVuYWJsZWQoKTtcclxuICB9O1xyXG5cclxuICBJZnJhbWVXcmFwVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAnaWZyYW1lLScgKyB0cmFuc3BvcnQudHJhbnNwb3J0TmFtZTtcclxuICBJZnJhbWVXcmFwVHJhbnNwb3J0Lm5lZWRCb2R5ID0gdHJ1ZTtcclxuICBJZnJhbWVXcmFwVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSBJZnJhbWVUcmFuc3BvcnQucm91bmRUcmlwcyArIHRyYW5zcG9ydC5yb3VuZFRyaXBzIC0gMTsgLy8gaHRtbCwgamF2YXNjcmlwdCAoMikgKyB0cmFuc3BvcnQgLSBubyBDT1JTICgxKVxyXG5cclxuICBJZnJhbWVXcmFwVHJhbnNwb3J0LmZhY2FkZVRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcclxuXHJcbiAgcmV0dXJuIElmcmFtZVdyYXBUcmFuc3BvcnQ7XHJcbn07XHJcblxyXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcclxuXHJcbn0se1wiLi4vLi4vdXRpbHMvb2JqZWN0XCI6NDksXCIuLi9pZnJhbWVcIjoyMixcImluaGVyaXRzXCI6NTZ9XSwyNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbihmdW5jdGlvbiAocHJvY2Vzcyl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcclxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxyXG4gIDtcclxuXHJcbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XHJcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnBvbGxpbmcnKTtcclxufVxyXG5cclxuZnVuY3Rpb24gUG9sbGluZyhSZWNlaXZlciwgcmVjZWl2ZVVybCwgQWpheE9iamVjdCkge1xyXG4gIGRlYnVnKHJlY2VpdmVVcmwpO1xyXG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xyXG4gIHRoaXMuUmVjZWl2ZXIgPSBSZWNlaXZlcjtcclxuICB0aGlzLnJlY2VpdmVVcmwgPSByZWNlaXZlVXJsO1xyXG4gIHRoaXMuQWpheE9iamVjdCA9IEFqYXhPYmplY3Q7XHJcbiAgdGhpcy5fc2NoZWR1bGVSZWNlaXZlcigpO1xyXG59XHJcblxyXG5pbmhlcml0cyhQb2xsaW5nLCBFdmVudEVtaXR0ZXIpO1xyXG5cclxuUG9sbGluZy5wcm90b3R5cGUuX3NjaGVkdWxlUmVjZWl2ZXIgPSBmdW5jdGlvbigpIHtcclxuICBkZWJ1ZygnX3NjaGVkdWxlUmVjZWl2ZXInKTtcclxuICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgdmFyIHBvbGwgPSB0aGlzLnBvbGwgPSBuZXcgdGhpcy5SZWNlaXZlcih0aGlzLnJlY2VpdmVVcmwsIHRoaXMuQWpheE9iamVjdCk7XHJcblxyXG4gIHBvbGwub24oJ21lc3NhZ2UnLCBmdW5jdGlvbihtc2cpIHtcclxuICAgIGRlYnVnKCdtZXNzYWdlJywgbXNnKTtcclxuICAgIHNlbGYuZW1pdCgnbWVzc2FnZScsIG1zZyk7XHJcbiAgfSk7XHJcblxyXG4gIHBvbGwub25jZSgnY2xvc2UnLCBmdW5jdGlvbihjb2RlLCByZWFzb24pIHtcclxuICAgIGRlYnVnKCdjbG9zZScsIGNvZGUsIHJlYXNvbiwgc2VsZi5wb2xsSXNDbG9zaW5nKTtcclxuICAgIHNlbGYucG9sbCA9IHBvbGwgPSBudWxsO1xyXG5cclxuICAgIGlmICghc2VsZi5wb2xsSXNDbG9zaW5nKSB7XHJcbiAgICAgIGlmIChyZWFzb24gPT09ICduZXR3b3JrJykge1xyXG4gICAgICAgIHNlbGYuX3NjaGVkdWxlUmVjZWl2ZXIoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgY29kZSB8fCAxMDA2LCByZWFzb24pO1xyXG4gICAgICAgIHNlbGYucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9KTtcclxufTtcclxuXHJcblBvbGxpbmcucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKSB7XHJcbiAgZGVidWcoJ2Fib3J0Jyk7XHJcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcclxuICB0aGlzLnBvbGxJc0Nsb3NpbmcgPSB0cnVlO1xyXG4gIGlmICh0aGlzLnBvbGwpIHtcclxuICAgIHRoaXMucG9sbC5hYm9ydCgpO1xyXG4gIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUG9sbGluZztcclxuXHJcbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcclxuXHJcbn0se1wiZGVidWdcIjo1NCxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU2fV0sMjg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXHJcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3VybCcpXHJcbiAgLCBCdWZmZXJlZFNlbmRlciA9IHJlcXVpcmUoJy4vYnVmZmVyZWQtc2VuZGVyJylcclxuICAsIFBvbGxpbmcgPSByZXF1aXJlKCcuL3BvbGxpbmcnKVxyXG4gIDtcclxuXHJcbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XHJcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnNlbmRlci1yZWNlaXZlcicpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBTZW5kZXJSZWNlaXZlcih0cmFuc1VybCwgdXJsU3VmZml4LCBzZW5kZXJGdW5jLCBSZWNlaXZlciwgQWpheE9iamVjdCkge1xyXG4gIHZhciBwb2xsVXJsID0gdXJsVXRpbHMuYWRkUGF0aCh0cmFuc1VybCwgdXJsU3VmZml4KTtcclxuICBkZWJ1Zyhwb2xsVXJsKTtcclxuICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgQnVmZmVyZWRTZW5kZXIuY2FsbCh0aGlzLCB0cmFuc1VybCwgc2VuZGVyRnVuYyk7XHJcblxyXG4gIHRoaXMucG9sbCA9IG5ldyBQb2xsaW5nKFJlY2VpdmVyLCBwb2xsVXJsLCBBamF4T2JqZWN0KTtcclxuICB0aGlzLnBvbGwub24oJ21lc3NhZ2UnLCBmdW5jdGlvbihtc2cpIHtcclxuICAgIGRlYnVnKCdwb2xsIG1lc3NhZ2UnLCBtc2cpO1xyXG4gICAgc2VsZi5lbWl0KCdtZXNzYWdlJywgbXNnKTtcclxuICB9KTtcclxuICB0aGlzLnBvbGwub25jZSgnY2xvc2UnLCBmdW5jdGlvbihjb2RlLCByZWFzb24pIHtcclxuICAgIGRlYnVnKCdwb2xsIGNsb3NlJywgY29kZSwgcmVhc29uKTtcclxuICAgIHNlbGYucG9sbCA9IG51bGw7XHJcbiAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgY29kZSwgcmVhc29uKTtcclxuICAgIHNlbGYuY2xvc2UoKTtcclxuICB9KTtcclxufVxyXG5cclxuaW5oZXJpdHMoU2VuZGVyUmVjZWl2ZXIsIEJ1ZmZlcmVkU2VuZGVyKTtcclxuXHJcblNlbmRlclJlY2VpdmVyLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xyXG4gIEJ1ZmZlcmVkU2VuZGVyLnByb3RvdHlwZS5jbG9zZS5jYWxsKHRoaXMpO1xyXG4gIGRlYnVnKCdjbG9zZScpO1xyXG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XHJcbiAgaWYgKHRoaXMucG9sbCkge1xyXG4gICAgdGhpcy5wb2xsLmFib3J0KCk7XHJcbiAgICB0aGlzLnBvbGwgPSBudWxsO1xyXG4gIH1cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2VuZGVyUmVjZWl2ZXI7XHJcblxyXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXHJcblxyXG59LHtcIi4uLy4uL3V0aWxzL3VybFwiOjUyLFwiLi9idWZmZXJlZC1zZW5kZXJcIjoyNSxcIi4vcG9sbGluZ1wiOjI3LFwiZGVidWdcIjo1NCxcImluaGVyaXRzXCI6NTZ9XSwyOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbihmdW5jdGlvbiAocHJvY2Vzcyl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcclxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxyXG4gICwgRXZlbnRTb3VyY2VEcml2ZXIgPSByZXF1aXJlKCdldmVudHNvdXJjZScpXHJcbiAgO1xyXG5cclxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcclxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6cmVjZWl2ZXI6ZXZlbnRzb3VyY2UnKTtcclxufVxyXG5cclxuZnVuY3Rpb24gRXZlbnRTb3VyY2VSZWNlaXZlcih1cmwpIHtcclxuICBkZWJ1Zyh1cmwpO1xyXG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xyXG5cclxuICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgdmFyIGVzID0gdGhpcy5lcyA9IG5ldyBFdmVudFNvdXJjZURyaXZlcih1cmwpO1xyXG4gIGVzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcclxuICAgIGRlYnVnKCdtZXNzYWdlJywgZS5kYXRhKTtcclxuICAgIHNlbGYuZW1pdCgnbWVzc2FnZScsIGRlY29kZVVSSShlLmRhdGEpKTtcclxuICB9O1xyXG4gIGVzLm9uZXJyb3IgPSBmdW5jdGlvbihlKSB7XHJcbiAgICBkZWJ1ZygnZXJyb3InLCBlcy5yZWFkeVN0YXRlLCBlKTtcclxuICAgIC8vIEVTIG9uIHJlY29ubmVjdGlvbiBoYXMgcmVhZHlTdGF0ZSA9IDAgb3IgMS5cclxuICAgIC8vIG9uIG5ldHdvcmsgZXJyb3IgaXQncyBDTE9TRUQgPSAyXHJcbiAgICB2YXIgcmVhc29uID0gKGVzLnJlYWR5U3RhdGUgIT09IDIgPyAnbmV0d29yaycgOiAncGVybWFuZW50Jyk7XHJcbiAgICBzZWxmLl9jbGVhbnVwKCk7XHJcbiAgICBzZWxmLl9jbG9zZShyZWFzb24pO1xyXG4gIH07XHJcbn1cclxuXHJcbmluaGVyaXRzKEV2ZW50U291cmNlUmVjZWl2ZXIsIEV2ZW50RW1pdHRlcik7XHJcblxyXG5FdmVudFNvdXJjZVJlY2VpdmVyLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCkge1xyXG4gIGRlYnVnKCdhYm9ydCcpO1xyXG4gIHRoaXMuX2NsZWFudXAoKTtcclxuICB0aGlzLl9jbG9zZSgndXNlcicpO1xyXG59O1xyXG5cclxuRXZlbnRTb3VyY2VSZWNlaXZlci5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbigpIHtcclxuICBkZWJ1ZygnY2xlYW51cCcpO1xyXG4gIHZhciBlcyA9IHRoaXMuZXM7XHJcbiAgaWYgKGVzKSB7XHJcbiAgICBlcy5vbm1lc3NhZ2UgPSBlcy5vbmVycm9yID0gbnVsbDtcclxuICAgIGVzLmNsb3NlKCk7XHJcbiAgICB0aGlzLmVzID0gbnVsbDtcclxuICB9XHJcbn07XHJcblxyXG5FdmVudFNvdXJjZVJlY2VpdmVyLnByb3RvdHlwZS5fY2xvc2UgPSBmdW5jdGlvbihyZWFzb24pIHtcclxuICBkZWJ1ZygnY2xvc2UnLCByZWFzb24pO1xyXG4gIHZhciBzZWxmID0gdGhpcztcclxuICAvLyBTYWZhcmkgYW5kIGNocm9tZSA8IDE1IGNyYXNoIGlmIHdlIGNsb3NlIHdpbmRvdyBiZWZvcmVcclxuICAvLyB3YWl0aW5nIGZvciBFUyBjbGVhbnVwLiBTZWU6XHJcbiAgLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTg5MTU1XHJcbiAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgIHNlbGYuZW1pdCgnY2xvc2UnLCBudWxsLCByZWFzb24pO1xyXG4gICAgc2VsZi5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcclxuICB9LCAyMDApO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFNvdXJjZVJlY2VpdmVyO1xyXG5cclxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxyXG5cclxufSx7XCJkZWJ1Z1wiOjU0LFwiZXZlbnRzXCI6MyxcImV2ZW50c291cmNlXCI6MTgsXCJpbmhlcml0c1wiOjU2fV0sMzA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxyXG4gICwgaWZyYW1lVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy9pZnJhbWUnKVxyXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy91cmwnKVxyXG4gICwgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXHJcbiAgLCByYW5kb20gPSByZXF1aXJlKCcuLi8uLi91dGlscy9yYW5kb20nKVxyXG4gIDtcclxuXHJcbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XHJcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnJlY2VpdmVyOmh0bWxmaWxlJyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIEh0bWxmaWxlUmVjZWl2ZXIodXJsKSB7XHJcbiAgZGVidWcodXJsKTtcclxuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcclxuICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgaWZyYW1lVXRpbHMucG9sbHV0ZUdsb2JhbE5hbWVzcGFjZSgpO1xyXG5cclxuICB0aGlzLmlkID0gJ2EnICsgcmFuZG9tLnN0cmluZyg2KTtcclxuICB1cmwgPSB1cmxVdGlscy5hZGRRdWVyeSh1cmwsICdjPScgKyBkZWNvZGVVUklDb21wb25lbnQoaWZyYW1lVXRpbHMuV1ByZWZpeCArICcuJyArIHRoaXMuaWQpKTtcclxuXHJcbiAgZGVidWcoJ3VzaW5nIGh0bWxmaWxlJywgSHRtbGZpbGVSZWNlaXZlci5odG1sZmlsZUVuYWJsZWQpO1xyXG4gIHZhciBjb25zdHJ1Y3RGdW5jID0gSHRtbGZpbGVSZWNlaXZlci5odG1sZmlsZUVuYWJsZWQgP1xyXG4gICAgICBpZnJhbWVVdGlscy5jcmVhdGVIdG1sZmlsZSA6IGlmcmFtZVV0aWxzLmNyZWF0ZUlmcmFtZTtcclxuXHJcbiAgZ2xvYmFsW2lmcmFtZVV0aWxzLldQcmVmaXhdW3RoaXMuaWRdID0ge1xyXG4gICAgc3RhcnQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICBkZWJ1Zygnc3RhcnQnKTtcclxuICAgICAgc2VsZi5pZnJhbWVPYmoubG9hZGVkKCk7XHJcbiAgICB9XHJcbiAgLCBtZXNzYWdlOiBmdW5jdGlvbihkYXRhKSB7XHJcbiAgICAgIGRlYnVnKCdtZXNzYWdlJywgZGF0YSk7XHJcbiAgICAgIHNlbGYuZW1pdCgnbWVzc2FnZScsIGRhdGEpO1xyXG4gICAgfVxyXG4gICwgc3RvcDogZnVuY3Rpb24oKSB7XHJcbiAgICAgIGRlYnVnKCdzdG9wJyk7XHJcbiAgICAgIHNlbGYuX2NsZWFudXAoKTtcclxuICAgICAgc2VsZi5fY2xvc2UoJ25ldHdvcmsnKTtcclxuICAgIH1cclxuICB9O1xyXG4gIHRoaXMuaWZyYW1lT2JqID0gY29uc3RydWN0RnVuYyh1cmwsIGZ1bmN0aW9uKCkge1xyXG4gICAgZGVidWcoJ2NhbGxiYWNrJyk7XHJcbiAgICBzZWxmLl9jbGVhbnVwKCk7XHJcbiAgICBzZWxmLl9jbG9zZSgncGVybWFuZW50Jyk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbmluaGVyaXRzKEh0bWxmaWxlUmVjZWl2ZXIsIEV2ZW50RW1pdHRlcik7XHJcblxyXG5IdG1sZmlsZVJlY2VpdmVyLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCkge1xyXG4gIGRlYnVnKCdhYm9ydCcpO1xyXG4gIHRoaXMuX2NsZWFudXAoKTtcclxuICB0aGlzLl9jbG9zZSgndXNlcicpO1xyXG59O1xyXG5cclxuSHRtbGZpbGVSZWNlaXZlci5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbigpIHtcclxuICBkZWJ1ZygnX2NsZWFudXAnKTtcclxuICBpZiAodGhpcy5pZnJhbWVPYmopIHtcclxuICAgIHRoaXMuaWZyYW1lT2JqLmNsZWFudXAoKTtcclxuICAgIHRoaXMuaWZyYW1lT2JqID0gbnVsbDtcclxuICB9XHJcbiAgZGVsZXRlIGdsb2JhbFtpZnJhbWVVdGlscy5XUHJlZml4XVt0aGlzLmlkXTtcclxufTtcclxuXHJcbkh0bWxmaWxlUmVjZWl2ZXIucHJvdG90eXBlLl9jbG9zZSA9IGZ1bmN0aW9uKHJlYXNvbikge1xyXG4gIGRlYnVnKCdfY2xvc2UnLCByZWFzb24pO1xyXG4gIHRoaXMuZW1pdCgnY2xvc2UnLCBudWxsLCByZWFzb24pO1xyXG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XHJcbn07XHJcblxyXG5IdG1sZmlsZVJlY2VpdmVyLmh0bWxmaWxlRW5hYmxlZCA9IGZhbHNlO1xyXG5cclxuLy8gb2JmdXNjYXRlIHRvIGF2b2lkIGZpcmV3YWxsc1xyXG52YXIgYXhvID0gWydBY3RpdmUnXS5jb25jYXQoJ09iamVjdCcpLmpvaW4oJ1gnKTtcclxuaWYgKGF4byBpbiBnbG9iYWwpIHtcclxuICB0cnkge1xyXG4gICAgSHRtbGZpbGVSZWNlaXZlci5odG1sZmlsZUVuYWJsZWQgPSAhIW5ldyBnbG9iYWxbYXhvXSgnaHRtbGZpbGUnKTtcclxuICB9IGNhdGNoICh4KSB7XHJcbiAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XHJcbiAgfVxyXG59XHJcblxyXG5IdG1sZmlsZVJlY2VpdmVyLmVuYWJsZWQgPSBIdG1sZmlsZVJlY2VpdmVyLmh0bWxmaWxlRW5hYmxlZCB8fCBpZnJhbWVVdGlscy5pZnJhbWVFbmFibGVkO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBIdG1sZmlsZVJlY2VpdmVyO1xyXG5cclxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9LHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXHJcblxyXG59LHtcIi4uLy4uL3V0aWxzL2lmcmFtZVwiOjQ3LFwiLi4vLi4vdXRpbHMvcmFuZG9tXCI6NTAsXCIuLi8uLi91dGlscy91cmxcIjo1MixcImRlYnVnXCI6NTQsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1Nn1dLDMxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2lmcmFtZScpXHJcbiAgLCByYW5kb20gPSByZXF1aXJlKCcuLi8uLi91dGlscy9yYW5kb20nKVxyXG4gICwgYnJvd3NlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2Jyb3dzZXInKVxyXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy91cmwnKVxyXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXHJcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcclxuICA7XHJcblxyXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xyXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpyZWNlaXZlcjpqc29ucCcpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBKc29ucFJlY2VpdmVyKHVybCkge1xyXG4gIGRlYnVnKHVybCk7XHJcbiAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xyXG5cclxuICB1dGlscy5wb2xsdXRlR2xvYmFsTmFtZXNwYWNlKCk7XHJcblxyXG4gIHRoaXMuaWQgPSAnYScgKyByYW5kb20uc3RyaW5nKDYpO1xyXG4gIHZhciB1cmxXaXRoSWQgPSB1cmxVdGlscy5hZGRRdWVyeSh1cmwsICdjPScgKyBlbmNvZGVVUklDb21wb25lbnQodXRpbHMuV1ByZWZpeCArICcuJyArIHRoaXMuaWQpKTtcclxuXHJcbiAgZ2xvYmFsW3V0aWxzLldQcmVmaXhdW3RoaXMuaWRdID0gdGhpcy5fY2FsbGJhY2suYmluZCh0aGlzKTtcclxuICB0aGlzLl9jcmVhdGVTY3JpcHQodXJsV2l0aElkKTtcclxuXHJcbiAgLy8gRmFsbGJhY2sgbW9zdGx5IGZvciBLb25xdWVyb3IgLSBzdHVwaWQgdGltZXIsIDM1IHNlY29uZHMgc2hhbGwgYmUgcGxlbnR5LlxyXG4gIHRoaXMudGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgIGRlYnVnKCd0aW1lb3V0Jyk7XHJcbiAgICBzZWxmLl9hYm9ydChuZXcgRXJyb3IoJ0pTT05QIHNjcmlwdCBsb2FkZWQgYWJub3JtYWxseSAodGltZW91dCknKSk7XHJcbiAgfSwgSnNvbnBSZWNlaXZlci50aW1lb3V0KTtcclxufVxyXG5cclxuaW5oZXJpdHMoSnNvbnBSZWNlaXZlciwgRXZlbnRFbWl0dGVyKTtcclxuXHJcbkpzb25wUmVjZWl2ZXIucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKSB7XHJcbiAgZGVidWcoJ2Fib3J0Jyk7XHJcbiAgaWYgKGdsb2JhbFt1dGlscy5XUHJlZml4XVt0aGlzLmlkXSkge1xyXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcignSlNPTlAgdXNlciBhYm9ydGVkIHJlYWQnKTtcclxuICAgIGVyci5jb2RlID0gMTAwMDtcclxuICAgIHRoaXMuX2Fib3J0KGVycik7XHJcbiAgfVxyXG59O1xyXG5cclxuSnNvbnBSZWNlaXZlci50aW1lb3V0ID0gMzUwMDA7XHJcbkpzb25wUmVjZWl2ZXIuc2NyaXB0RXJyb3JUaW1lb3V0ID0gMTAwMDtcclxuXHJcbkpzb25wUmVjZWl2ZXIucHJvdG90eXBlLl9jYWxsYmFjayA9IGZ1bmN0aW9uKGRhdGEpIHtcclxuICBkZWJ1ZygnX2NhbGxiYWNrJywgZGF0YSk7XHJcbiAgdGhpcy5fY2xlYW51cCgpO1xyXG5cclxuICBpZiAodGhpcy5hYm9ydGluZykge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgaWYgKGRhdGEpIHtcclxuICAgIGRlYnVnKCdtZXNzYWdlJywgZGF0YSk7XHJcbiAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBkYXRhKTtcclxuICB9XHJcbiAgdGhpcy5lbWl0KCdjbG9zZScsIG51bGwsICduZXR3b3JrJyk7XHJcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcclxufTtcclxuXHJcbkpzb25wUmVjZWl2ZXIucHJvdG90eXBlLl9hYm9ydCA9IGZ1bmN0aW9uKGVycikge1xyXG4gIGRlYnVnKCdfYWJvcnQnLCBlcnIpO1xyXG4gIHRoaXMuX2NsZWFudXAoKTtcclxuICB0aGlzLmFib3J0aW5nID0gdHJ1ZTtcclxuICB0aGlzLmVtaXQoJ2Nsb3NlJywgZXJyLmNvZGUsIGVyci5tZXNzYWdlKTtcclxuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xyXG59O1xyXG5cclxuSnNvbnBSZWNlaXZlci5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbigpIHtcclxuICBkZWJ1ZygnX2NsZWFudXAnKTtcclxuICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0SWQpO1xyXG4gIGlmICh0aGlzLnNjcmlwdDIpIHtcclxuICAgIHRoaXMuc2NyaXB0Mi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuc2NyaXB0Mik7XHJcbiAgICB0aGlzLnNjcmlwdDIgPSBudWxsO1xyXG4gIH1cclxuICBpZiAodGhpcy5zY3JpcHQpIHtcclxuICAgIHZhciBzY3JpcHQgPSB0aGlzLnNjcmlwdDtcclxuICAgIC8vIFVuZm9ydHVuYXRlbHksIHlvdSBjYW4ndCByZWFsbHkgYWJvcnQgc2NyaXB0IGxvYWRpbmcgb2ZcclxuICAgIC8vIHRoZSBzY3JpcHQuXHJcbiAgICBzY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHQpO1xyXG4gICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IHNjcmlwdC5vbmVycm9yID1cclxuICAgICAgICBzY3JpcHQub25sb2FkID0gc2NyaXB0Lm9uY2xpY2sgPSBudWxsO1xyXG4gICAgdGhpcy5zY3JpcHQgPSBudWxsO1xyXG4gIH1cclxuICBkZWxldGUgZ2xvYmFsW3V0aWxzLldQcmVmaXhdW3RoaXMuaWRdO1xyXG59O1xyXG5cclxuSnNvbnBSZWNlaXZlci5wcm90b3R5cGUuX3NjcmlwdEVycm9yID0gZnVuY3Rpb24oKSB7XHJcbiAgZGVidWcoJ19zY3JpcHRFcnJvcicpO1xyXG4gIHZhciBzZWxmID0gdGhpcztcclxuICBpZiAodGhpcy5lcnJvclRpbWVyKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICB0aGlzLmVycm9yVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgaWYgKCFzZWxmLmxvYWRlZE9rYXkpIHtcclxuICAgICAgc2VsZi5fYWJvcnQobmV3IEVycm9yKCdKU09OUCBzY3JpcHQgbG9hZGVkIGFibm9ybWFsbHkgKG9uZXJyb3IpJykpO1xyXG4gICAgfVxyXG4gIH0sIEpzb25wUmVjZWl2ZXIuc2NyaXB0RXJyb3JUaW1lb3V0KTtcclxufTtcclxuXHJcbkpzb25wUmVjZWl2ZXIucHJvdG90eXBlLl9jcmVhdGVTY3JpcHQgPSBmdW5jdGlvbih1cmwpIHtcclxuICBkZWJ1ZygnX2NyZWF0ZVNjcmlwdCcsIHVybCk7XHJcbiAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gIHZhciBzY3JpcHQgPSB0aGlzLnNjcmlwdCA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcclxuICB2YXIgc2NyaXB0MjsgIC8vIE9wZXJhIHN5bmNocm9ub3VzIGxvYWQgdHJpY2suXHJcblxyXG4gIHNjcmlwdC5pZCA9ICdhJyArIHJhbmRvbS5zdHJpbmcoOCk7XHJcbiAgc2NyaXB0LnNyYyA9IHVybDtcclxuICBzY3JpcHQudHlwZSA9ICd0ZXh0L2phdmFzY3JpcHQnO1xyXG4gIHNjcmlwdC5jaGFyc2V0ID0gJ1VURi04JztcclxuICBzY3JpcHQub25lcnJvciA9IHRoaXMuX3NjcmlwdEVycm9yLmJpbmQodGhpcyk7XHJcbiAgc2NyaXB0Lm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgZGVidWcoJ29ubG9hZCcpO1xyXG4gICAgc2VsZi5fYWJvcnQobmV3IEVycm9yKCdKU09OUCBzY3JpcHQgbG9hZGVkIGFibm9ybWFsbHkgKG9ubG9hZCknKSk7XHJcbiAgfTtcclxuXHJcbiAgLy8gSUU5IGZpcmVzICdlcnJvcicgZXZlbnQgYWZ0ZXIgb25yZWFkeXN0YXRlY2hhbmdlIG9yIGJlZm9yZSwgaW4gcmFuZG9tIG9yZGVyLlxyXG4gIC8vIFVzZSBsb2FkZWRPa2F5IHRvIGRldGVybWluZSBpZiBhY3R1YWxseSBlcnJvcmVkXHJcbiAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgZGVidWcoJ29ucmVhZHlzdGF0ZWNoYW5nZScsIHNjcmlwdC5yZWFkeVN0YXRlKTtcclxuICAgIGlmICgvbG9hZGVkfGNsb3NlZC8udGVzdChzY3JpcHQucmVhZHlTdGF0ZSkpIHtcclxuICAgICAgaWYgKHNjcmlwdCAmJiBzY3JpcHQuaHRtbEZvciAmJiBzY3JpcHQub25jbGljaykge1xyXG4gICAgICAgIHNlbGYubG9hZGVkT2theSA9IHRydWU7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIC8vIEluIElFLCBhY3R1YWxseSBleGVjdXRlIHRoZSBzY3JpcHQuXHJcbiAgICAgICAgICBzY3JpcHQub25jbGljaygpO1xyXG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcclxuICAgICAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHNjcmlwdCkge1xyXG4gICAgICAgIHNlbGYuX2Fib3J0KG5ldyBFcnJvcignSlNPTlAgc2NyaXB0IGxvYWRlZCBhYm5vcm1hbGx5IChvbnJlYWR5c3RhdGVjaGFuZ2UpJykpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxuICAvLyBJRTogZXZlbnQvaHRtbEZvci9vbmNsaWNrIHRyaWNrLlxyXG4gIC8vIE9uZSBjYW4ndCByZWx5IG9uIHByb3BlciBvcmRlciBmb3Igb25yZWFkeXN0YXRlY2hhbmdlLiBJbiBvcmRlciB0b1xyXG4gIC8vIG1ha2Ugc3VyZSwgc2V0IGEgJ2h0bWxGb3InIGFuZCAnZXZlbnQnIHByb3BlcnRpZXMsIHNvIHRoYXRcclxuICAvLyBzY3JpcHQgY29kZSB3aWxsIGJlIGluc3RhbGxlZCBhcyAnb25jbGljaycgaGFuZGxlciBmb3IgdGhlXHJcbiAgLy8gc2NyaXB0IG9iamVjdC4gTGF0ZXIsIG9ucmVhZHlzdGF0ZWNoYW5nZSwgbWFudWFsbHkgZXhlY3V0ZSB0aGlzXHJcbiAgLy8gY29kZS4gRkYgYW5kIENocm9tZSBkb2Vzbid0IHdvcmsgd2l0aCAnZXZlbnQnIGFuZCAnaHRtbEZvcidcclxuICAvLyBzZXQuIEZvciByZWZlcmVuY2Ugc2VlOlxyXG4gIC8vICAgaHR0cDovL2phdWJvdXJnLm5ldC8yMDEwLzA3L2xvYWRpbmctc2NyaXB0LWFzLW9uY2xpY2staGFuZGxlci1vZi5odG1sXHJcbiAgLy8gQWxzbywgcmVhZCBvbiB0aGF0IGFib3V0IHNjcmlwdCBvcmRlcmluZzpcclxuICAvLyAgIGh0dHA6Ly93aWtpLndoYXR3Zy5vcmcvd2lraS9EeW5hbWljX1NjcmlwdF9FeGVjdXRpb25fT3JkZXJcclxuICBpZiAodHlwZW9mIHNjcmlwdC5hc3luYyA9PT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsLmRvY3VtZW50LmF0dGFjaEV2ZW50KSB7XHJcbiAgICAvLyBBY2NvcmRpbmcgdG8gbW96aWxsYSBkb2NzLCBpbiByZWNlbnQgYnJvd3NlcnMgc2NyaXB0LmFzeW5jIGRlZmF1bHRzXHJcbiAgICAvLyB0byAndHJ1ZScsIHNvIHdlIG1heSB1c2UgaXQgdG8gZGV0ZWN0IGEgZ29vZCBicm93c2VyOlxyXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSFRNTC9FbGVtZW50L3NjcmlwdFxyXG4gICAgaWYgKCFicm93c2VyLmlzT3BlcmEoKSkge1xyXG4gICAgICAvLyBOYWl2ZWx5IGFzc3VtZSB3ZSdyZSBpbiBJRVxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHNjcmlwdC5odG1sRm9yID0gc2NyaXB0LmlkO1xyXG4gICAgICAgIHNjcmlwdC5ldmVudCA9ICdvbmNsaWNrJztcclxuICAgICAgfSBjYXRjaCAoeCkge1xyXG4gICAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcclxuICAgICAgfVxyXG4gICAgICBzY3JpcHQuYXN5bmMgPSB0cnVlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gT3BlcmEsIHNlY29uZCBzeW5jIHNjcmlwdCBoYWNrXHJcbiAgICAgIHNjcmlwdDIgPSB0aGlzLnNjcmlwdDIgPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XHJcbiAgICAgIHNjcmlwdDIudGV4dCA9IFwidHJ5e3ZhciBhID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ1wiICsgc2NyaXB0LmlkICsgXCInKTsgaWYoYSlhLm9uZXJyb3IoKTt9Y2F0Y2goeCl7fTtcIjtcclxuICAgICAgc2NyaXB0LmFzeW5jID0gc2NyaXB0Mi5hc3luYyA9IGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuICBpZiAodHlwZW9mIHNjcmlwdC5hc3luYyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIHNjcmlwdC5hc3luYyA9IHRydWU7XHJcbiAgfVxyXG5cclxuICB2YXIgaGVhZCA9IGdsb2JhbC5kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xyXG4gIGhlYWQuaW5zZXJ0QmVmb3JlKHNjcmlwdCwgaGVhZC5maXJzdENoaWxkKTtcclxuICBpZiAoc2NyaXB0Mikge1xyXG4gICAgaGVhZC5pbnNlcnRCZWZvcmUoc2NyaXB0MiwgaGVhZC5maXJzdENoaWxkKTtcclxuICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEpzb25wUmVjZWl2ZXI7XHJcblxyXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0sdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcclxuXHJcbn0se1wiLi4vLi4vdXRpbHMvYnJvd3NlclwiOjQ0LFwiLi4vLi4vdXRpbHMvaWZyYW1lXCI6NDcsXCIuLi8uLi91dGlscy9yYW5kb21cIjo1MCxcIi4uLy4uL3V0aWxzL3VybFwiOjUyLFwiZGVidWdcIjo1NCxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU2fV0sMzI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXHJcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcclxuICA7XHJcblxyXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xyXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpyZWNlaXZlcjp4aHInKTtcclxufVxyXG5cclxuZnVuY3Rpb24gWGhyUmVjZWl2ZXIodXJsLCBBamF4T2JqZWN0KSB7XHJcbiAgZGVidWcodXJsKTtcclxuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcclxuICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gIHRoaXMuYnVmZmVyUG9zaXRpb24gPSAwO1xyXG5cclxuICB0aGlzLnhvID0gbmV3IEFqYXhPYmplY3QoJ1BPU1QnLCB1cmwsIG51bGwpO1xyXG4gIHRoaXMueG8ub24oJ2NodW5rJywgdGhpcy5fY2h1bmtIYW5kbGVyLmJpbmQodGhpcykpO1xyXG4gIHRoaXMueG8ub25jZSgnZmluaXNoJywgZnVuY3Rpb24oc3RhdHVzLCB0ZXh0KSB7XHJcbiAgICBkZWJ1ZygnZmluaXNoJywgc3RhdHVzLCB0ZXh0KTtcclxuICAgIHNlbGYuX2NodW5rSGFuZGxlcihzdGF0dXMsIHRleHQpO1xyXG4gICAgc2VsZi54byA9IG51bGw7XHJcbiAgICB2YXIgcmVhc29uID0gc3RhdHVzID09PSAyMDAgPyAnbmV0d29yaycgOiAncGVybWFuZW50JztcclxuICAgIGRlYnVnKCdjbG9zZScsIHJlYXNvbik7XHJcbiAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgbnVsbCwgcmVhc29uKTtcclxuICAgIHNlbGYuX2NsZWFudXAoKTtcclxuICB9KTtcclxufVxyXG5cclxuaW5oZXJpdHMoWGhyUmVjZWl2ZXIsIEV2ZW50RW1pdHRlcik7XHJcblxyXG5YaHJSZWNlaXZlci5wcm90b3R5cGUuX2NodW5rSGFuZGxlciA9IGZ1bmN0aW9uKHN0YXR1cywgdGV4dCkge1xyXG4gIGRlYnVnKCdfY2h1bmtIYW5kbGVyJywgc3RhdHVzKTtcclxuICBpZiAoc3RhdHVzICE9PSAyMDAgfHwgIXRleHQpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIGZvciAodmFyIGlkeCA9IC0xOyA7IHRoaXMuYnVmZmVyUG9zaXRpb24gKz0gaWR4ICsgMSkge1xyXG4gICAgdmFyIGJ1ZiA9IHRleHQuc2xpY2UodGhpcy5idWZmZXJQb3NpdGlvbik7XHJcbiAgICBpZHggPSBidWYuaW5kZXhPZignXFxuJyk7XHJcbiAgICBpZiAoaWR4ID09PSAtMSkge1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICAgIHZhciBtc2cgPSBidWYuc2xpY2UoMCwgaWR4KTtcclxuICAgIGlmIChtc2cpIHtcclxuICAgICAgZGVidWcoJ21lc3NhZ2UnLCBtc2cpO1xyXG4gICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBtc2cpO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcblhoclJlY2VpdmVyLnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xyXG4gIGRlYnVnKCdfY2xlYW51cCcpO1xyXG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XHJcbn07XHJcblxyXG5YaHJSZWNlaXZlci5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpIHtcclxuICBkZWJ1ZygnYWJvcnQnKTtcclxuICBpZiAodGhpcy54bykge1xyXG4gICAgdGhpcy54by5jbG9zZSgpO1xyXG4gICAgZGVidWcoJ2Nsb3NlJyk7XHJcbiAgICB0aGlzLmVtaXQoJ2Nsb3NlJywgbnVsbCwgJ3VzZXInKTtcclxuICAgIHRoaXMueG8gPSBudWxsO1xyXG4gIH1cclxuICB0aGlzLl9jbGVhbnVwKCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFhoclJlY2VpdmVyO1xyXG5cclxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxyXG5cclxufSx7XCJkZWJ1Z1wiOjU0LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTZ9XSwzMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgcmFuZG9tID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvcmFuZG9tJylcclxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXJsJylcclxuICA7XHJcblxyXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xyXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpzZW5kZXI6anNvbnAnKTtcclxufVxyXG5cclxudmFyIGZvcm0sIGFyZWE7XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVJZnJhbWUoaWQpIHtcclxuICBkZWJ1ZygnY3JlYXRlSWZyYW1lJywgaWQpO1xyXG4gIHRyeSB7XHJcbiAgICAvLyBpZTYgZHluYW1pYyBpZnJhbWVzIHdpdGggdGFyZ2V0PVwiXCIgc3VwcG9ydCAodGhhbmtzIENocmlzIExhbWJhY2hlcilcclxuICAgIHJldHVybiBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnPGlmcmFtZSBuYW1lPVwiJyArIGlkICsgJ1wiPicpO1xyXG4gIH0gY2F0Y2ggKHgpIHtcclxuICAgIHZhciBpZnJhbWUgPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XHJcbiAgICBpZnJhbWUubmFtZSA9IGlkO1xyXG4gICAgcmV0dXJuIGlmcmFtZTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUZvcm0oKSB7XHJcbiAgZGVidWcoJ2NyZWF0ZUZvcm0nKTtcclxuICBmb3JtID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Zvcm0nKTtcclxuICBmb3JtLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgZm9ybS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XHJcbiAgZm9ybS5tZXRob2QgPSAnUE9TVCc7XHJcbiAgZm9ybS5lbmN0eXBlID0gJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCc7XHJcbiAgZm9ybS5hY2NlcHRDaGFyc2V0ID0gJ1VURi04JztcclxuXHJcbiAgYXJlYSA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpO1xyXG4gIGFyZWEubmFtZSA9ICdkJztcclxuICBmb3JtLmFwcGVuZENoaWxkKGFyZWEpO1xyXG5cclxuICBnbG9iYWwuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmb3JtKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih1cmwsIHBheWxvYWQsIGNhbGxiYWNrKSB7XHJcbiAgZGVidWcodXJsLCBwYXlsb2FkKTtcclxuICBpZiAoIWZvcm0pIHtcclxuICAgIGNyZWF0ZUZvcm0oKTtcclxuICB9XHJcbiAgdmFyIGlkID0gJ2EnICsgcmFuZG9tLnN0cmluZyg4KTtcclxuICBmb3JtLnRhcmdldCA9IGlkO1xyXG4gIGZvcm0uYWN0aW9uID0gdXJsVXRpbHMuYWRkUXVlcnkodXJsVXRpbHMuYWRkUGF0aCh1cmwsICcvanNvbnBfc2VuZCcpLCAnaT0nICsgaWQpO1xyXG5cclxuICB2YXIgaWZyYW1lID0gY3JlYXRlSWZyYW1lKGlkKTtcclxuICBpZnJhbWUuaWQgPSBpZDtcclxuICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICBmb3JtLmFwcGVuZENoaWxkKGlmcmFtZSk7XHJcblxyXG4gIHRyeSB7XHJcbiAgICBhcmVhLnZhbHVlID0gcGF5bG9hZDtcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICAvLyBzZXJpb3VzbHkgYnJva2VuIGJyb3dzZXJzIGdldCBoZXJlXHJcbiAgfVxyXG4gIGZvcm0uc3VibWl0KCk7XHJcblxyXG4gIHZhciBjb21wbGV0ZWQgPSBmdW5jdGlvbihlcnIpIHtcclxuICAgIGRlYnVnKCdjb21wbGV0ZWQnLCBpZCwgZXJyKTtcclxuICAgIGlmICghaWZyYW1lLm9uZXJyb3IpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWZyYW1lLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGlmcmFtZS5vbmVycm9yID0gaWZyYW1lLm9ubG9hZCA9IG51bGw7XHJcbiAgICAvLyBPcGVyYSBtaW5pIGRvZXNuJ3QgbGlrZSBpZiB3ZSBHQyBpZnJhbWVcclxuICAgIC8vIGltbWVkaWF0ZWx5LCB0aHVzIHRoaXMgdGltZW91dC5cclxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgIGRlYnVnKCdjbGVhbmluZyB1cCcsIGlkKTtcclxuICAgICAgaWZyYW1lLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcclxuICAgICAgaWZyYW1lID0gbnVsbDtcclxuICAgIH0sIDUwMCk7XHJcbiAgICBhcmVhLnZhbHVlID0gJyc7XHJcbiAgICAvLyBJdCBpcyBub3QgcG9zc2libGUgdG8gZGV0ZWN0IGlmIHRoZSBpZnJhbWUgc3VjY2VlZGVkIG9yXHJcbiAgICAvLyBmYWlsZWQgdG8gc3VibWl0IG91ciBmb3JtLlxyXG4gICAgY2FsbGJhY2soZXJyKTtcclxuICB9O1xyXG4gIGlmcmFtZS5vbmVycm9yID0gZnVuY3Rpb24oKSB7XHJcbiAgICBkZWJ1Zygnb25lcnJvcicsIGlkKTtcclxuICAgIGNvbXBsZXRlZCgpO1xyXG4gIH07XHJcbiAgaWZyYW1lLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgZGVidWcoJ29ubG9hZCcsIGlkKTtcclxuICAgIGNvbXBsZXRlZCgpO1xyXG4gIH07XHJcbiAgaWZyYW1lLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKGUpIHtcclxuICAgIGRlYnVnKCdvbnJlYWR5c3RhdGVjaGFuZ2UnLCBpZCwgaWZyYW1lLnJlYWR5U3RhdGUsIGUpO1xyXG4gICAgaWYgKGlmcmFtZS5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XHJcbiAgICAgIGNvbXBsZXRlZCgpO1xyXG4gICAgfVxyXG4gIH07XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgZGVidWcoJ2Fib3J0ZWQnLCBpZCk7XHJcbiAgICBjb21wbGV0ZWQobmV3IEVycm9yKCdBYm9ydGVkJykpO1xyXG4gIH07XHJcbn07XHJcblxyXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0sdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcclxuXHJcbn0se1wiLi4vLi4vdXRpbHMvcmFuZG9tXCI6NTAsXCIuLi8uLi91dGlscy91cmxcIjo1MixcImRlYnVnXCI6NTR9XSwzNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXHJcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcclxuICAsIGV2ZW50VXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy9ldmVudCcpXHJcbiAgLCBicm93c2VyID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvYnJvd3NlcicpXHJcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3VybCcpXHJcbiAgO1xyXG5cclxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcclxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6c2VuZGVyOnhkcicpO1xyXG59XHJcblxyXG4vLyBSZWZlcmVuY2VzOlxyXG4vLyAgIGh0dHA6Ly9hamF4aWFuLmNvbS9hcmNoaXZlcy8xMDAtbGluZS1hamF4LXdyYXBwZXJcclxuLy8gICBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvY2MyODgwNjAodj1WUy44NSkuYXNweFxyXG5cclxuZnVuY3Rpb24gWERST2JqZWN0KG1ldGhvZCwgdXJsLCBwYXlsb2FkKSB7XHJcbiAgZGVidWcobWV0aG9kLCB1cmwpO1xyXG4gIHZhciBzZWxmID0gdGhpcztcclxuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcclxuXHJcbiAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgIHNlbGYuX3N0YXJ0KG1ldGhvZCwgdXJsLCBwYXlsb2FkKTtcclxuICB9LCAwKTtcclxufVxyXG5cclxuaW5oZXJpdHMoWERST2JqZWN0LCBFdmVudEVtaXR0ZXIpO1xyXG5cclxuWERST2JqZWN0LnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbihtZXRob2QsIHVybCwgcGF5bG9hZCkge1xyXG4gIGRlYnVnKCdfc3RhcnQnKTtcclxuICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgdmFyIHhkciA9IG5ldyBnbG9iYWwuWERvbWFpblJlcXVlc3QoKTtcclxuICAvLyBJRSBjYWNoZXMgZXZlbiBQT1NUc1xyXG4gIHVybCA9IHVybFV0aWxzLmFkZFF1ZXJ5KHVybCwgJ3Q9JyArICgrbmV3IERhdGUoKSkpO1xyXG5cclxuICB4ZHIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgZGVidWcoJ29uZXJyb3InKTtcclxuICAgIHNlbGYuX2Vycm9yKCk7XHJcbiAgfTtcclxuICB4ZHIub250aW1lb3V0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICBkZWJ1Zygnb250aW1lb3V0Jyk7XHJcbiAgICBzZWxmLl9lcnJvcigpO1xyXG4gIH07XHJcbiAgeGRyLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbigpIHtcclxuICAgIGRlYnVnKCdwcm9ncmVzcycsIHhkci5yZXNwb25zZVRleHQpO1xyXG4gICAgc2VsZi5lbWl0KCdjaHVuaycsIDIwMCwgeGRyLnJlc3BvbnNlVGV4dCk7XHJcbiAgfTtcclxuICB4ZHIub25sb2FkID0gZnVuY3Rpb24oKSB7XHJcbiAgICBkZWJ1ZygnbG9hZCcpO1xyXG4gICAgc2VsZi5lbWl0KCdmaW5pc2gnLCAyMDAsIHhkci5yZXNwb25zZVRleHQpO1xyXG4gICAgc2VsZi5fY2xlYW51cChmYWxzZSk7XHJcbiAgfTtcclxuICB0aGlzLnhkciA9IHhkcjtcclxuICB0aGlzLnVubG9hZFJlZiA9IGV2ZW50VXRpbHMudW5sb2FkQWRkKGZ1bmN0aW9uKCkge1xyXG4gICAgc2VsZi5fY2xlYW51cCh0cnVlKTtcclxuICB9KTtcclxuICB0cnkge1xyXG4gICAgLy8gRmFpbHMgd2l0aCBBY2Nlc3NEZW5pZWQgaWYgcG9ydCBudW1iZXIgaXMgYm9ndXNcclxuICAgIHRoaXMueGRyLm9wZW4obWV0aG9kLCB1cmwpO1xyXG4gICAgaWYgKHRoaXMudGltZW91dCkge1xyXG4gICAgICB0aGlzLnhkci50aW1lb3V0ID0gdGhpcy50aW1lb3V0O1xyXG4gICAgfVxyXG4gICAgdGhpcy54ZHIuc2VuZChwYXlsb2FkKTtcclxuICB9IGNhdGNoICh4KSB7XHJcbiAgICB0aGlzLl9lcnJvcigpO1xyXG4gIH1cclxufTtcclxuXHJcblhEUk9iamVjdC5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24oKSB7XHJcbiAgdGhpcy5lbWl0KCdmaW5pc2gnLCAwLCAnJyk7XHJcbiAgdGhpcy5fY2xlYW51cChmYWxzZSk7XHJcbn07XHJcblxyXG5YRFJPYmplY3QucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24oYWJvcnQpIHtcclxuICBkZWJ1ZygnY2xlYW51cCcsIGFib3J0KTtcclxuICBpZiAoIXRoaXMueGRyKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XHJcbiAgZXZlbnRVdGlscy51bmxvYWREZWwodGhpcy51bmxvYWRSZWYpO1xyXG5cclxuICB0aGlzLnhkci5vbnRpbWVvdXQgPSB0aGlzLnhkci5vbmVycm9yID0gdGhpcy54ZHIub25wcm9ncmVzcyA9IHRoaXMueGRyLm9ubG9hZCA9IG51bGw7XHJcbiAgaWYgKGFib3J0KSB7XHJcbiAgICB0cnkge1xyXG4gICAgICB0aGlzLnhkci5hYm9ydCgpO1xyXG4gICAgfSBjYXRjaCAoeCkge1xyXG4gICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XHJcbiAgICB9XHJcbiAgfVxyXG4gIHRoaXMudW5sb2FkUmVmID0gdGhpcy54ZHIgPSBudWxsO1xyXG59O1xyXG5cclxuWERST2JqZWN0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xyXG4gIGRlYnVnKCdjbG9zZScpO1xyXG4gIHRoaXMuX2NsZWFudXAodHJ1ZSk7XHJcbn07XHJcblxyXG4vLyBJRSA4LzkgaWYgdGhlIHJlcXVlc3QgdGFyZ2V0IHVzZXMgdGhlIHNhbWUgc2NoZW1lIC0gIzc5XHJcblhEUk9iamVjdC5lbmFibGVkID0gISEoZ2xvYmFsLlhEb21haW5SZXF1ZXN0ICYmIGJyb3dzZXIuaGFzRG9tYWluKCkpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBYRFJPYmplY3Q7XHJcblxyXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0sdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcclxuXHJcbn0se1wiLi4vLi4vdXRpbHMvYnJvd3NlclwiOjQ0LFwiLi4vLi4vdXRpbHMvZXZlbnRcIjo0NixcIi4uLy4uL3V0aWxzL3VybFwiOjUyLFwiZGVidWdcIjo1NCxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU2fV0sMzU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXHJcbiAgLCBYaHJEcml2ZXIgPSByZXF1aXJlKCcuLi9kcml2ZXIveGhyJylcclxuICA7XHJcblxyXG5mdW5jdGlvbiBYSFJDb3JzT2JqZWN0KG1ldGhvZCwgdXJsLCBwYXlsb2FkLCBvcHRzKSB7XHJcbiAgWGhyRHJpdmVyLmNhbGwodGhpcywgbWV0aG9kLCB1cmwsIHBheWxvYWQsIG9wdHMpO1xyXG59XHJcblxyXG5pbmhlcml0cyhYSFJDb3JzT2JqZWN0LCBYaHJEcml2ZXIpO1xyXG5cclxuWEhSQ29yc09iamVjdC5lbmFibGVkID0gWGhyRHJpdmVyLmVuYWJsZWQgJiYgWGhyRHJpdmVyLnN1cHBvcnRzQ09SUztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gWEhSQ29yc09iamVjdDtcclxuXHJcbn0se1wiLi4vZHJpdmVyL3hoclwiOjE3LFwiaW5oZXJpdHNcIjo1Nn1dLDM2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxyXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXHJcbiAgO1xyXG5cclxuZnVuY3Rpb24gWEhSRmFrZSgvKiBtZXRob2QsIHVybCwgcGF5bG9hZCwgb3B0cyAqLykge1xyXG4gIHZhciBzZWxmID0gdGhpcztcclxuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcclxuXHJcbiAgdGhpcy50byA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcsIDIwMCwgJ3t9Jyk7XHJcbiAgfSwgWEhSRmFrZS50aW1lb3V0KTtcclxufVxyXG5cclxuaW5oZXJpdHMoWEhSRmFrZSwgRXZlbnRFbWl0dGVyKTtcclxuXHJcblhIUkZha2UucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XHJcbiAgY2xlYXJUaW1lb3V0KHRoaXMudG8pO1xyXG59O1xyXG5cclxuWEhSRmFrZS50aW1lb3V0ID0gMjAwMDtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gWEhSRmFrZTtcclxuXHJcbn0se1wiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTZ9XSwzNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcclxuICAsIFhockRyaXZlciA9IHJlcXVpcmUoJy4uL2RyaXZlci94aHInKVxyXG4gIDtcclxuXHJcbmZ1bmN0aW9uIFhIUkxvY2FsT2JqZWN0KG1ldGhvZCwgdXJsLCBwYXlsb2FkIC8qLCBvcHRzICovKSB7XHJcbiAgWGhyRHJpdmVyLmNhbGwodGhpcywgbWV0aG9kLCB1cmwsIHBheWxvYWQsIHtcclxuICAgIG5vQ3JlZGVudGlhbHM6IHRydWVcclxuICB9KTtcclxufVxyXG5cclxuaW5oZXJpdHMoWEhSTG9jYWxPYmplY3QsIFhockRyaXZlcik7XHJcblxyXG5YSFJMb2NhbE9iamVjdC5lbmFibGVkID0gWGhyRHJpdmVyLmVuYWJsZWQ7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFhIUkxvY2FsT2JqZWN0O1xyXG5cclxufSx7XCIuLi9kcml2ZXIveGhyXCI6MTcsXCJpbmhlcml0c1wiOjU2fV0sMzg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9ldmVudCcpXHJcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL3VybCcpXHJcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcclxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxyXG4gICwgV2Vic29ja2V0RHJpdmVyID0gcmVxdWlyZSgnLi9kcml2ZXIvd2Vic29ja2V0JylcclxuICA7XHJcblxyXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xyXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDp3ZWJzb2NrZXQnKTtcclxufVxyXG5cclxuZnVuY3Rpb24gV2ViU29ja2V0VHJhbnNwb3J0KHRyYW5zVXJsLCBpZ25vcmUsIG9wdGlvbnMpIHtcclxuICBpZiAoIVdlYlNvY2tldFRyYW5zcG9ydC5lbmFibGVkKCkpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xyXG4gIH1cclxuXHJcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XHJcbiAgZGVidWcoJ2NvbnN0cnVjdG9yJywgdHJhbnNVcmwpO1xyXG5cclxuICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgdmFyIHVybCA9IHVybFV0aWxzLmFkZFBhdGgodHJhbnNVcmwsICcvd2Vic29ja2V0Jyk7XHJcbiAgaWYgKHVybC5zbGljZSgwLCA1KSA9PT0gJ2h0dHBzJykge1xyXG4gICAgdXJsID0gJ3dzcycgKyB1cmwuc2xpY2UoNSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHVybCA9ICd3cycgKyB1cmwuc2xpY2UoNCk7XHJcbiAgfVxyXG4gIHRoaXMudXJsID0gdXJsO1xyXG5cclxuICB0aGlzLndzID0gbmV3IFdlYnNvY2tldERyaXZlcih0aGlzLnVybCwgW10sIG9wdGlvbnMpO1xyXG4gIHRoaXMud3Mub25tZXNzYWdlID0gZnVuY3Rpb24oZSkge1xyXG4gICAgZGVidWcoJ21lc3NhZ2UgZXZlbnQnLCBlLmRhdGEpO1xyXG4gICAgc2VsZi5lbWl0KCdtZXNzYWdlJywgZS5kYXRhKTtcclxuICB9O1xyXG4gIC8vIEZpcmVmb3ggaGFzIGFuIGludGVyZXN0aW5nIGJ1Zy4gSWYgYSB3ZWJzb2NrZXQgY29ubmVjdGlvbiBpc1xyXG4gIC8vIGNyZWF0ZWQgYWZ0ZXIgb251bmxvYWQsIGl0IHN0YXlzIGFsaXZlIGV2ZW4gd2hlbiB1c2VyXHJcbiAgLy8gbmF2aWdhdGVzIGF3YXkgZnJvbSB0aGUgcGFnZS4gSW4gc3VjaCBzaXR1YXRpb24gbGV0J3MgbGllIC1cclxuICAvLyBsZXQncyBub3Qgb3BlbiB0aGUgd3MgY29ubmVjdGlvbiBhdCBhbGwuIFNlZTpcclxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vc29ja2pzL3NvY2tqcy1jbGllbnQvaXNzdWVzLzI4XHJcbiAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk2MDg1XHJcbiAgdGhpcy51bmxvYWRSZWYgPSB1dGlscy51bmxvYWRBZGQoZnVuY3Rpb24oKSB7XHJcbiAgICBkZWJ1ZygndW5sb2FkJyk7XHJcbiAgICBzZWxmLndzLmNsb3NlKCk7XHJcbiAgfSk7XHJcbiAgdGhpcy53cy5vbmNsb3NlID0gZnVuY3Rpb24oZSkge1xyXG4gICAgZGVidWcoJ2Nsb3NlIGV2ZW50JywgZS5jb2RlLCBlLnJlYXNvbik7XHJcbiAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgZS5jb2RlLCBlLnJlYXNvbik7XHJcbiAgICBzZWxmLl9jbGVhbnVwKCk7XHJcbiAgfTtcclxuICB0aGlzLndzLm9uZXJyb3IgPSBmdW5jdGlvbihlKSB7XHJcbiAgICBkZWJ1ZygnZXJyb3IgZXZlbnQnLCBlKTtcclxuICAgIHNlbGYuZW1pdCgnY2xvc2UnLCAxMDA2LCAnV2ViU29ja2V0IGNvbm5lY3Rpb24gYnJva2VuJyk7XHJcbiAgICBzZWxmLl9jbGVhbnVwKCk7XHJcbiAgfTtcclxufVxyXG5cclxuaW5oZXJpdHMoV2ViU29ja2V0VHJhbnNwb3J0LCBFdmVudEVtaXR0ZXIpO1xyXG5cclxuV2ViU29ja2V0VHJhbnNwb3J0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24oZGF0YSkge1xyXG4gIHZhciBtc2cgPSAnWycgKyBkYXRhICsgJ10nO1xyXG4gIGRlYnVnKCdzZW5kJywgbXNnKTtcclxuICB0aGlzLndzLnNlbmQobXNnKTtcclxufTtcclxuXHJcbldlYlNvY2tldFRyYW5zcG9ydC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcclxuICBkZWJ1ZygnY2xvc2UnKTtcclxuICB2YXIgd3MgPSB0aGlzLndzO1xyXG4gIHRoaXMuX2NsZWFudXAoKTtcclxuICBpZiAod3MpIHtcclxuICAgIHdzLmNsb3NlKCk7XHJcbiAgfVxyXG59O1xyXG5cclxuV2ViU29ja2V0VHJhbnNwb3J0LnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xyXG4gIGRlYnVnKCdfY2xlYW51cCcpO1xyXG4gIHZhciB3cyA9IHRoaXMud3M7XHJcbiAgaWYgKHdzKSB7XHJcbiAgICB3cy5vbm1lc3NhZ2UgPSB3cy5vbmNsb3NlID0gd3Mub25lcnJvciA9IG51bGw7XHJcbiAgfVxyXG4gIHV0aWxzLnVubG9hZERlbCh0aGlzLnVubG9hZFJlZik7XHJcbiAgdGhpcy51bmxvYWRSZWYgPSB0aGlzLndzID0gbnVsbDtcclxuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xyXG59O1xyXG5cclxuV2ViU29ja2V0VHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbigpIHtcclxuICBkZWJ1ZygnZW5hYmxlZCcpO1xyXG4gIHJldHVybiAhIVdlYnNvY2tldERyaXZlcjtcclxufTtcclxuV2ViU29ja2V0VHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAnd2Vic29ja2V0JztcclxuXHJcbi8vIEluIHRoZW9yeSwgd3Mgc2hvdWxkIHJlcXVpcmUgMSByb3VuZCB0cmlwLiBCdXQgaW4gY2hyb21lLCB0aGlzIGlzXHJcbi8vIG5vdCB2ZXJ5IHN0YWJsZSBvdmVyIFNTTC4gTW9zdCBsaWtlbHkgYSB3cyBjb25uZWN0aW9uIHJlcXVpcmVzIGFcclxuLy8gc2VwYXJhdGUgU1NMIGNvbm5lY3Rpb24sIGluIHdoaWNoIGNhc2UgMiByb3VuZCB0cmlwcyBhcmUgYW5cclxuLy8gYWJzb2x1dGUgbWludW11bS5cclxuV2ViU29ja2V0VHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBXZWJTb2NrZXRUcmFuc3BvcnQ7XHJcblxyXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXHJcblxyXG59LHtcIi4uL3V0aWxzL2V2ZW50XCI6NDYsXCIuLi91dGlscy91cmxcIjo1MixcIi4vZHJpdmVyL3dlYnNvY2tldFwiOjE5LFwiZGVidWdcIjo1NCxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU2fV0sMzk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXHJcbiAgLCBBamF4QmFzZWRUcmFuc3BvcnQgPSByZXF1aXJlKCcuL2xpYi9hamF4LWJhc2VkJylcclxuICAsIFhkclN0cmVhbWluZ1RyYW5zcG9ydCA9IHJlcXVpcmUoJy4veGRyLXN0cmVhbWluZycpXHJcbiAgLCBYaHJSZWNlaXZlciA9IHJlcXVpcmUoJy4vcmVjZWl2ZXIveGhyJylcclxuICAsIFhEUk9iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hkcicpXHJcbiAgO1xyXG5cclxuZnVuY3Rpb24gWGRyUG9sbGluZ1RyYW5zcG9ydCh0cmFuc1VybCkge1xyXG4gIGlmICghWERST2JqZWN0LmVuYWJsZWQpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xyXG4gIH1cclxuICBBamF4QmFzZWRUcmFuc3BvcnQuY2FsbCh0aGlzLCB0cmFuc1VybCwgJy94aHInLCBYaHJSZWNlaXZlciwgWERST2JqZWN0KTtcclxufVxyXG5cclxuaW5oZXJpdHMoWGRyUG9sbGluZ1RyYW5zcG9ydCwgQWpheEJhc2VkVHJhbnNwb3J0KTtcclxuXHJcblhkclBvbGxpbmdUcmFuc3BvcnQuZW5hYmxlZCA9IFhkclN0cmVhbWluZ1RyYW5zcG9ydC5lbmFibGVkO1xyXG5YZHJQb2xsaW5nVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAneGRyLXBvbGxpbmcnO1xyXG5YZHJQb2xsaW5nVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyOyAvLyBwcmVmbGlnaHQsIGFqYXhcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gWGRyUG9sbGluZ1RyYW5zcG9ydDtcclxuXHJcbn0se1wiLi9saWIvYWpheC1iYXNlZFwiOjI0LFwiLi9yZWNlaXZlci94aHJcIjozMixcIi4vc2VuZGVyL3hkclwiOjM0LFwiLi94ZHItc3RyZWFtaW5nXCI6NDAsXCJpbmhlcml0c1wiOjU2fV0sNDA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXHJcbiAgLCBBamF4QmFzZWRUcmFuc3BvcnQgPSByZXF1aXJlKCcuL2xpYi9hamF4LWJhc2VkJylcclxuICAsIFhoclJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlci94aHInKVxyXG4gICwgWERST2JqZWN0ID0gcmVxdWlyZSgnLi9zZW5kZXIveGRyJylcclxuICA7XHJcblxyXG4vLyBBY2NvcmRpbmcgdG86XHJcbi8vICAgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xNjQxNTA3L2RldGVjdC1icm93c2VyLXN1cHBvcnQtZm9yLWNyb3NzLWRvbWFpbi14bWxodHRwcmVxdWVzdHNcclxuLy8gICBodHRwOi8vaGFja3MubW96aWxsYS5vcmcvMjAwOS8wNy9jcm9zcy1zaXRlLXhtbGh0dHByZXF1ZXN0LXdpdGgtY29ycy9cclxuXHJcbmZ1bmN0aW9uIFhkclN0cmVhbWluZ1RyYW5zcG9ydCh0cmFuc1VybCkge1xyXG4gIGlmICghWERST2JqZWN0LmVuYWJsZWQpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xyXG4gIH1cclxuICBBamF4QmFzZWRUcmFuc3BvcnQuY2FsbCh0aGlzLCB0cmFuc1VybCwgJy94aHJfc3RyZWFtaW5nJywgWGhyUmVjZWl2ZXIsIFhEUk9iamVjdCk7XHJcbn1cclxuXHJcbmluaGVyaXRzKFhkclN0cmVhbWluZ1RyYW5zcG9ydCwgQWpheEJhc2VkVHJhbnNwb3J0KTtcclxuXHJcblhkclN0cmVhbWluZ1RyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oaW5mbykge1xyXG4gIGlmIChpbmZvLmNvb2tpZV9uZWVkZWQgfHwgaW5mby5udWxsT3JpZ2luKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIHJldHVybiBYRFJPYmplY3QuZW5hYmxlZCAmJiBpbmZvLnNhbWVTY2hlbWU7XHJcbn07XHJcblxyXG5YZHJTdHJlYW1pbmdUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICd4ZHItc3RyZWFtaW5nJztcclxuWGRyU3RyZWFtaW5nVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyOyAvLyBwcmVmbGlnaHQsIGFqYXhcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gWGRyU3RyZWFtaW5nVHJhbnNwb3J0O1xyXG5cclxufSx7XCIuL2xpYi9hamF4LWJhc2VkXCI6MjQsXCIuL3JlY2VpdmVyL3hoclwiOjMyLFwiLi9zZW5kZXIveGRyXCI6MzQsXCJpbmhlcml0c1wiOjU2fV0sNDE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXHJcbiAgLCBBamF4QmFzZWRUcmFuc3BvcnQgPSByZXF1aXJlKCcuL2xpYi9hamF4LWJhc2VkJylcclxuICAsIFhoclJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlci94aHInKVxyXG4gICwgWEhSQ29yc09iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hoci1jb3JzJylcclxuICAsIFhIUkxvY2FsT2JqZWN0ID0gcmVxdWlyZSgnLi9zZW5kZXIveGhyLWxvY2FsJylcclxuICA7XHJcblxyXG5mdW5jdGlvbiBYaHJQb2xsaW5nVHJhbnNwb3J0KHRyYW5zVXJsKSB7XHJcbiAgaWYgKCFYSFJMb2NhbE9iamVjdC5lbmFibGVkICYmICFYSFJDb3JzT2JqZWN0LmVuYWJsZWQpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xyXG4gIH1cclxuICBBamF4QmFzZWRUcmFuc3BvcnQuY2FsbCh0aGlzLCB0cmFuc1VybCwgJy94aHInLCBYaHJSZWNlaXZlciwgWEhSQ29yc09iamVjdCk7XHJcbn1cclxuXHJcbmluaGVyaXRzKFhoclBvbGxpbmdUcmFuc3BvcnQsIEFqYXhCYXNlZFRyYW5zcG9ydCk7XHJcblxyXG5YaHJQb2xsaW5nVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbihpbmZvKSB7XHJcbiAgaWYgKGluZm8ubnVsbE9yaWdpbikge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgaWYgKFhIUkxvY2FsT2JqZWN0LmVuYWJsZWQgJiYgaW5mby5zYW1lT3JpZ2luKSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcbiAgcmV0dXJuIFhIUkNvcnNPYmplY3QuZW5hYmxlZDtcclxufTtcclxuXHJcblhoclBvbGxpbmdUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICd4aHItcG9sbGluZyc7XHJcblhoclBvbGxpbmdUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7IC8vIHByZWZsaWdodCwgYWpheFxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBYaHJQb2xsaW5nVHJhbnNwb3J0O1xyXG5cclxufSx7XCIuL2xpYi9hamF4LWJhc2VkXCI6MjQsXCIuL3JlY2VpdmVyL3hoclwiOjMyLFwiLi9zZW5kZXIveGhyLWNvcnNcIjozNSxcIi4vc2VuZGVyL3hoci1sb2NhbFwiOjM3LFwiaW5oZXJpdHNcIjo1Nn1dLDQyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuKGZ1bmN0aW9uIChnbG9iYWwpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXHJcbiAgLCBBamF4QmFzZWRUcmFuc3BvcnQgPSByZXF1aXJlKCcuL2xpYi9hamF4LWJhc2VkJylcclxuICAsIFhoclJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlci94aHInKVxyXG4gICwgWEhSQ29yc09iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hoci1jb3JzJylcclxuICAsIFhIUkxvY2FsT2JqZWN0ID0gcmVxdWlyZSgnLi9zZW5kZXIveGhyLWxvY2FsJylcclxuICAsIGJyb3dzZXIgPSByZXF1aXJlKCcuLi91dGlscy9icm93c2VyJylcclxuICA7XHJcblxyXG5mdW5jdGlvbiBYaHJTdHJlYW1pbmdUcmFuc3BvcnQodHJhbnNVcmwpIHtcclxuICBpZiAoIVhIUkxvY2FsT2JqZWN0LmVuYWJsZWQgJiYgIVhIUkNvcnNPYmplY3QuZW5hYmxlZCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgY3JlYXRlZCB3aGVuIGRpc2FibGVkJyk7XHJcbiAgfVxyXG4gIEFqYXhCYXNlZFRyYW5zcG9ydC5jYWxsKHRoaXMsIHRyYW5zVXJsLCAnL3hocl9zdHJlYW1pbmcnLCBYaHJSZWNlaXZlciwgWEhSQ29yc09iamVjdCk7XHJcbn1cclxuXHJcbmluaGVyaXRzKFhoclN0cmVhbWluZ1RyYW5zcG9ydCwgQWpheEJhc2VkVHJhbnNwb3J0KTtcclxuXHJcblhoclN0cmVhbWluZ1RyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oaW5mbykge1xyXG4gIGlmIChpbmZvLm51bGxPcmlnaW4pIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgLy8gT3BlcmEgZG9lc24ndCBzdXBwb3J0IHhoci1zdHJlYW1pbmcgIzYwXHJcbiAgLy8gQnV0IGl0IG1pZ2h0IGJlIGFibGUgdG8gIzkyXHJcbiAgaWYgKGJyb3dzZXIuaXNPcGVyYSgpKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gWEhSQ29yc09iamVjdC5lbmFibGVkO1xyXG59O1xyXG5cclxuWGhyU3RyZWFtaW5nVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAneGhyLXN0cmVhbWluZyc7XHJcblhoclN0cmVhbWluZ1RyYW5zcG9ydC5yb3VuZFRyaXBzID0gMjsgLy8gcHJlZmxpZ2h0LCBhamF4XHJcblxyXG4vLyBTYWZhcmkgZ2V0cyBjb25mdXNlZCB3aGVuIGEgc3RyZWFtaW5nIGFqYXggcmVxdWVzdCBpcyBzdGFydGVkXHJcbi8vIGJlZm9yZSBvbmxvYWQuIFRoaXMgY2F1c2VzIHRoZSBsb2FkIGluZGljYXRvciB0byBzcGluIGluZGVmaW5ldGVseS5cclxuLy8gT25seSByZXF1aXJlIGJvZHkgd2hlbiB1c2VkIGluIGEgYnJvd3NlclxyXG5YaHJTdHJlYW1pbmdUcmFuc3BvcnQubmVlZEJvZHkgPSAhIWdsb2JhbC5kb2N1bWVudDtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gWGhyU3RyZWFtaW5nVHJhbnNwb3J0O1xyXG5cclxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXHJcblxyXG59LHtcIi4uL3V0aWxzL2Jyb3dzZXJcIjo0NCxcIi4vbGliL2FqYXgtYmFzZWRcIjoyNCxcIi4vcmVjZWl2ZXIveGhyXCI6MzIsXCIuL3NlbmRlci94aHItY29yc1wiOjM1LFwiLi9zZW5kZXIveGhyLWxvY2FsXCI6MzcsXCJpbmhlcml0c1wiOjU2fV0sNDM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4oZnVuY3Rpb24gKGdsb2JhbCl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbmlmIChnbG9iYWwuY3J5cHRvICYmIGdsb2JhbC5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XHJcbiAgbW9kdWxlLmV4cG9ydHMucmFuZG9tQnl0ZXMgPSBmdW5jdGlvbihsZW5ndGgpIHtcclxuICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XHJcbiAgICBnbG9iYWwuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhieXRlcyk7XHJcbiAgICByZXR1cm4gYnl0ZXM7XHJcbiAgfTtcclxufSBlbHNlIHtcclxuICBtb2R1bGUuZXhwb3J0cy5yYW5kb21CeXRlcyA9IGZ1bmN0aW9uKGxlbmd0aCkge1xyXG4gICAgdmFyIGJ5dGVzID0gbmV3IEFycmF5KGxlbmd0aCk7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGJ5dGVzW2ldID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjU2KTtcclxuICAgIH1cclxuICAgIHJldHVybiBieXRlcztcclxuICB9O1xyXG59XHJcblxyXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcclxuXHJcbn0se31dLDQ0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuKGZ1bmN0aW9uIChnbG9iYWwpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICBpc09wZXJhOiBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiBnbG9iYWwubmF2aWdhdG9yICYmXHJcbiAgICAgIC9vcGVyYS9pLnRlc3QoZ2xvYmFsLm5hdmlnYXRvci51c2VyQWdlbnQpO1xyXG4gIH1cclxuXHJcbiwgaXNLb25xdWVyb3I6IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIGdsb2JhbC5uYXZpZ2F0b3IgJiZcclxuICAgICAgL2tvbnF1ZXJvci9pLnRlc3QoZ2xvYmFsLm5hdmlnYXRvci51c2VyQWdlbnQpO1xyXG4gIH1cclxuXHJcbiAgLy8gIzE4NyB3cmFwIGRvY3VtZW50LmRvbWFpbiBpbiB0cnkvY2F0Y2ggYmVjYXVzZSBvZiBXUDggZnJvbSBmaWxlOi8vL1xyXG4sIGhhc0RvbWFpbjogZnVuY3Rpb24gKCkge1xyXG4gICAgLy8gbm9uLWJyb3dzZXIgY2xpZW50IGFsd2F5cyBoYXMgYSBkb21haW5cclxuICAgIGlmICghZ2xvYmFsLmRvY3VtZW50KSB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIHJldHVybiAhIWdsb2JhbC5kb2N1bWVudC5kb21haW47XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcclxuXHJcbn0se31dLDQ1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIEpTT04zID0gcmVxdWlyZSgnanNvbjMnKTtcclxuXHJcbi8vIFNvbWUgZXh0cmEgY2hhcmFjdGVycyB0aGF0IENocm9tZSBnZXRzIHdyb25nLCBhbmQgc3Vic3RpdHV0ZXMgd2l0aFxyXG4vLyBzb21ldGhpbmcgZWxzZSBvbiB0aGUgd2lyZS5cclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRyb2wtcmVnZXhcclxudmFyIGV4dHJhRXNjYXBhYmxlID0gL1tcXHgwMC1cXHgxZlxcdWQ4MDAtXFx1ZGZmZlxcdWZmZmVcXHVmZmZmXFx1MDMwMC1cXHUwMzMzXFx1MDMzZC1cXHUwMzQ2XFx1MDM0YS1cXHUwMzRjXFx1MDM1MC1cXHUwMzUyXFx1MDM1Ny1cXHUwMzU4XFx1MDM1Yy1cXHUwMzYyXFx1MDM3NFxcdTAzN2VcXHUwMzg3XFx1MDU5MS1cXHUwNWFmXFx1MDVjNFxcdTA2MTAtXFx1MDYxN1xcdTA2NTMtXFx1MDY1NFxcdTA2NTctXFx1MDY1YlxcdTA2NWQtXFx1MDY1ZVxcdTA2ZGYtXFx1MDZlMlxcdTA2ZWItXFx1MDZlY1xcdTA3MzBcXHUwNzMyLVxcdTA3MzNcXHUwNzM1LVxcdTA3MzZcXHUwNzNhXFx1MDczZFxcdTA3M2YtXFx1MDc0MVxcdTA3NDNcXHUwNzQ1XFx1MDc0N1xcdTA3ZWItXFx1MDdmMVxcdTA5NTFcXHUwOTU4LVxcdTA5NWZcXHUwOWRjLVxcdTA5ZGRcXHUwOWRmXFx1MGEzM1xcdTBhMzZcXHUwYTU5LVxcdTBhNWJcXHUwYTVlXFx1MGI1Yy1cXHUwYjVkXFx1MGUzOC1cXHUwZTM5XFx1MGY0M1xcdTBmNGRcXHUwZjUyXFx1MGY1N1xcdTBmNWNcXHUwZjY5XFx1MGY3Mi1cXHUwZjc2XFx1MGY3OFxcdTBmODAtXFx1MGY4M1xcdTBmOTNcXHUwZjlkXFx1MGZhMlxcdTBmYTdcXHUwZmFjXFx1MGZiOVxcdTE5MzktXFx1MTkzYVxcdTFhMTdcXHUxYjZiXFx1MWNkYS1cXHUxY2RiXFx1MWRjMC1cXHUxZGNmXFx1MWRmY1xcdTFkZmVcXHUxZjcxXFx1MWY3M1xcdTFmNzVcXHUxZjc3XFx1MWY3OVxcdTFmN2JcXHUxZjdkXFx1MWZiYlxcdTFmYmVcXHUxZmM5XFx1MWZjYlxcdTFmZDNcXHUxZmRiXFx1MWZlM1xcdTFmZWJcXHUxZmVlLVxcdTFmZWZcXHUxZmY5XFx1MWZmYlxcdTFmZmRcXHUyMDAwLVxcdTIwMDFcXHUyMGQwLVxcdTIwZDFcXHUyMGQ0LVxcdTIwZDdcXHUyMGU3LVxcdTIwZTlcXHUyMTI2XFx1MjEyYS1cXHUyMTJiXFx1MjMyOS1cXHUyMzJhXFx1MmFkY1xcdTMwMmItXFx1MzAyY1xcdWFhYjItXFx1YWFiM1xcdWY5MDAtXFx1ZmEwZFxcdWZhMTBcXHVmYTEyXFx1ZmExNS1cXHVmYTFlXFx1ZmEyMFxcdWZhMjJcXHVmYTI1LVxcdWZhMjZcXHVmYTJhLVxcdWZhMmRcXHVmYTMwLVxcdWZhNmRcXHVmYTcwLVxcdWZhZDlcXHVmYjFkXFx1ZmIxZlxcdWZiMmEtXFx1ZmIzNlxcdWZiMzgtXFx1ZmIzY1xcdWZiM2VcXHVmYjQwLVxcdWZiNDFcXHVmYjQzLVxcdWZiNDRcXHVmYjQ2LVxcdWZiNGVcXHVmZmYwLVxcdWZmZmZdL2dcclxuICAsIGV4dHJhTG9va3VwO1xyXG5cclxuLy8gVGhpcyBtYXkgYmUgcXVpdGUgc2xvdywgc28gbGV0J3MgZGVsYXkgdW50aWwgdXNlciBhY3R1YWxseSB1c2VzIGJhZFxyXG4vLyBjaGFyYWN0ZXJzLlxyXG52YXIgdW5yb2xsTG9va3VwID0gZnVuY3Rpb24oZXNjYXBhYmxlKSB7XHJcbiAgdmFyIGk7XHJcbiAgdmFyIHVucm9sbGVkID0ge307XHJcbiAgdmFyIGMgPSBbXTtcclxuICBmb3IgKGkgPSAwOyBpIDwgNjU1MzY7IGkrKykge1xyXG4gICAgYy5wdXNoKCBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpICk7XHJcbiAgfVxyXG4gIGVzY2FwYWJsZS5sYXN0SW5kZXggPSAwO1xyXG4gIGMuam9pbignJykucmVwbGFjZShlc2NhcGFibGUsIGZ1bmN0aW9uKGEpIHtcclxuICAgIHVucm9sbGVkWyBhIF0gPSAnXFxcXHUnICsgKCcwMDAwJyArIGEuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikpLnNsaWNlKC00KTtcclxuICAgIHJldHVybiAnJztcclxuICB9KTtcclxuICBlc2NhcGFibGUubGFzdEluZGV4ID0gMDtcclxuICByZXR1cm4gdW5yb2xsZWQ7XHJcbn07XHJcblxyXG4vLyBRdW90ZSBzdHJpbmcsIGFsc28gdGFraW5nIGNhcmUgb2YgdW5pY29kZSBjaGFyYWN0ZXJzIHRoYXQgYnJvd3NlcnNcclxuLy8gb2Z0ZW4gYnJlYWsuIEVzcGVjaWFsbHksIHRha2UgY2FyZSBvZiB1bmljb2RlIHN1cnJvZ2F0ZXM6XHJcbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWFwcGluZ19vZl9Vbmljb2RlX2NoYXJhY3RlcnMjU3Vycm9nYXRlc1xyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICBxdW90ZTogZnVuY3Rpb24oc3RyaW5nKSB7XHJcbiAgICB2YXIgcXVvdGVkID0gSlNPTjMuc3RyaW5naWZ5KHN0cmluZyk7XHJcblxyXG4gICAgLy8gSW4gbW9zdCBjYXNlcyB0aGlzIHNob3VsZCBiZSB2ZXJ5IGZhc3QgYW5kIGdvb2QgZW5vdWdoLlxyXG4gICAgZXh0cmFFc2NhcGFibGUubGFzdEluZGV4ID0gMDtcclxuICAgIGlmICghZXh0cmFFc2NhcGFibGUudGVzdChxdW90ZWQpKSB7XHJcbiAgICAgIHJldHVybiBxdW90ZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFleHRyYUxvb2t1cCkge1xyXG4gICAgICBleHRyYUxvb2t1cCA9IHVucm9sbExvb2t1cChleHRyYUVzY2FwYWJsZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHF1b3RlZC5yZXBsYWNlKGV4dHJhRXNjYXBhYmxlLCBmdW5jdGlvbihhKSB7XHJcbiAgICAgIHJldHVybiBleHRyYUxvb2t1cFthXTtcclxuICAgIH0pO1xyXG4gIH1cclxufTtcclxuXHJcbn0se1wianNvbjNcIjo1N31dLDQ2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuKGZ1bmN0aW9uIChnbG9iYWwpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgcmFuZG9tID0gcmVxdWlyZSgnLi9yYW5kb20nKTtcclxuXHJcbnZhciBvblVubG9hZCA9IHt9XHJcbiAgLCBhZnRlclVubG9hZCA9IGZhbHNlXHJcbiAgICAvLyBkZXRlY3QgZ29vZ2xlIGNocm9tZSBwYWNrYWdlZCBhcHBzIGJlY2F1c2UgdGhleSBkb24ndCBhbGxvdyB0aGUgJ3VubG9hZCcgZXZlbnRcclxuICAsIGlzQ2hyb21lUGFja2FnZWRBcHAgPSBnbG9iYWwuY2hyb21lICYmIGdsb2JhbC5jaHJvbWUuYXBwICYmIGdsb2JhbC5jaHJvbWUuYXBwLnJ1bnRpbWVcclxuICA7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICBhdHRhY2hFdmVudDogZnVuY3Rpb24oZXZlbnQsIGxpc3RlbmVyKSB7XHJcbiAgICBpZiAodHlwZW9mIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIGZhbHNlKTtcclxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLmRvY3VtZW50ICYmIGdsb2JhbC5hdHRhY2hFdmVudCkge1xyXG4gICAgICAvLyBJRSBxdWlya3MuXHJcbiAgICAgIC8vIEFjY29yZGluZyB0bzogaHR0cDovL3N0ZXZlc291ZGVycy5jb20vbWlzYy90ZXN0LXBvc3RtZXNzYWdlLnBocFxyXG4gICAgICAvLyB0aGUgbWVzc2FnZSBnZXRzIGRlbGl2ZXJlZCBvbmx5IHRvICdkb2N1bWVudCcsIG5vdCAnd2luZG93Jy5cclxuICAgICAgZ2xvYmFsLmRvY3VtZW50LmF0dGFjaEV2ZW50KCdvbicgKyBldmVudCwgbGlzdGVuZXIpO1xyXG4gICAgICAvLyBJIGdldCAnd2luZG93JyBmb3IgaWU4LlxyXG4gICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBsaXN0ZW5lcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuLCBkZXRhY2hFdmVudDogZnVuY3Rpb24oZXZlbnQsIGxpc3RlbmVyKSB7XHJcbiAgICBpZiAodHlwZW9mIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICBnbG9iYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIGZhbHNlKTtcclxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLmRvY3VtZW50ICYmIGdsb2JhbC5kZXRhY2hFdmVudCkge1xyXG4gICAgICBnbG9iYWwuZG9jdW1lbnQuZGV0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBsaXN0ZW5lcik7XHJcbiAgICAgIGdsb2JhbC5kZXRhY2hFdmVudCgnb24nICsgZXZlbnQsIGxpc3RlbmVyKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4sIHVubG9hZEFkZDogZnVuY3Rpb24obGlzdGVuZXIpIHtcclxuICAgIGlmIChpc0Nocm9tZVBhY2thZ2VkQXBwKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciByZWYgPSByYW5kb20uc3RyaW5nKDgpO1xyXG4gICAgb25VbmxvYWRbcmVmXSA9IGxpc3RlbmVyO1xyXG4gICAgaWYgKGFmdGVyVW5sb2FkKSB7XHJcbiAgICAgIHNldFRpbWVvdXQodGhpcy50cmlnZ2VyVW5sb2FkQ2FsbGJhY2tzLCAwKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZWY7XHJcbiAgfVxyXG5cclxuLCB1bmxvYWREZWw6IGZ1bmN0aW9uKHJlZikge1xyXG4gICAgaWYgKHJlZiBpbiBvblVubG9hZCkge1xyXG4gICAgICBkZWxldGUgb25VbmxvYWRbcmVmXTtcclxuICAgIH1cclxuICB9XHJcblxyXG4sIHRyaWdnZXJVbmxvYWRDYWxsYmFja3M6IGZ1bmN0aW9uKCkge1xyXG4gICAgZm9yICh2YXIgcmVmIGluIG9uVW5sb2FkKSB7XHJcbiAgICAgIG9uVW5sb2FkW3JlZl0oKTtcclxuICAgICAgZGVsZXRlIG9uVW5sb2FkW3JlZl07XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxudmFyIHVubG9hZFRyaWdnZXJlZCA9IGZ1bmN0aW9uKCkge1xyXG4gIGlmIChhZnRlclVubG9hZCkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBhZnRlclVubG9hZCA9IHRydWU7XHJcbiAgbW9kdWxlLmV4cG9ydHMudHJpZ2dlclVubG9hZENhbGxiYWNrcygpO1xyXG59O1xyXG5cclxuLy8gJ3VubG9hZCcgYWxvbmUgaXMgbm90IHJlbGlhYmxlIGluIG9wZXJhIHdpdGhpbiBhbiBpZnJhbWUsIGJ1dCB3ZVxyXG4vLyBjYW4ndCB1c2UgYGJlZm9yZXVubG9hZGAgYXMgSUUgZmlyZXMgaXQgb24gamF2YXNjcmlwdDogbGlua3MuXHJcbmlmICghaXNDaHJvbWVQYWNrYWdlZEFwcCkge1xyXG4gIG1vZHVsZS5leHBvcnRzLmF0dGFjaEV2ZW50KCd1bmxvYWQnLCB1bmxvYWRUcmlnZ2VyZWQpO1xyXG59XHJcblxyXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcclxuXHJcbn0se1wiLi9yYW5kb21cIjo1MH1dLDQ3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBldmVudFV0aWxzID0gcmVxdWlyZSgnLi9ldmVudCcpXHJcbiAgLCBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJylcclxuICAsIGJyb3dzZXIgPSByZXF1aXJlKCcuL2Jyb3dzZXInKVxyXG4gIDtcclxuXHJcbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XHJcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnV0aWxzOmlmcmFtZScpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICBXUHJlZml4OiAnX2pwJ1xyXG4sIGN1cnJlbnRXaW5kb3dJZDogbnVsbFxyXG5cclxuLCBwb2xsdXRlR2xvYmFsTmFtZXNwYWNlOiBmdW5jdGlvbigpIHtcclxuICAgIGlmICghKG1vZHVsZS5leHBvcnRzLldQcmVmaXggaW4gZ2xvYmFsKSkge1xyXG4gICAgICBnbG9iYWxbbW9kdWxlLmV4cG9ydHMuV1ByZWZpeF0gPSB7fTtcclxuICAgIH1cclxuICB9XHJcblxyXG4sIHBvc3RNZXNzYWdlOiBmdW5jdGlvbih0eXBlLCBkYXRhKSB7XHJcbiAgICBpZiAoZ2xvYmFsLnBhcmVudCAhPT0gZ2xvYmFsKSB7XHJcbiAgICAgIGdsb2JhbC5wYXJlbnQucG9zdE1lc3NhZ2UoSlNPTjMuc3RyaW5naWZ5KHtcclxuICAgICAgICB3aW5kb3dJZDogbW9kdWxlLmV4cG9ydHMuY3VycmVudFdpbmRvd0lkXHJcbiAgICAgICwgdHlwZTogdHlwZVxyXG4gICAgICAsIGRhdGE6IGRhdGEgfHwgJydcclxuICAgICAgfSksICcqJyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBkZWJ1ZygnQ2Fubm90IHBvc3RNZXNzYWdlLCBubyBwYXJlbnQgd2luZG93LicsIHR5cGUsIGRhdGEpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiwgY3JlYXRlSWZyYW1lOiBmdW5jdGlvbihpZnJhbWVVcmwsIGVycm9yQ2FsbGJhY2spIHtcclxuICAgIHZhciBpZnJhbWUgPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XHJcbiAgICB2YXIgdHJlZiwgdW5sb2FkUmVmO1xyXG4gICAgdmFyIHVuYXR0YWNoID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIGRlYnVnKCd1bmF0dGFjaCcpO1xyXG4gICAgICBjbGVhclRpbWVvdXQodHJlZik7XHJcbiAgICAgIC8vIEV4cGxvcmVyIGhhZCBwcm9ibGVtcyB3aXRoIHRoYXQuXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgaWZyYW1lLm9ubG9hZCA9IG51bGw7XHJcbiAgICAgIH0gY2F0Y2ggKHgpIHtcclxuICAgICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XHJcbiAgICAgIH1cclxuICAgICAgaWZyYW1lLm9uZXJyb3IgPSBudWxsO1xyXG4gICAgfTtcclxuICAgIHZhciBjbGVhbnVwID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIGRlYnVnKCdjbGVhbnVwJyk7XHJcbiAgICAgIGlmIChpZnJhbWUpIHtcclxuICAgICAgICB1bmF0dGFjaCgpO1xyXG4gICAgICAgIC8vIFRoaXMgdGltZW91dCBtYWtlcyBjaHJvbWUgZmlyZSBvbmJlZm9yZXVubG9hZCBldmVudFxyXG4gICAgICAgIC8vIHdpdGhpbiBpZnJhbWUuIFdpdGhvdXQgdGhlIHRpbWVvdXQgaXQgZ29lcyBzdHJhaWdodCB0b1xyXG4gICAgICAgIC8vIG9udW5sb2FkLlxyXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICBpZiAoaWZyYW1lKSB7XHJcbiAgICAgICAgICAgIGlmcmFtZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGlmcmFtZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZnJhbWUgPSBudWxsO1xyXG4gICAgICAgIH0sIDApO1xyXG4gICAgICAgIGV2ZW50VXRpbHMudW5sb2FkRGVsKHVubG9hZFJlZik7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICB2YXIgb25lcnJvciA9IGZ1bmN0aW9uKGVycikge1xyXG4gICAgICBkZWJ1Zygnb25lcnJvcicsIGVycik7XHJcbiAgICAgIGlmIChpZnJhbWUpIHtcclxuICAgICAgICBjbGVhbnVwKCk7XHJcbiAgICAgICAgZXJyb3JDYWxsYmFjayhlcnIpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgdmFyIHBvc3QgPSBmdW5jdGlvbihtc2csIG9yaWdpbikge1xyXG4gICAgICBkZWJ1ZygncG9zdCcsIG1zZywgb3JpZ2luKTtcclxuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgLy8gV2hlbiB0aGUgaWZyYW1lIGlzIG5vdCBsb2FkZWQsIElFIHJhaXNlcyBhbiBleGNlcHRpb25cclxuICAgICAgICAgIC8vIG9uICdjb250ZW50V2luZG93Jy5cclxuICAgICAgICAgIGlmIChpZnJhbWUgJiYgaWZyYW1lLmNvbnRlbnRXaW5kb3cpIHtcclxuICAgICAgICAgICAgaWZyYW1lLmNvbnRlbnRXaW5kb3cucG9zdE1lc3NhZ2UobXNnLCBvcmlnaW4pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcclxuICAgICAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcclxuICAgICAgICB9XHJcbiAgICAgIH0sIDApO1xyXG4gICAgfTtcclxuXHJcbiAgICBpZnJhbWUuc3JjID0gaWZyYW1lVXJsO1xyXG4gICAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICBpZnJhbWUuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xyXG4gICAgaWZyYW1lLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcclxuICAgICAgb25lcnJvcignb25lcnJvcicpO1xyXG4gICAgfTtcclxuICAgIGlmcmFtZS5vbmxvYWQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgZGVidWcoJ29ubG9hZCcpO1xyXG4gICAgICAvLyBgb25sb2FkYCBpcyB0cmlnZ2VyZWQgYmVmb3JlIHNjcmlwdHMgb24gdGhlIGlmcmFtZSBhcmVcclxuICAgICAgLy8gZXhlY3V0ZWQuIEdpdmUgaXQgZmV3IHNlY29uZHMgdG8gYWN0dWFsbHkgbG9hZCBzdHVmZi5cclxuICAgICAgY2xlYXJUaW1lb3V0KHRyZWYpO1xyXG4gICAgICB0cmVmID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICBvbmVycm9yKCdvbmxvYWQgdGltZW91dCcpO1xyXG4gICAgICB9LCAyMDAwKTtcclxuICAgIH07XHJcbiAgICBnbG9iYWwuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJhbWUpO1xyXG4gICAgdHJlZiA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgIG9uZXJyb3IoJ3RpbWVvdXQnKTtcclxuICAgIH0sIDE1MDAwKTtcclxuICAgIHVubG9hZFJlZiA9IGV2ZW50VXRpbHMudW5sb2FkQWRkKGNsZWFudXApO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgcG9zdDogcG9zdFxyXG4gICAgLCBjbGVhbnVwOiBjbGVhbnVwXHJcbiAgICAsIGxvYWRlZDogdW5hdHRhY2hcclxuICAgIH07XHJcbiAgfVxyXG5cclxuLyogZXNsaW50IG5vLXVuZGVmOiBcIm9mZlwiLCBuZXctY2FwOiBcIm9mZlwiICovXHJcbiwgY3JlYXRlSHRtbGZpbGU6IGZ1bmN0aW9uKGlmcmFtZVVybCwgZXJyb3JDYWxsYmFjaykge1xyXG4gICAgdmFyIGF4byA9IFsnQWN0aXZlJ10uY29uY2F0KCdPYmplY3QnKS5qb2luKCdYJyk7XHJcbiAgICB2YXIgZG9jID0gbmV3IGdsb2JhbFtheG9dKCdodG1sZmlsZScpO1xyXG4gICAgdmFyIHRyZWYsIHVubG9hZFJlZjtcclxuICAgIHZhciBpZnJhbWU7XHJcbiAgICB2YXIgdW5hdHRhY2ggPSBmdW5jdGlvbigpIHtcclxuICAgICAgY2xlYXJUaW1lb3V0KHRyZWYpO1xyXG4gICAgICBpZnJhbWUub25lcnJvciA9IG51bGw7XHJcbiAgICB9O1xyXG4gICAgdmFyIGNsZWFudXAgPSBmdW5jdGlvbigpIHtcclxuICAgICAgaWYgKGRvYykge1xyXG4gICAgICAgIHVuYXR0YWNoKCk7XHJcbiAgICAgICAgZXZlbnRVdGlscy51bmxvYWREZWwodW5sb2FkUmVmKTtcclxuICAgICAgICBpZnJhbWUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChpZnJhbWUpO1xyXG4gICAgICAgIGlmcmFtZSA9IGRvYyA9IG51bGw7XHJcbiAgICAgICAgQ29sbGVjdEdhcmJhZ2UoKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIHZhciBvbmVycm9yID0gZnVuY3Rpb24ocikge1xyXG4gICAgICBkZWJ1Zygnb25lcnJvcicsIHIpO1xyXG4gICAgICBpZiAoZG9jKSB7XHJcbiAgICAgICAgY2xlYW51cCgpO1xyXG4gICAgICAgIGVycm9yQ2FsbGJhY2socik7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICB2YXIgcG9zdCA9IGZ1bmN0aW9uKG1zZywgb3JpZ2luKSB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgLy8gV2hlbiB0aGUgaWZyYW1lIGlzIG5vdCBsb2FkZWQsIElFIHJhaXNlcyBhbiBleGNlcHRpb25cclxuICAgICAgICAvLyBvbiAnY29udGVudFdpbmRvdycuXHJcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICAgIGlmIChpZnJhbWUgJiYgaWZyYW1lLmNvbnRlbnRXaW5kb3cpIHtcclxuICAgICAgICAgICAgICBpZnJhbWUuY29udGVudFdpbmRvdy5wb3N0TWVzc2FnZShtc2csIG9yaWdpbik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSwgMCk7XHJcbiAgICAgIH0gY2F0Y2ggKHgpIHtcclxuICAgICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgZG9jLm9wZW4oKTtcclxuICAgIGRvYy53cml0ZSgnPGh0bWw+PHMnICsgJ2NyaXB0PicgK1xyXG4gICAgICAgICAgICAgICdkb2N1bWVudC5kb21haW49XCInICsgZ2xvYmFsLmRvY3VtZW50LmRvbWFpbiArICdcIjsnICtcclxuICAgICAgICAgICAgICAnPC9zJyArICdjcmlwdD48L2h0bWw+Jyk7XHJcbiAgICBkb2MuY2xvc2UoKTtcclxuICAgIGRvYy5wYXJlbnRXaW5kb3dbbW9kdWxlLmV4cG9ydHMuV1ByZWZpeF0gPSBnbG9iYWxbbW9kdWxlLmV4cG9ydHMuV1ByZWZpeF07XHJcbiAgICB2YXIgYyA9IGRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgIGRvYy5ib2R5LmFwcGVuZENoaWxkKGMpO1xyXG4gICAgaWZyYW1lID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xyXG4gICAgYy5hcHBlbmRDaGlsZChpZnJhbWUpO1xyXG4gICAgaWZyYW1lLnNyYyA9IGlmcmFtZVVybDtcclxuICAgIGlmcmFtZS5vbmVycm9yID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIG9uZXJyb3IoJ29uZXJyb3InKTtcclxuICAgIH07XHJcbiAgICB0cmVmID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgb25lcnJvcigndGltZW91dCcpO1xyXG4gICAgfSwgMTUwMDApO1xyXG4gICAgdW5sb2FkUmVmID0gZXZlbnRVdGlscy51bmxvYWRBZGQoY2xlYW51cCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBwb3N0OiBwb3N0XHJcbiAgICAsIGNsZWFudXA6IGNsZWFudXBcclxuICAgICwgbG9hZGVkOiB1bmF0dGFjaFxyXG4gICAgfTtcclxuICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cy5pZnJhbWVFbmFibGVkID0gZmFsc2U7XHJcbmlmIChnbG9iYWwuZG9jdW1lbnQpIHtcclxuICAvLyBwb3N0TWVzc2FnZSBtaXNiZWhhdmVzIGluIGtvbnF1ZXJvciA0LjYuNSAtIHRoZSBtZXNzYWdlcyBhcmUgZGVsaXZlcmVkIHdpdGhcclxuICAvLyBodWdlIGRlbGF5LCBvciBub3QgYXQgYWxsLlxyXG4gIG1vZHVsZS5leHBvcnRzLmlmcmFtZUVuYWJsZWQgPSAodHlwZW9mIGdsb2JhbC5wb3N0TWVzc2FnZSA9PT0gJ2Z1bmN0aW9uJyB8fFxyXG4gICAgdHlwZW9mIGdsb2JhbC5wb3N0TWVzc2FnZSA9PT0gJ29iamVjdCcpICYmICghYnJvd3Nlci5pc0tvbnF1ZXJvcigpKTtcclxufVxyXG5cclxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9LHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXHJcblxyXG59LHtcIi4vYnJvd3NlclwiOjQ0LFwiLi9ldmVudFwiOjQ2LFwiZGVidWdcIjo1NCxcImpzb24zXCI6NTd9XSw0ODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbihmdW5jdGlvbiAoZ2xvYmFsKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGxvZ09iamVjdCA9IHt9O1xyXG5bJ2xvZycsICdkZWJ1ZycsICd3YXJuJ10uZm9yRWFjaChmdW5jdGlvbiAobGV2ZWwpIHtcclxuICB2YXIgbGV2ZWxFeGlzdHM7XHJcblxyXG4gIHRyeSB7XHJcbiAgICBsZXZlbEV4aXN0cyA9IGdsb2JhbC5jb25zb2xlICYmIGdsb2JhbC5jb25zb2xlW2xldmVsXSAmJiBnbG9iYWwuY29uc29sZVtsZXZlbF0uYXBwbHk7XHJcbiAgfSBjYXRjaChlKSB7XHJcbiAgICAvLyBkbyBub3RoaW5nXHJcbiAgfVxyXG5cclxuICBsb2dPYmplY3RbbGV2ZWxdID0gbGV2ZWxFeGlzdHMgPyBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gZ2xvYmFsLmNvbnNvbGVbbGV2ZWxdLmFwcGx5KGdsb2JhbC5jb25zb2xlLCBhcmd1bWVudHMpO1xyXG4gIH0gOiAobGV2ZWwgPT09ICdsb2cnID8gZnVuY3Rpb24gKCkge30gOiBsb2dPYmplY3QubG9nKTtcclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGxvZ09iamVjdDtcclxuXHJcbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxyXG5cclxufSx7fV0sNDk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICBpc09iamVjdDogZnVuY3Rpb24ob2JqKSB7XHJcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiBvYmo7XHJcbiAgICByZXR1cm4gdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlID09PSAnb2JqZWN0JyAmJiAhIW9iajtcclxuICB9XHJcblxyXG4sIGV4dGVuZDogZnVuY3Rpb24ob2JqKSB7XHJcbiAgICBpZiAoIXRoaXMuaXNPYmplY3Qob2JqKSkge1xyXG4gICAgICByZXR1cm4gb2JqO1xyXG4gICAgfVxyXG4gICAgdmFyIHNvdXJjZSwgcHJvcDtcclxuICAgIGZvciAodmFyIGkgPSAxLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgc291cmNlID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICBmb3IgKHByb3AgaW4gc291cmNlKSB7XHJcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIHByb3ApKSB7XHJcbiAgICAgICAgICBvYmpbcHJvcF0gPSBzb3VyY2VbcHJvcF07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb2JqO1xyXG4gIH1cclxufTtcclxuXHJcbn0se31dLDUwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuLyogZ2xvYmFsIGNyeXB0bzp0cnVlICovXHJcbnZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcclxuXHJcbi8vIFRoaXMgc3RyaW5nIGhhcyBsZW5ndGggMzIsIGEgcG93ZXIgb2YgMiwgc28gdGhlIG1vZHVsdXMgZG9lc24ndCBpbnRyb2R1Y2UgYVxyXG4vLyBiaWFzLlxyXG52YXIgX3JhbmRvbVN0cmluZ0NoYXJzID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1JztcclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgc3RyaW5nOiBmdW5jdGlvbihsZW5ndGgpIHtcclxuICAgIHZhciBtYXggPSBfcmFuZG9tU3RyaW5nQ2hhcnMubGVuZ3RoO1xyXG4gICAgdmFyIGJ5dGVzID0gY3J5cHRvLnJhbmRvbUJ5dGVzKGxlbmd0aCk7XHJcbiAgICB2YXIgcmV0ID0gW107XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHJldC5wdXNoKF9yYW5kb21TdHJpbmdDaGFycy5zdWJzdHIoYnl0ZXNbaV0gJSBtYXgsIDEpKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXQuam9pbignJyk7XHJcbiAgfVxyXG5cclxuLCBudW1iZXI6IGZ1bmN0aW9uKG1heCkge1xyXG4gICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG1heCk7XHJcbiAgfVxyXG5cclxuLCBudW1iZXJTdHJpbmc6IGZ1bmN0aW9uKG1heCkge1xyXG4gICAgdmFyIHQgPSAoJycgKyAobWF4IC0gMSkpLmxlbmd0aDtcclxuICAgIHZhciBwID0gbmV3IEFycmF5KHQgKyAxKS5qb2luKCcwJyk7XHJcbiAgICByZXR1cm4gKHAgKyB0aGlzLm51bWJlcihtYXgpKS5zbGljZSgtdCk7XHJcbiAgfVxyXG59O1xyXG5cclxufSx7XCJjcnlwdG9cIjo0M31dLDUxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxuKGZ1bmN0aW9uIChwcm9jZXNzKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcclxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6dXRpbHM6dHJhbnNwb3J0Jyk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXZhaWxhYmxlVHJhbnNwb3J0cykge1xyXG4gIHJldHVybiB7XHJcbiAgICBmaWx0ZXJUb0VuYWJsZWQ6IGZ1bmN0aW9uKHRyYW5zcG9ydHNXaGl0ZWxpc3QsIGluZm8pIHtcclxuICAgICAgdmFyIHRyYW5zcG9ydHMgPSB7XHJcbiAgICAgICAgbWFpbjogW11cclxuICAgICAgLCBmYWNhZGU6IFtdXHJcbiAgICAgIH07XHJcbiAgICAgIGlmICghdHJhbnNwb3J0c1doaXRlbGlzdCkge1xyXG4gICAgICAgIHRyYW5zcG9ydHNXaGl0ZWxpc3QgPSBbXTtcclxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdHJhbnNwb3J0c1doaXRlbGlzdCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICB0cmFuc3BvcnRzV2hpdGVsaXN0ID0gW3RyYW5zcG9ydHNXaGl0ZWxpc3RdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBhdmFpbGFibGVUcmFuc3BvcnRzLmZvckVhY2goZnVuY3Rpb24odHJhbnMpIHtcclxuICAgICAgICBpZiAoIXRyYW5zKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodHJhbnMudHJhbnNwb3J0TmFtZSA9PT0gJ3dlYnNvY2tldCcgJiYgaW5mby53ZWJzb2NrZXQgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICBkZWJ1ZygnZGlzYWJsZWQgZnJvbSBzZXJ2ZXInLCAnd2Vic29ja2V0Jyk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodHJhbnNwb3J0c1doaXRlbGlzdC5sZW5ndGggJiZcclxuICAgICAgICAgICAgdHJhbnNwb3J0c1doaXRlbGlzdC5pbmRleE9mKHRyYW5zLnRyYW5zcG9ydE5hbWUpID09PSAtMSkge1xyXG4gICAgICAgICAgZGVidWcoJ25vdCBpbiB3aGl0ZWxpc3QnLCB0cmFucy50cmFuc3BvcnROYW1lKTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0cmFucy5lbmFibGVkKGluZm8pKSB7XHJcbiAgICAgICAgICBkZWJ1ZygnZW5hYmxlZCcsIHRyYW5zLnRyYW5zcG9ydE5hbWUpO1xyXG4gICAgICAgICAgdHJhbnNwb3J0cy5tYWluLnB1c2godHJhbnMpO1xyXG4gICAgICAgICAgaWYgKHRyYW5zLmZhY2FkZVRyYW5zcG9ydCkge1xyXG4gICAgICAgICAgICB0cmFuc3BvcnRzLmZhY2FkZS5wdXNoKHRyYW5zLmZhY2FkZVRyYW5zcG9ydCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGRlYnVnKCdkaXNhYmxlZCcsIHRyYW5zLnRyYW5zcG9ydE5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiB0cmFuc3BvcnRzO1xyXG4gICAgfVxyXG4gIH07XHJcbn07XHJcblxyXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXHJcblxyXG59LHtcImRlYnVnXCI6NTR9XSw1MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbihmdW5jdGlvbiAocHJvY2Vzcyl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBVUkwgPSByZXF1aXJlKCd1cmwtcGFyc2UnKTtcclxuXHJcbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XHJcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnV0aWxzOnVybCcpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICBnZXRPcmlnaW46IGZ1bmN0aW9uKHVybCkge1xyXG4gICAgaWYgKCF1cmwpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHAgPSBuZXcgVVJMKHVybCk7XHJcbiAgICBpZiAocC5wcm90b2NvbCA9PT0gJ2ZpbGU6Jykge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcG9ydCA9IHAucG9ydDtcclxuICAgIGlmICghcG9ydCkge1xyXG4gICAgICBwb3J0ID0gKHAucHJvdG9jb2wgPT09ICdodHRwczonKSA/ICc0NDMnIDogJzgwJztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcC5wcm90b2NvbCArICcvLycgKyBwLmhvc3RuYW1lICsgJzonICsgcG9ydDtcclxuICB9XHJcblxyXG4sIGlzT3JpZ2luRXF1YWw6IGZ1bmN0aW9uKGEsIGIpIHtcclxuICAgIHZhciByZXMgPSB0aGlzLmdldE9yaWdpbihhKSA9PT0gdGhpcy5nZXRPcmlnaW4oYik7XHJcbiAgICBkZWJ1Zygnc2FtZScsIGEsIGIsIHJlcyk7XHJcbiAgICByZXR1cm4gcmVzO1xyXG4gIH1cclxuXHJcbiwgaXNTY2hlbWVFcXVhbDogZnVuY3Rpb24oYSwgYikge1xyXG4gICAgcmV0dXJuIChhLnNwbGl0KCc6JylbMF0gPT09IGIuc3BsaXQoJzonKVswXSk7XHJcbiAgfVxyXG5cclxuLCBhZGRQYXRoOiBmdW5jdGlvbiAodXJsLCBwYXRoKSB7XHJcbiAgICB2YXIgcXMgPSB1cmwuc3BsaXQoJz8nKTtcclxuICAgIHJldHVybiBxc1swXSArIHBhdGggKyAocXNbMV0gPyAnPycgKyBxc1sxXSA6ICcnKTtcclxuICB9XHJcblxyXG4sIGFkZFF1ZXJ5OiBmdW5jdGlvbiAodXJsLCBxKSB7XHJcbiAgICByZXR1cm4gdXJsICsgKHVybC5pbmRleE9mKCc/JykgPT09IC0xID8gKCc/JyArIHEpIDogKCcmJyArIHEpKTtcclxuICB9XHJcbn07XHJcblxyXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXHJcblxyXG59LHtcImRlYnVnXCI6NTQsXCJ1cmwtcGFyc2VcIjo2MX1dLDUzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcclxubW9kdWxlLmV4cG9ydHMgPSAnMS4xLjUnO1xyXG5cclxufSx7fV0sNTQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xyXG4vKipcclxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxyXG4gKlxyXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXHJcbiAqL1xyXG5cclxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kZWJ1ZycpO1xyXG5leHBvcnRzLmxvZyA9IGxvZztcclxuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcclxuZXhwb3J0cy5zYXZlID0gc2F2ZTtcclxuZXhwb3J0cy5sb2FkID0gbG9hZDtcclxuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XHJcbmV4cG9ydHMuc3RvcmFnZSA9ICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWVcclxuICAgICAgICAgICAgICAgJiYgJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGNocm9tZS5zdG9yYWdlXHJcbiAgICAgICAgICAgICAgICAgID8gY2hyb21lLnN0b3JhZ2UubG9jYWxcclxuICAgICAgICAgICAgICAgICAgOiBsb2NhbHN0b3JhZ2UoKTtcclxuXHJcbi8qKlxyXG4gKiBDb2xvcnMuXHJcbiAqL1xyXG5cclxuZXhwb3J0cy5jb2xvcnMgPSBbXHJcbiAgJ2xpZ2h0c2VhZ3JlZW4nLFxyXG4gICdmb3Jlc3RncmVlbicsXHJcbiAgJ2dvbGRlbnJvZCcsXHJcbiAgJ2RvZGdlcmJsdWUnLFxyXG4gICdkYXJrb3JjaGlkJyxcclxuICAnY3JpbXNvbidcclxuXTtcclxuXHJcbi8qKlxyXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxyXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cclxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxyXG4gKlxyXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcclxuICAvLyBOQjogSW4gYW4gRWxlY3Ryb24gcHJlbG9hZCBzY3JpcHQsIGRvY3VtZW50IHdpbGwgYmUgZGVmaW5lZCBidXQgbm90IGZ1bGx5XHJcbiAgLy8gaW5pdGlhbGl6ZWQuIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gQ2hyb21lLCB3ZSdsbCBqdXN0IGRldGVjdCB0aGlzIGNhc2VcclxuICAvLyBleHBsaWNpdGx5XHJcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzICYmIHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicpIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLy8gaXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcclxuICAvLyBkb2N1bWVudCBpcyB1bmRlZmluZWQgaW4gcmVhY3QtbmF0aXZlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtbmF0aXZlL3B1bGwvMTYzMlxyXG4gIHJldHVybiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5XZWJraXRBcHBlYXJhbmNlKSB8fFxyXG4gICAgLy8gaXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xyXG4gICAgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS5maXJlYnVnIHx8ICh3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpKSkgfHxcclxuICAgIC8vIGlzIGZpcmVmb3ggPj0gdjMxP1xyXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXHJcbiAgICAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSkgfHxcclxuICAgIC8vIGRvdWJsZSBjaGVjayB3ZWJraXQgaW4gdXNlckFnZW50IGp1c3QgaW4gY2FzZSB3ZSBhcmUgaW4gYSB3b3JrZXJcclxuICAgICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXHJcbiAqL1xyXG5cclxuZXhwb3J0cy5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbih2KSB7XHJcbiAgdHJ5IHtcclxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcclxuICB9IGNhdGNoIChlcnIpIHtcclxuICAgIHJldHVybiAnW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06ICcgKyBlcnIubWVzc2FnZTtcclxuICB9XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIENvbG9yaXplIGxvZyBhcmd1bWVudHMgaWYgZW5hYmxlZC5cclxuICpcclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcclxuICB2YXIgdXNlQ29sb3JzID0gdGhpcy51c2VDb2xvcnM7XHJcblxyXG4gIGFyZ3NbMF0gPSAodXNlQ29sb3JzID8gJyVjJyA6ICcnKVxyXG4gICAgKyB0aGlzLm5hbWVzcGFjZVxyXG4gICAgKyAodXNlQ29sb3JzID8gJyAlYycgOiAnICcpXHJcbiAgICArIGFyZ3NbMF1cclxuICAgICsgKHVzZUNvbG9ycyA/ICclYyAnIDogJyAnKVxyXG4gICAgKyAnKycgKyBleHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XHJcblxyXG4gIGlmICghdXNlQ29sb3JzKSByZXR1cm47XHJcblxyXG4gIHZhciBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcclxuICBhcmdzLnNwbGljZSgxLCAwLCBjLCAnY29sb3I6IGluaGVyaXQnKVxyXG5cclxuICAvLyB0aGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxyXG4gIC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cclxuICAvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cclxuICB2YXIgaW5kZXggPSAwO1xyXG4gIHZhciBsYXN0QyA9IDA7XHJcbiAgYXJnc1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XHJcbiAgICBpZiAoJyUlJyA9PT0gbWF0Y2gpIHJldHVybjtcclxuICAgIGluZGV4Kys7XHJcbiAgICBpZiAoJyVjJyA9PT0gbWF0Y2gpIHtcclxuICAgICAgLy8gd2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXHJcbiAgICAgIC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXHJcbiAgICAgIGxhc3RDID0gaW5kZXg7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEludm9rZXMgYGNvbnNvbGUubG9nKClgIHdoZW4gYXZhaWxhYmxlLlxyXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmxvZ2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxyXG4gKlxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIGxvZygpIHtcclxuICAvLyB0aGlzIGhhY2tlcnkgaXMgcmVxdWlyZWQgZm9yIElFOC85LCB3aGVyZVxyXG4gIC8vIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uIGRvZXNuJ3QgaGF2ZSAnYXBwbHknXHJcbiAgcmV0dXJuICdvYmplY3QnID09PSB0eXBlb2YgY29uc29sZVxyXG4gICAgJiYgY29uc29sZS5sb2dcclxuICAgICYmIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGUubG9nLCBjb25zb2xlLCBhcmd1bWVudHMpO1xyXG59XHJcblxyXG4vKipcclxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXHJcbiAqIEBhcGkgcHJpdmF0ZVxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xyXG4gIHRyeSB7XHJcbiAgICBpZiAobnVsbCA9PSBuYW1lc3BhY2VzKSB7XHJcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZXhwb3J0cy5zdG9yYWdlLmRlYnVnID0gbmFtZXNwYWNlcztcclxuICAgIH1cclxuICB9IGNhdGNoKGUpIHt9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cclxuICpcclxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcblxyXG5mdW5jdGlvbiBsb2FkKCkge1xyXG4gIHZhciByO1xyXG4gIHRyeSB7XHJcbiAgICByID0gZXhwb3J0cy5zdG9yYWdlLmRlYnVnO1xyXG4gIH0gY2F0Y2goZSkge31cclxuXHJcbiAgLy8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xyXG4gIGlmICghciAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2VudicgaW4gcHJvY2Vzcykge1xyXG4gICAgciA9IHByb2Nlc3MuZW52LkRFQlVHO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHI7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFbmFibGUgbmFtZXNwYWNlcyBsaXN0ZWQgaW4gYGxvY2FsU3RvcmFnZS5kZWJ1Z2AgaW5pdGlhbGx5LlxyXG4gKi9cclxuXHJcbmV4cG9ydHMuZW5hYmxlKGxvYWQoKSk7XHJcblxyXG4vKipcclxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxyXG4gKlxyXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcclxuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcclxuICogYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cclxuICpcclxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcblxyXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKSB7XHJcbiAgdHJ5IHtcclxuICAgIHJldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlO1xyXG4gIH0gY2F0Y2ggKGUpIHt9XHJcbn1cclxuXHJcbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcclxuXHJcbn0se1wiLi9kZWJ1Z1wiOjU1fV0sNTU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cclxuICpcclxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxyXG4gKi9cclxuXHJcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZURlYnVnLmRlYnVnID0gY3JlYXRlRGVidWdbJ2RlZmF1bHQnXSA9IGNyZWF0ZURlYnVnO1xyXG5leHBvcnRzLmNvZXJjZSA9IGNvZXJjZTtcclxuZXhwb3J0cy5kaXNhYmxlID0gZGlzYWJsZTtcclxuZXhwb3J0cy5lbmFibGUgPSBlbmFibGU7XHJcbmV4cG9ydHMuZW5hYmxlZCA9IGVuYWJsZWQ7XHJcbmV4cG9ydHMuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxyXG4gKi9cclxuXHJcbmV4cG9ydHMubmFtZXMgPSBbXTtcclxuZXhwb3J0cy5za2lwcyA9IFtdO1xyXG5cclxuLyoqXHJcbiAqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cclxuICpcclxuICogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXIgb3IgdXBwZXItY2FzZSBsZXR0ZXIsIGkuZS4gXCJuXCIgYW5kIFwiTlwiLlxyXG4gKi9cclxuXHJcbmV4cG9ydHMuZm9ybWF0dGVycyA9IHt9O1xyXG5cclxuLyoqXHJcbiAqIFByZXZpb3VzIGxvZyB0aW1lc3RhbXAuXHJcbiAqL1xyXG5cclxudmFyIHByZXZUaW1lO1xyXG5cclxuLyoqXHJcbiAqIFNlbGVjdCBhIGNvbG9yLlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXHJcbiAqIEByZXR1cm4ge051bWJlcn1cclxuICogQGFwaSBwcml2YXRlXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gc2VsZWN0Q29sb3IobmFtZXNwYWNlKSB7XHJcbiAgdmFyIGhhc2ggPSAwLCBpO1xyXG5cclxuICBmb3IgKGkgaW4gbmFtZXNwYWNlKSB7XHJcbiAgICBoYXNoICA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgbmFtZXNwYWNlLmNoYXJDb2RlQXQoaSk7XHJcbiAgICBoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGV4cG9ydHMuY29sb3JzW01hdGguYWJzKGhhc2gpICUgZXhwb3J0cy5jb2xvcnMubGVuZ3RoXTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXHJcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZURlYnVnKG5hbWVzcGFjZSkge1xyXG5cclxuICBmdW5jdGlvbiBkZWJ1ZygpIHtcclxuICAgIC8vIGRpc2FibGVkP1xyXG4gICAgaWYgKCFkZWJ1Zy5lbmFibGVkKSByZXR1cm47XHJcblxyXG4gICAgdmFyIHNlbGYgPSBkZWJ1ZztcclxuXHJcbiAgICAvLyBzZXQgYGRpZmZgIHRpbWVzdGFtcFxyXG4gICAgdmFyIGN1cnIgPSArbmV3IERhdGUoKTtcclxuICAgIHZhciBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XHJcbiAgICBzZWxmLmRpZmYgPSBtcztcclxuICAgIHNlbGYucHJldiA9IHByZXZUaW1lO1xyXG4gICAgc2VsZi5jdXJyID0gY3VycjtcclxuICAgIHByZXZUaW1lID0gY3VycjtcclxuXHJcbiAgICAvLyB0dXJuIHRoZSBgYXJndW1lbnRzYCBpbnRvIGEgcHJvcGVyIEFycmF5XHJcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xyXG4gICAgfVxyXG5cclxuICAgIGFyZ3NbMF0gPSBleHBvcnRzLmNvZXJjZShhcmdzWzBdKTtcclxuXHJcbiAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBhcmdzWzBdKSB7XHJcbiAgICAgIC8vIGFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVPXHJcbiAgICAgIGFyZ3MudW5zaGlmdCgnJU8nKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBhcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xyXG4gICAgdmFyIGluZGV4ID0gMDtcclxuICAgIGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCBmdW5jdGlvbihtYXRjaCwgZm9ybWF0KSB7XHJcbiAgICAgIC8vIGlmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcclxuICAgICAgaWYgKG1hdGNoID09PSAnJSUnKSByZXR1cm4gbWF0Y2g7XHJcbiAgICAgIGluZGV4Kys7XHJcbiAgICAgIHZhciBmb3JtYXR0ZXIgPSBleHBvcnRzLmZvcm1hdHRlcnNbZm9ybWF0XTtcclxuICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBmb3JtYXR0ZXIpIHtcclxuICAgICAgICB2YXIgdmFsID0gYXJnc1tpbmRleF07XHJcbiAgICAgICAgbWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xyXG5cclxuICAgICAgICAvLyBub3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXHJcbiAgICAgICAgYXJncy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgIGluZGV4LS07XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG1hdGNoO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gYXBwbHkgZW52LXNwZWNpZmljIGZvcm1hdHRpbmcgKGNvbG9ycywgZXRjLilcclxuICAgIGV4cG9ydHMuZm9ybWF0QXJncy5jYWxsKHNlbGYsIGFyZ3MpO1xyXG5cclxuICAgIHZhciBsb2dGbiA9IGRlYnVnLmxvZyB8fCBleHBvcnRzLmxvZyB8fCBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpO1xyXG4gICAgbG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XHJcbiAgfVxyXG5cclxuICBkZWJ1Zy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XHJcbiAgZGVidWcuZW5hYmxlZCA9IGV4cG9ydHMuZW5hYmxlZChuYW1lc3BhY2UpO1xyXG4gIGRlYnVnLnVzZUNvbG9ycyA9IGV4cG9ydHMudXNlQ29sb3JzKCk7XHJcbiAgZGVidWcuY29sb3IgPSBzZWxlY3RDb2xvcihuYW1lc3BhY2UpO1xyXG5cclxuICAvLyBlbnYtc3BlY2lmaWMgaW5pdGlhbGl6YXRpb24gbG9naWMgZm9yIGRlYnVnIGluc3RhbmNlc1xyXG4gIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZXhwb3J0cy5pbml0KSB7XHJcbiAgICBleHBvcnRzLmluaXQoZGVidWcpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGRlYnVnO1xyXG59XHJcblxyXG4vKipcclxuICogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xyXG4gKiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XHJcbiAgZXhwb3J0cy5zYXZlKG5hbWVzcGFjZXMpO1xyXG5cclxuICBleHBvcnRzLm5hbWVzID0gW107XHJcbiAgZXhwb3J0cy5za2lwcyA9IFtdO1xyXG5cclxuICB2YXIgc3BsaXQgPSAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICdzdHJpbmcnID8gbmFtZXNwYWNlcyA6ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xyXG4gIHZhciBsZW4gPSBzcGxpdC5sZW5ndGg7XHJcblxyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgIGlmICghc3BsaXRbaV0pIGNvbnRpbnVlOyAvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xyXG4gICAgbmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XHJcbiAgICBpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XHJcbiAgICAgIGV4cG9ydHMuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc3Vic3RyKDEpICsgJyQnKSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBleHBvcnRzLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXHJcbiAqXHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gZGlzYWJsZSgpIHtcclxuICBleHBvcnRzLmVuYWJsZSgnJyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XHJcbiAgdmFyIGksIGxlbjtcclxuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICBpZiAoZXhwb3J0cy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgaWYgKGV4cG9ydHMubmFtZXNbaV0udGVzdChuYW1lKSkge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIGZhbHNlO1xyXG59XHJcblxyXG4vKipcclxuICogQ29lcmNlIGB2YWxgLlxyXG4gKlxyXG4gKiBAcGFyYW0ge01peGVkfSB2YWxcclxuICogQHJldHVybiB7TWl4ZWR9XHJcbiAqIEBhcGkgcHJpdmF0ZVxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcclxuICBpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XHJcbiAgcmV0dXJuIHZhbDtcclxufVxyXG5cclxufSx7XCJtc1wiOjU4fV0sNTY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG5pZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcclxuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxyXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XHJcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxyXG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcclxuICAgICAgY29uc3RydWN0b3I6IHtcclxuICAgICAgICB2YWx1ZTogY3RvcixcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfTtcclxufSBlbHNlIHtcclxuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xyXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XHJcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxyXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cclxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcclxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcclxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxyXG4gIH1cclxufVxyXG5cclxufSx7fV0sNTc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4oZnVuY3Rpb24gKGdsb2JhbCl7XHJcbi8qISBKU09OIHYzLjMuMiB8IGh0dHA6Ly9iZXN0aWVqcy5naXRodWIuaW8vanNvbjMgfCBDb3B5cmlnaHQgMjAxMi0yMDE0LCBLaXQgQ2FtYnJpZGdlIHwgaHR0cDovL2tpdC5taXQtbGljZW5zZS5vcmcgKi9cclxuOyhmdW5jdGlvbiAoKSB7XHJcbiAgLy8gRGV0ZWN0IHRoZSBgZGVmaW5lYCBmdW5jdGlvbiBleHBvc2VkIGJ5IGFzeW5jaHJvbm91cyBtb2R1bGUgbG9hZGVycy4gVGhlXHJcbiAgLy8gc3RyaWN0IGBkZWZpbmVgIGNoZWNrIGlzIG5lY2Vzc2FyeSBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIGByLmpzYC5cclxuICB2YXIgaXNMb2FkZXIgPSB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZDtcclxuXHJcbiAgLy8gQSBzZXQgb2YgdHlwZXMgdXNlZCB0byBkaXN0aW5ndWlzaCBvYmplY3RzIGZyb20gcHJpbWl0aXZlcy5cclxuICB2YXIgb2JqZWN0VHlwZXMgPSB7XHJcbiAgICBcImZ1bmN0aW9uXCI6IHRydWUsXHJcbiAgICBcIm9iamVjdFwiOiB0cnVlXHJcbiAgfTtcclxuXHJcbiAgLy8gRGV0ZWN0IHRoZSBgZXhwb3J0c2Agb2JqZWN0IGV4cG9zZWQgYnkgQ29tbW9uSlMgaW1wbGVtZW50YXRpb25zLlxyXG4gIHZhciBmcmVlRXhwb3J0cyA9IG9iamVjdFR5cGVzW3R5cGVvZiBleHBvcnRzXSAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XHJcblxyXG4gIC8vIFVzZSB0aGUgYGdsb2JhbGAgb2JqZWN0IGV4cG9zZWQgYnkgTm9kZSAoaW5jbHVkaW5nIEJyb3dzZXJpZnkgdmlhXHJcbiAgLy8gYGluc2VydC1tb2R1bGUtZ2xvYmFsc2ApLCBOYXJ3aGFsLCBhbmQgUmluZ28gYXMgdGhlIGRlZmF1bHQgY29udGV4dCxcclxuICAvLyBhbmQgdGhlIGB3aW5kb3dgIG9iamVjdCBpbiBicm93c2Vycy4gUmhpbm8gZXhwb3J0cyBhIGBnbG9iYWxgIGZ1bmN0aW9uXHJcbiAgLy8gaW5zdGVhZC5cclxuICB2YXIgcm9vdCA9IG9iamVjdFR5cGVzW3R5cGVvZiB3aW5kb3ddICYmIHdpbmRvdyB8fCB0aGlzLFxyXG4gICAgICBmcmVlR2xvYmFsID0gZnJlZUV4cG9ydHMgJiYgb2JqZWN0VHlwZXNbdHlwZW9mIG1vZHVsZV0gJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgdHlwZW9mIGdsb2JhbCA9PSBcIm9iamVjdFwiICYmIGdsb2JhbDtcclxuXHJcbiAgaWYgKGZyZWVHbG9iYWwgJiYgKGZyZWVHbG9iYWxbXCJnbG9iYWxcIl0gPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbFtcIndpbmRvd1wiXSA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsW1wic2VsZlwiXSA9PT0gZnJlZUdsb2JhbCkpIHtcclxuICAgIHJvb3QgPSBmcmVlR2xvYmFsO1xyXG4gIH1cclxuXHJcbiAgLy8gUHVibGljOiBJbml0aWFsaXplcyBKU09OIDMgdXNpbmcgdGhlIGdpdmVuIGBjb250ZXh0YCBvYmplY3QsIGF0dGFjaGluZyB0aGVcclxuICAvLyBgc3RyaW5naWZ5YCBhbmQgYHBhcnNlYCBmdW5jdGlvbnMgdG8gdGhlIHNwZWNpZmllZCBgZXhwb3J0c2Agb2JqZWN0LlxyXG4gIGZ1bmN0aW9uIHJ1bkluQ29udGV4dChjb250ZXh0LCBleHBvcnRzKSB7XHJcbiAgICBjb250ZXh0IHx8IChjb250ZXh0ID0gcm9vdFtcIk9iamVjdFwiXSgpKTtcclxuICAgIGV4cG9ydHMgfHwgKGV4cG9ydHMgPSByb290W1wiT2JqZWN0XCJdKCkpO1xyXG5cclxuICAgIC8vIE5hdGl2ZSBjb25zdHJ1Y3RvciBhbGlhc2VzLlxyXG4gICAgdmFyIE51bWJlciA9IGNvbnRleHRbXCJOdW1iZXJcIl0gfHwgcm9vdFtcIk51bWJlclwiXSxcclxuICAgICAgICBTdHJpbmcgPSBjb250ZXh0W1wiU3RyaW5nXCJdIHx8IHJvb3RbXCJTdHJpbmdcIl0sXHJcbiAgICAgICAgT2JqZWN0ID0gY29udGV4dFtcIk9iamVjdFwiXSB8fCByb290W1wiT2JqZWN0XCJdLFxyXG4gICAgICAgIERhdGUgPSBjb250ZXh0W1wiRGF0ZVwiXSB8fCByb290W1wiRGF0ZVwiXSxcclxuICAgICAgICBTeW50YXhFcnJvciA9IGNvbnRleHRbXCJTeW50YXhFcnJvclwiXSB8fCByb290W1wiU3ludGF4RXJyb3JcIl0sXHJcbiAgICAgICAgVHlwZUVycm9yID0gY29udGV4dFtcIlR5cGVFcnJvclwiXSB8fCByb290W1wiVHlwZUVycm9yXCJdLFxyXG4gICAgICAgIE1hdGggPSBjb250ZXh0W1wiTWF0aFwiXSB8fCByb290W1wiTWF0aFwiXSxcclxuICAgICAgICBuYXRpdmVKU09OID0gY29udGV4dFtcIkpTT05cIl0gfHwgcm9vdFtcIkpTT05cIl07XHJcblxyXG4gICAgLy8gRGVsZWdhdGUgdG8gdGhlIG5hdGl2ZSBgc3RyaW5naWZ5YCBhbmQgYHBhcnNlYCBpbXBsZW1lbnRhdGlvbnMuXHJcbiAgICBpZiAodHlwZW9mIG5hdGl2ZUpTT04gPT0gXCJvYmplY3RcIiAmJiBuYXRpdmVKU09OKSB7XHJcbiAgICAgIGV4cG9ydHMuc3RyaW5naWZ5ID0gbmF0aXZlSlNPTi5zdHJpbmdpZnk7XHJcbiAgICAgIGV4cG9ydHMucGFyc2UgPSBuYXRpdmVKU09OLnBhcnNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENvbnZlbmllbmNlIGFsaWFzZXMuXHJcbiAgICB2YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlLFxyXG4gICAgICAgIGdldENsYXNzID0gb2JqZWN0UHJvdG8udG9TdHJpbmcsXHJcbiAgICAgICAgaXNQcm9wZXJ0eSwgZm9yRWFjaCwgdW5kZWY7XHJcblxyXG4gICAgLy8gVGVzdCB0aGUgYERhdGUjZ2V0VVRDKmAgbWV0aG9kcy4gQmFzZWQgb24gd29yayBieSBAWWFmZmxlLlxyXG4gICAgdmFyIGlzRXh0ZW5kZWQgPSBuZXcgRGF0ZSgtMzUwOTgyNzMzNDU3MzI5Mik7XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBUaGUgYGdldFVUQ0Z1bGxZZWFyYCwgYE1vbnRoYCwgYW5kIGBEYXRlYCBtZXRob2RzIHJldHVybiBub25zZW5zaWNhbFxyXG4gICAgICAvLyByZXN1bHRzIGZvciBjZXJ0YWluIGRhdGVzIGluIE9wZXJhID49IDEwLjUzLlxyXG4gICAgICBpc0V4dGVuZGVkID0gaXNFeHRlbmRlZC5nZXRVVENGdWxsWWVhcigpID09IC0xMDkyNTIgJiYgaXNFeHRlbmRlZC5nZXRVVENNb250aCgpID09PSAwICYmIGlzRXh0ZW5kZWQuZ2V0VVRDRGF0ZSgpID09PSAxICYmXHJcbiAgICAgICAgLy8gU2FmYXJpIDwgMi4wLjIgc3RvcmVzIHRoZSBpbnRlcm5hbCBtaWxsaXNlY29uZCB0aW1lIHZhbHVlIGNvcnJlY3RseSxcclxuICAgICAgICAvLyBidXQgY2xpcHMgdGhlIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgZGF0ZSBtZXRob2RzIHRvIHRoZSByYW5nZSBvZlxyXG4gICAgICAgIC8vIHNpZ25lZCAzMi1iaXQgaW50ZWdlcnMgKFstMiAqKiAzMSwgMiAqKiAzMSAtIDFdKS5cclxuICAgICAgICBpc0V4dGVuZGVkLmdldFVUQ0hvdXJzKCkgPT0gMTAgJiYgaXNFeHRlbmRlZC5nZXRVVENNaW51dGVzKCkgPT0gMzcgJiYgaXNFeHRlbmRlZC5nZXRVVENTZWNvbmRzKCkgPT0gNiAmJiBpc0V4dGVuZGVkLmdldFVUQ01pbGxpc2Vjb25kcygpID09IDcwODtcclxuICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cclxuXHJcbiAgICAvLyBJbnRlcm5hbDogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBuYXRpdmUgYEpTT04uc3RyaW5naWZ5YCBhbmQgYHBhcnNlYFxyXG4gICAgLy8gaW1wbGVtZW50YXRpb25zIGFyZSBzcGVjLWNvbXBsaWFudC4gQmFzZWQgb24gd29yayBieSBLZW4gU255ZGVyLlxyXG4gICAgZnVuY3Rpb24gaGFzKG5hbWUpIHtcclxuICAgICAgaWYgKGhhc1tuYW1lXSAhPT0gdW5kZWYpIHtcclxuICAgICAgICAvLyBSZXR1cm4gY2FjaGVkIGZlYXR1cmUgdGVzdCByZXN1bHQuXHJcbiAgICAgICAgcmV0dXJuIGhhc1tuYW1lXTtcclxuICAgICAgfVxyXG4gICAgICB2YXIgaXNTdXBwb3J0ZWQ7XHJcbiAgICAgIGlmIChuYW1lID09IFwiYnVnLXN0cmluZy1jaGFyLWluZGV4XCIpIHtcclxuICAgICAgICAvLyBJRSA8PSA3IGRvZXNuJ3Qgc3VwcG9ydCBhY2Nlc3Npbmcgc3RyaW5nIGNoYXJhY3RlcnMgdXNpbmcgc3F1YXJlXHJcbiAgICAgICAgLy8gYnJhY2tldCBub3RhdGlvbi4gSUUgOCBvbmx5IHN1cHBvcnRzIHRoaXMgZm9yIHByaW1pdGl2ZXMuXHJcbiAgICAgICAgaXNTdXBwb3J0ZWQgPSBcImFcIlswXSAhPSBcImFcIjtcclxuICAgICAgfSBlbHNlIGlmIChuYW1lID09IFwianNvblwiKSB7XHJcbiAgICAgICAgLy8gSW5kaWNhdGVzIHdoZXRoZXIgYm90aCBgSlNPTi5zdHJpbmdpZnlgIGFuZCBgSlNPTi5wYXJzZWAgYXJlXHJcbiAgICAgICAgLy8gc3VwcG9ydGVkLlxyXG4gICAgICAgIGlzU3VwcG9ydGVkID0gaGFzKFwianNvbi1zdHJpbmdpZnlcIikgJiYgaGFzKFwianNvbi1wYXJzZVwiKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB2YXIgdmFsdWUsIHNlcmlhbGl6ZWQgPSAne1wiYVwiOlsxLHRydWUsZmFsc2UsbnVsbCxcIlxcXFx1MDAwMFxcXFxiXFxcXG5cXFxcZlxcXFxyXFxcXHRcIl19JztcclxuICAgICAgICAvLyBUZXN0IGBKU09OLnN0cmluZ2lmeWAuXHJcbiAgICAgICAgaWYgKG5hbWUgPT0gXCJqc29uLXN0cmluZ2lmeVwiKSB7XHJcbiAgICAgICAgICB2YXIgc3RyaW5naWZ5ID0gZXhwb3J0cy5zdHJpbmdpZnksIHN0cmluZ2lmeVN1cHBvcnRlZCA9IHR5cGVvZiBzdHJpbmdpZnkgPT0gXCJmdW5jdGlvblwiICYmIGlzRXh0ZW5kZWQ7XHJcbiAgICAgICAgICBpZiAoc3RyaW5naWZ5U3VwcG9ydGVkKSB7XHJcbiAgICAgICAgICAgIC8vIEEgdGVzdCBmdW5jdGlvbiBvYmplY3Qgd2l0aCBhIGN1c3RvbSBgdG9KU09OYCBtZXRob2QuXHJcbiAgICAgICAgICAgICh2YWx1ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgfSkudG9KU09OID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgc3RyaW5naWZ5U3VwcG9ydGVkID1cclxuICAgICAgICAgICAgICAgIC8vIEZpcmVmb3ggMy4xYjEgYW5kIGIyIHNlcmlhbGl6ZSBzdHJpbmcsIG51bWJlciwgYW5kIGJvb2xlYW5cclxuICAgICAgICAgICAgICAgIC8vIHByaW1pdGl2ZXMgYXMgb2JqZWN0IGxpdGVyYWxzLlxyXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KDApID09PSBcIjBcIiAmJlxyXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIGIyLCBhbmQgSlNPTiAyIHNlcmlhbGl6ZSB3cmFwcGVkIHByaW1pdGl2ZXMgYXMgb2JqZWN0XHJcbiAgICAgICAgICAgICAgICAvLyBsaXRlcmFscy5cclxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgTnVtYmVyKCkpID09PSBcIjBcIiAmJlxyXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBTdHJpbmcoKSkgPT0gJ1wiXCInICYmXHJcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgMiB0aHJvdyBhbiBlcnJvciBpZiB0aGUgdmFsdWUgaXMgYG51bGxgLCBgdW5kZWZpbmVkYCwgb3JcclxuICAgICAgICAgICAgICAgIC8vIGRvZXMgbm90IGRlZmluZSBhIGNhbm9uaWNhbCBKU09OIHJlcHJlc2VudGF0aW9uICh0aGlzIGFwcGxpZXMgdG9cclxuICAgICAgICAgICAgICAgIC8vIG9iamVjdHMgd2l0aCBgdG9KU09OYCBwcm9wZXJ0aWVzIGFzIHdlbGwsICp1bmxlc3MqIHRoZXkgYXJlIG5lc3RlZFxyXG4gICAgICAgICAgICAgICAgLy8gd2l0aGluIGFuIG9iamVjdCBvciBhcnJheSkuXHJcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoZ2V0Q2xhc3MpID09PSB1bmRlZiAmJlxyXG4gICAgICAgICAgICAgICAgLy8gSUUgOCBzZXJpYWxpemVzIGB1bmRlZmluZWRgIGFzIGBcInVuZGVmaW5lZFwiYC4gU2FmYXJpIDw9IDUuMS43IGFuZFxyXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjMgcGFzcyB0aGlzIHRlc3QuXHJcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkodW5kZWYpID09PSB1bmRlZiAmJlxyXG4gICAgICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDUuMS43IGFuZCBGRiAzLjFiMyB0aHJvdyBgRXJyb3JgcyBhbmQgYFR5cGVFcnJvcmBzLFxyXG4gICAgICAgICAgICAgICAgLy8gcmVzcGVjdGl2ZWx5LCBpZiB0aGUgdmFsdWUgaXMgb21pdHRlZCBlbnRpcmVseS5cclxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSgpID09PSB1bmRlZiAmJlxyXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIDIgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIG51bWJlcixcclxuICAgICAgICAgICAgICAgIC8vIHN0cmluZywgYXJyYXksIG9iamVjdCwgQm9vbGVhbiwgb3IgYG51bGxgIGxpdGVyYWwuIFRoaXMgYXBwbGllcyB0b1xyXG4gICAgICAgICAgICAgICAgLy8gb2JqZWN0cyB3aXRoIGN1c3RvbSBgdG9KU09OYCBtZXRob2RzIGFzIHdlbGwsIHVubGVzcyB0aGV5IGFyZSBuZXN0ZWRcclxuICAgICAgICAgICAgICAgIC8vIGluc2lkZSBvYmplY3Qgb3IgYXJyYXkgbGl0ZXJhbHMuIFlVSSAzLjAuMGIxIGlnbm9yZXMgY3VzdG9tIGB0b0pTT05gXHJcbiAgICAgICAgICAgICAgICAvLyBtZXRob2RzIGVudGlyZWx5LlxyXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KHZhbHVlKSA9PT0gXCIxXCIgJiZcclxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbdmFsdWVdKSA9PSBcIlsxXVwiICYmXHJcbiAgICAgICAgICAgICAgICAvLyBQcm90b3R5cGUgPD0gMS42LjEgc2VyaWFsaXplcyBgW3VuZGVmaW5lZF1gIGFzIGBcIltdXCJgIGluc3RlYWQgb2ZcclxuICAgICAgICAgICAgICAgIC8vIGBcIltudWxsXVwiYC5cclxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbdW5kZWZdKSA9PSBcIltudWxsXVwiICYmXHJcbiAgICAgICAgICAgICAgICAvLyBZVUkgMy4wLjBiMSBmYWlscyB0byBzZXJpYWxpemUgYG51bGxgIGxpdGVyYWxzLlxyXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG51bGwpID09IFwibnVsbFwiICYmXHJcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgMiBoYWx0cyBzZXJpYWxpemF0aW9uIGlmIGFuIGFycmF5IGNvbnRhaW5zIGEgZnVuY3Rpb246XHJcbiAgICAgICAgICAgICAgICAvLyBgWzEsIHRydWUsIGdldENsYXNzLCAxXWAgc2VyaWFsaXplcyBhcyBcIlsxLHRydWUsXSxcIi4gRkYgMy4xYjNcclxuICAgICAgICAgICAgICAgIC8vIGVsaWRlcyBub24tSlNPTiB2YWx1ZXMgZnJvbSBvYmplY3RzIGFuZCBhcnJheXMsIHVubGVzcyB0aGV5XHJcbiAgICAgICAgICAgICAgICAvLyBkZWZpbmUgY3VzdG9tIGB0b0pTT05gIG1ldGhvZHMuXHJcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoW3VuZGVmLCBnZXRDbGFzcywgbnVsbF0pID09IFwiW251bGwsbnVsbCxudWxsXVwiICYmXHJcbiAgICAgICAgICAgICAgICAvLyBTaW1wbGUgc2VyaWFsaXphdGlvbiB0ZXN0LiBGRiAzLjFiMSB1c2VzIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlc1xyXG4gICAgICAgICAgICAgICAgLy8gd2hlcmUgY2hhcmFjdGVyIGVzY2FwZSBjb2RlcyBhcmUgZXhwZWN0ZWQgKGUuZy4sIGBcXGJgID0+IGBcXHUwMDA4YCkuXHJcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoeyBcImFcIjogW3ZhbHVlLCB0cnVlLCBmYWxzZSwgbnVsbCwgXCJcXHgwMFxcYlxcblxcZlxcclxcdFwiXSB9KSA9PSBzZXJpYWxpemVkICYmXHJcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSBhbmQgYjIgaWdub3JlIHRoZSBgZmlsdGVyYCBhbmQgYHdpZHRoYCBhcmd1bWVudHMuXHJcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobnVsbCwgdmFsdWUpID09PSBcIjFcIiAmJlxyXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KFsxLCAyXSwgbnVsbCwgMSkgPT0gXCJbXFxuIDEsXFxuIDJcXG5dXCIgJiZcclxuICAgICAgICAgICAgICAgIC8vIEpTT04gMiwgUHJvdG90eXBlIDw9IDEuNywgYW5kIG9sZGVyIFdlYktpdCBidWlsZHMgaW5jb3JyZWN0bHlcclxuICAgICAgICAgICAgICAgIC8vIHNlcmlhbGl6ZSBleHRlbmRlZCB5ZWFycy5cclxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSgtOC42NGUxNSkpID09ICdcIi0yNzE4MjEtMDQtMjBUMDA6MDA6MDAuMDAwWlwiJyAmJlxyXG4gICAgICAgICAgICAgICAgLy8gVGhlIG1pbGxpc2Vjb25kcyBhcmUgb3B0aW9uYWwgaW4gRVMgNSwgYnV0IHJlcXVpcmVkIGluIDUuMS5cclxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSg4LjY0ZTE1KSkgPT0gJ1wiKzI3NTc2MC0wOS0xM1QwMDowMDowMC4wMDBaXCInICYmXHJcbiAgICAgICAgICAgICAgICAvLyBGaXJlZm94IDw9IDExLjAgaW5jb3JyZWN0bHkgc2VyaWFsaXplcyB5ZWFycyBwcmlvciB0byAwIGFzIG5lZ2F0aXZlXHJcbiAgICAgICAgICAgICAgICAvLyBmb3VyLWRpZ2l0IHllYXJzIGluc3RlYWQgb2Ygc2l4LWRpZ2l0IHllYXJzLiBDcmVkaXRzOiBAWWFmZmxlLlxyXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKC02MjE5ODc1NTJlNSkpID09ICdcIi0wMDAwMDEtMDEtMDFUMDA6MDA6MDAuMDAwWlwiJyAmJlxyXG4gICAgICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDUuMS41IGFuZCBPcGVyYSA+PSAxMC41MyBpbmNvcnJlY3RseSBzZXJpYWxpemUgbWlsbGlzZWNvbmRcclxuICAgICAgICAgICAgICAgIC8vIHZhbHVlcyBsZXNzIHRoYW4gMTAwMC4gQ3JlZGl0czogQFlhZmZsZS5cclxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSgtMSkpID09ICdcIjE5NjktMTItMzFUMjM6NTk6NTkuOTk5WlwiJztcclxuICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XHJcbiAgICAgICAgICAgICAgc3RyaW5naWZ5U3VwcG9ydGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlzU3VwcG9ydGVkID0gc3RyaW5naWZ5U3VwcG9ydGVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUZXN0IGBKU09OLnBhcnNlYC5cclxuICAgICAgICBpZiAobmFtZSA9PSBcImpzb24tcGFyc2VcIikge1xyXG4gICAgICAgICAgdmFyIHBhcnNlID0gZXhwb3J0cy5wYXJzZTtcclxuICAgICAgICAgIGlmICh0eXBlb2YgcGFyc2UgPT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIGIyIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGEgYmFyZSBsaXRlcmFsIGlzIHByb3ZpZGVkLlxyXG4gICAgICAgICAgICAgIC8vIENvbmZvcm1pbmcgaW1wbGVtZW50YXRpb25zIHNob3VsZCBhbHNvIGNvZXJjZSB0aGUgaW5pdGlhbCBhcmd1bWVudCB0b1xyXG4gICAgICAgICAgICAgIC8vIGEgc3RyaW5nIHByaW9yIHRvIHBhcnNpbmcuXHJcbiAgICAgICAgICAgICAgaWYgKHBhcnNlKFwiMFwiKSA9PT0gMCAmJiAhcGFyc2UoZmFsc2UpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTaW1wbGUgcGFyc2luZyB0ZXN0LlxyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZShzZXJpYWxpemVkKTtcclxuICAgICAgICAgICAgICAgIHZhciBwYXJzZVN1cHBvcnRlZCA9IHZhbHVlW1wiYVwiXS5sZW5ndGggPT0gNSAmJiB2YWx1ZVtcImFcIl1bMF0gPT09IDE7XHJcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VTdXBwb3J0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBTYWZhcmkgPD0gNS4xLjIgYW5kIEZGIDMuMWIxIGFsbG93IHVuZXNjYXBlZCB0YWJzIGluIHN0cmluZ3MuXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSAhcGFyc2UoJ1wiXFx0XCInKTtcclxuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxyXG4gICAgICAgICAgICAgICAgICBpZiAocGFyc2VTdXBwb3J0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgLy8gRkYgNC4wIGFuZCA0LjAuMSBhbGxvdyBsZWFkaW5nIGArYCBzaWducyBhbmQgbGVhZGluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgLy8gZGVjaW1hbCBwb2ludHMuIEZGIDQuMCwgNC4wLjEsIGFuZCBJRSA5LTEwIGFsc28gYWxsb3dcclxuICAgICAgICAgICAgICAgICAgICAgIC8vIGNlcnRhaW4gb2N0YWwgbGl0ZXJhbHMuXHJcbiAgICAgICAgICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9IHBhcnNlKFwiMDFcIikgIT09IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIGlmIChwYXJzZVN1cHBvcnRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAvLyBGRiA0LjAsIDQuMC4xLCBhbmQgUmhpbm8gMS43UjMtUjQgYWxsb3cgdHJhaWxpbmcgZGVjaW1hbFxyXG4gICAgICAgICAgICAgICAgICAgICAgLy8gcG9pbnRzLiBUaGVzZSBlbnZpcm9ubWVudHMsIGFsb25nIHdpdGggRkYgMy4xYjEgYW5kIDIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAvLyBhbHNvIGFsbG93IHRyYWlsaW5nIGNvbW1hcyBpbiBKU09OIG9iamVjdHMgYW5kIGFycmF5cy5cclxuICAgICAgICAgICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gcGFyc2UoXCIxLlwiKSAhPT0gMTtcclxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xyXG4gICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlzU3VwcG9ydGVkID0gcGFyc2VTdXBwb3J0ZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBoYXNbbmFtZV0gPSAhIWlzU3VwcG9ydGVkO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghaGFzKFwianNvblwiKSkge1xyXG4gICAgICAvLyBDb21tb24gYFtbQ2xhc3NdXWAgbmFtZSBhbGlhc2VzLlxyXG4gICAgICB2YXIgZnVuY3Rpb25DbGFzcyA9IFwiW29iamVjdCBGdW5jdGlvbl1cIixcclxuICAgICAgICAgIGRhdGVDbGFzcyA9IFwiW29iamVjdCBEYXRlXVwiLFxyXG4gICAgICAgICAgbnVtYmVyQ2xhc3MgPSBcIltvYmplY3QgTnVtYmVyXVwiLFxyXG4gICAgICAgICAgc3RyaW5nQ2xhc3MgPSBcIltvYmplY3QgU3RyaW5nXVwiLFxyXG4gICAgICAgICAgYXJyYXlDbGFzcyA9IFwiW29iamVjdCBBcnJheV1cIixcclxuICAgICAgICAgIGJvb2xlYW5DbGFzcyA9IFwiW29iamVjdCBCb29sZWFuXVwiO1xyXG5cclxuICAgICAgLy8gRGV0ZWN0IGluY29tcGxldGUgc3VwcG9ydCBmb3IgYWNjZXNzaW5nIHN0cmluZyBjaGFyYWN0ZXJzIGJ5IGluZGV4LlxyXG4gICAgICB2YXIgY2hhckluZGV4QnVnZ3kgPSBoYXMoXCJidWctc3RyaW5nLWNoYXItaW5kZXhcIik7XHJcblxyXG4gICAgICAvLyBEZWZpbmUgYWRkaXRpb25hbCB1dGlsaXR5IG1ldGhvZHMgaWYgdGhlIGBEYXRlYCBtZXRob2RzIGFyZSBidWdneS5cclxuICAgICAgaWYgKCFpc0V4dGVuZGVkKSB7XHJcbiAgICAgICAgdmFyIGZsb29yID0gTWF0aC5mbG9vcjtcclxuICAgICAgICAvLyBBIG1hcHBpbmcgYmV0d2VlbiB0aGUgbW9udGhzIG9mIHRoZSB5ZWFyIGFuZCB0aGUgbnVtYmVyIG9mIGRheXMgYmV0d2VlblxyXG4gICAgICAgIC8vIEphbnVhcnkgMXN0IGFuZCB0aGUgZmlyc3Qgb2YgdGhlIHJlc3BlY3RpdmUgbW9udGguXHJcbiAgICAgICAgdmFyIE1vbnRocyA9IFswLCAzMSwgNTksIDkwLCAxMjAsIDE1MSwgMTgxLCAyMTIsIDI0MywgMjczLCAzMDQsIDMzNF07XHJcbiAgICAgICAgLy8gSW50ZXJuYWw6IENhbGN1bGF0ZXMgdGhlIG51bWJlciBvZiBkYXlzIGJldHdlZW4gdGhlIFVuaXggZXBvY2ggYW5kIHRoZVxyXG4gICAgICAgIC8vIGZpcnN0IGRheSBvZiB0aGUgZ2l2ZW4gbW9udGguXHJcbiAgICAgICAgdmFyIGdldERheSA9IGZ1bmN0aW9uICh5ZWFyLCBtb250aCkge1xyXG4gICAgICAgICAgcmV0dXJuIE1vbnRoc1ttb250aF0gKyAzNjUgKiAoeWVhciAtIDE5NzApICsgZmxvb3IoKHllYXIgLSAxOTY5ICsgKG1vbnRoID0gKyhtb250aCA+IDEpKSkgLyA0KSAtIGZsb29yKCh5ZWFyIC0gMTkwMSArIG1vbnRoKSAvIDEwMCkgKyBmbG9vcigoeWVhciAtIDE2MDEgKyBtb250aCkgLyA0MDApO1xyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEludGVybmFsOiBEZXRlcm1pbmVzIGlmIGEgcHJvcGVydHkgaXMgYSBkaXJlY3QgcHJvcGVydHkgb2YgdGhlIGdpdmVuXHJcbiAgICAgIC8vIG9iamVjdC4gRGVsZWdhdGVzIHRvIHRoZSBuYXRpdmUgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAgbWV0aG9kLlxyXG4gICAgICBpZiAoIShpc1Byb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHkpKSB7XHJcbiAgICAgICAgaXNQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xyXG4gICAgICAgICAgdmFyIG1lbWJlcnMgPSB7fSwgY29uc3RydWN0b3I7XHJcbiAgICAgICAgICBpZiAoKG1lbWJlcnMuX19wcm90b19fID0gbnVsbCwgbWVtYmVycy5fX3Byb3RvX18gPSB7XHJcbiAgICAgICAgICAgIC8vIFRoZSAqcHJvdG8qIHByb3BlcnR5IGNhbm5vdCBiZSBzZXQgbXVsdGlwbGUgdGltZXMgaW4gcmVjZW50XHJcbiAgICAgICAgICAgIC8vIHZlcnNpb25zIG9mIEZpcmVmb3ggYW5kIFNlYU1vbmtleS5cclxuICAgICAgICAgICAgXCJ0b1N0cmluZ1wiOiAxXHJcbiAgICAgICAgICB9LCBtZW1iZXJzKS50b1N0cmluZyAhPSBnZXRDbGFzcykge1xyXG4gICAgICAgICAgICAvLyBTYWZhcmkgPD0gMi4wLjMgZG9lc24ndCBpbXBsZW1lbnQgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAsIGJ1dFxyXG4gICAgICAgICAgICAvLyBzdXBwb3J0cyB0aGUgbXV0YWJsZSAqcHJvdG8qIHByb3BlcnR5LlxyXG4gICAgICAgICAgICBpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XHJcbiAgICAgICAgICAgICAgLy8gQ2FwdHVyZSBhbmQgYnJlYWsgdGhlIG9iamVjdCdzIHByb3RvdHlwZSBjaGFpbiAoc2VlIHNlY3Rpb24gOC42LjJcclxuICAgICAgICAgICAgICAvLyBvZiB0aGUgRVMgNS4xIHNwZWMpLiBUaGUgcGFyZW50aGVzaXplZCBleHByZXNzaW9uIHByZXZlbnRzIGFuXHJcbiAgICAgICAgICAgICAgLy8gdW5zYWZlIHRyYW5zZm9ybWF0aW9uIGJ5IHRoZSBDbG9zdXJlIENvbXBpbGVyLlxyXG4gICAgICAgICAgICAgIHZhciBvcmlnaW5hbCA9IHRoaXMuX19wcm90b19fLCByZXN1bHQgPSBwcm9wZXJ0eSBpbiAodGhpcy5fX3Byb3RvX18gPSBudWxsLCB0aGlzKTtcclxuICAgICAgICAgICAgICAvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBwcm90b3R5cGUgY2hhaW4uXHJcbiAgICAgICAgICAgICAgdGhpcy5fX3Byb3RvX18gPSBvcmlnaW5hbDtcclxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gQ2FwdHVyZSBhIHJlZmVyZW5jZSB0byB0aGUgdG9wLWxldmVsIGBPYmplY3RgIGNvbnN0cnVjdG9yLlxyXG4gICAgICAgICAgICBjb25zdHJ1Y3RvciA9IG1lbWJlcnMuY29uc3RydWN0b3I7XHJcbiAgICAgICAgICAgIC8vIFVzZSB0aGUgYGNvbnN0cnVjdG9yYCBwcm9wZXJ0eSB0byBzaW11bGF0ZSBgT2JqZWN0I2hhc093blByb3BlcnR5YCBpblxyXG4gICAgICAgICAgICAvLyBvdGhlciBlbnZpcm9ubWVudHMuXHJcbiAgICAgICAgICAgIGlzUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcclxuICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gKHRoaXMuY29uc3RydWN0b3IgfHwgY29uc3RydWN0b3IpLnByb3RvdHlwZTtcclxuICAgICAgICAgICAgICByZXR1cm4gcHJvcGVydHkgaW4gdGhpcyAmJiAhKHByb3BlcnR5IGluIHBhcmVudCAmJiB0aGlzW3Byb3BlcnR5XSA9PT0gcGFyZW50W3Byb3BlcnR5XSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBtZW1iZXJzID0gbnVsbDtcclxuICAgICAgICAgIHJldHVybiBpc1Byb3BlcnR5LmNhbGwodGhpcywgcHJvcGVydHkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEludGVybmFsOiBOb3JtYWxpemVzIHRoZSBgZm9yLi4uaW5gIGl0ZXJhdGlvbiBhbGdvcml0aG0gYWNyb3NzXHJcbiAgICAgIC8vIGVudmlyb25tZW50cy4gRWFjaCBlbnVtZXJhdGVkIGtleSBpcyB5aWVsZGVkIHRvIGEgYGNhbGxiYWNrYCBmdW5jdGlvbi5cclxuICAgICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIHNpemUgPSAwLCBQcm9wZXJ0aWVzLCBtZW1iZXJzLCBwcm9wZXJ0eTtcclxuXHJcbiAgICAgICAgLy8gVGVzdHMgZm9yIGJ1Z3MgaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQncyBgZm9yLi4uaW5gIGFsZ29yaXRobS4gVGhlXHJcbiAgICAgICAgLy8gYHZhbHVlT2ZgIHByb3BlcnR5IGluaGVyaXRzIHRoZSBub24tZW51bWVyYWJsZSBmbGFnIGZyb21cclxuICAgICAgICAvLyBgT2JqZWN0LnByb3RvdHlwZWAgaW4gb2xkZXIgdmVyc2lvbnMgb2YgSUUsIE5ldHNjYXBlLCBhbmQgTW96aWxsYS5cclxuICAgICAgICAoUHJvcGVydGllcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIHRoaXMudmFsdWVPZiA9IDA7XHJcbiAgICAgICAgfSkucHJvdG90eXBlLnZhbHVlT2YgPSAwO1xyXG5cclxuICAgICAgICAvLyBJdGVyYXRlIG92ZXIgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGBQcm9wZXJ0aWVzYCBjbGFzcy5cclxuICAgICAgICBtZW1iZXJzID0gbmV3IFByb3BlcnRpZXMoKTtcclxuICAgICAgICBmb3IgKHByb3BlcnR5IGluIG1lbWJlcnMpIHtcclxuICAgICAgICAgIC8vIElnbm9yZSBhbGwgcHJvcGVydGllcyBpbmhlcml0ZWQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuXHJcbiAgICAgICAgICBpZiAoaXNQcm9wZXJ0eS5jYWxsKG1lbWJlcnMsIHByb3BlcnR5KSkge1xyXG4gICAgICAgICAgICBzaXplKys7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFByb3BlcnRpZXMgPSBtZW1iZXJzID0gbnVsbDtcclxuXHJcbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBpdGVyYXRpb24gYWxnb3JpdGhtLlxyXG4gICAgICAgIGlmICghc2l6ZSkge1xyXG4gICAgICAgICAgLy8gQSBsaXN0IG9mIG5vbi1lbnVtZXJhYmxlIHByb3BlcnRpZXMgaW5oZXJpdGVkIGZyb20gYE9iamVjdC5wcm90b3R5cGVgLlxyXG4gICAgICAgICAgbWVtYmVycyA9IFtcInZhbHVlT2ZcIiwgXCJ0b1N0cmluZ1wiLCBcInRvTG9jYWxlU3RyaW5nXCIsIFwicHJvcGVydHlJc0VudW1lcmFibGVcIiwgXCJpc1Byb3RvdHlwZU9mXCIsIFwiaGFzT3duUHJvcGVydHlcIiwgXCJjb25zdHJ1Y3RvclwiXTtcclxuICAgICAgICAgIC8vIElFIDw9IDgsIE1vemlsbGEgMS4wLCBhbmQgTmV0c2NhcGUgNi4yIGlnbm9yZSBzaGFkb3dlZCBub24tZW51bWVyYWJsZVxyXG4gICAgICAgICAgLy8gcHJvcGVydGllcy5cclxuICAgICAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICB2YXIgaXNGdW5jdGlvbiA9IGdldENsYXNzLmNhbGwob2JqZWN0KSA9PSBmdW5jdGlvbkNsYXNzLCBwcm9wZXJ0eSwgbGVuZ3RoO1xyXG4gICAgICAgICAgICB2YXIgaGFzUHJvcGVydHkgPSAhaXNGdW5jdGlvbiAmJiB0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yICE9IFwiZnVuY3Rpb25cIiAmJiBvYmplY3RUeXBlc1t0eXBlb2Ygb2JqZWN0Lmhhc093blByb3BlcnR5XSAmJiBvYmplY3QuaGFzT3duUHJvcGVydHkgfHwgaXNQcm9wZXJ0eTtcclxuICAgICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcclxuICAgICAgICAgICAgICAvLyBHZWNrbyA8PSAxLjAgZW51bWVyYXRlcyB0aGUgYHByb3RvdHlwZWAgcHJvcGVydHkgb2YgZnVuY3Rpb25zIHVuZGVyXHJcbiAgICAgICAgICAgICAgLy8gY2VydGFpbiBjb25kaXRpb25zOyBJRSBkb2VzIG5vdC5cclxuICAgICAgICAgICAgICBpZiAoIShpc0Z1bmN0aW9uICYmIHByb3BlcnR5ID09IFwicHJvdG90eXBlXCIpICYmIGhhc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gTWFudWFsbHkgaW52b2tlIHRoZSBjYWxsYmFjayBmb3IgZWFjaCBub24tZW51bWVyYWJsZSBwcm9wZXJ0eS5cclxuICAgICAgICAgICAgZm9yIChsZW5ndGggPSBtZW1iZXJzLmxlbmd0aDsgcHJvcGVydHkgPSBtZW1iZXJzWy0tbGVuZ3RoXTsgaGFzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSAmJiBjYWxsYmFjayhwcm9wZXJ0eSkpO1xyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9IGVsc2UgaWYgKHNpemUgPT0gMikge1xyXG4gICAgICAgICAgLy8gU2FmYXJpIDw9IDIuMC40IGVudW1lcmF0ZXMgc2hhZG93ZWQgcHJvcGVydGllcyB0d2ljZS5cclxuICAgICAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBzZXQgb2YgaXRlcmF0ZWQgcHJvcGVydGllcy5cclxuICAgICAgICAgICAgdmFyIG1lbWJlcnMgPSB7fSwgaXNGdW5jdGlvbiA9IGdldENsYXNzLmNhbGwob2JqZWN0KSA9PSBmdW5jdGlvbkNsYXNzLCBwcm9wZXJ0eTtcclxuICAgICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcclxuICAgICAgICAgICAgICAvLyBTdG9yZSBlYWNoIHByb3BlcnR5IG5hbWUgdG8gcHJldmVudCBkb3VibGUgZW51bWVyYXRpb24uIFRoZVxyXG4gICAgICAgICAgICAgIC8vIGBwcm90b3R5cGVgIHByb3BlcnR5IG9mIGZ1bmN0aW9ucyBpcyBub3QgZW51bWVyYXRlZCBkdWUgdG8gY3Jvc3MtXHJcbiAgICAgICAgICAgICAgLy8gZW52aXJvbm1lbnQgaW5jb25zaXN0ZW5jaWVzLlxyXG4gICAgICAgICAgICAgIGlmICghKGlzRnVuY3Rpb24gJiYgcHJvcGVydHkgPT0gXCJwcm90b3R5cGVcIikgJiYgIWlzUHJvcGVydHkuY2FsbChtZW1iZXJzLCBwcm9wZXJ0eSkgJiYgKG1lbWJlcnNbcHJvcGVydHldID0gMSkgJiYgaXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBObyBidWdzIGRldGVjdGVkOyB1c2UgdGhlIHN0YW5kYXJkIGBmb3IuLi5pbmAgYWxnb3JpdGhtLlxyXG4gICAgICAgICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIHZhciBpc0Z1bmN0aW9uID0gZ2V0Q2xhc3MuY2FsbChvYmplY3QpID09IGZ1bmN0aW9uQ2xhc3MsIHByb3BlcnR5LCBpc0NvbnN0cnVjdG9yO1xyXG4gICAgICAgICAgICBmb3IgKHByb3BlcnR5IGluIG9iamVjdCkge1xyXG4gICAgICAgICAgICAgIGlmICghKGlzRnVuY3Rpb24gJiYgcHJvcGVydHkgPT0gXCJwcm90b3R5cGVcIikgJiYgaXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpICYmICEoaXNDb25zdHJ1Y3RvciA9IHByb3BlcnR5ID09PSBcImNvbnN0cnVjdG9yXCIpKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIE1hbnVhbGx5IGludm9rZSB0aGUgY2FsbGJhY2sgZm9yIHRoZSBgY29uc3RydWN0b3JgIHByb3BlcnR5IGR1ZSB0b1xyXG4gICAgICAgICAgICAvLyBjcm9zcy1lbnZpcm9ubWVudCBpbmNvbnNpc3RlbmNpZXMuXHJcbiAgICAgICAgICAgIGlmIChpc0NvbnN0cnVjdG9yIHx8IGlzUHJvcGVydHkuY2FsbChvYmplY3QsIChwcm9wZXJ0eSA9IFwiY29uc3RydWN0b3JcIikpKSB7XHJcbiAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZm9yRWFjaChvYmplY3QsIGNhbGxiYWNrKTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIC8vIFB1YmxpYzogU2VyaWFsaXplcyBhIEphdmFTY3JpcHQgYHZhbHVlYCBhcyBhIEpTT04gc3RyaW5nLiBUaGUgb3B0aW9uYWxcclxuICAgICAgLy8gYGZpbHRlcmAgYXJndW1lbnQgbWF5IHNwZWNpZnkgZWl0aGVyIGEgZnVuY3Rpb24gdGhhdCBhbHRlcnMgaG93IG9iamVjdCBhbmRcclxuICAgICAgLy8gYXJyYXkgbWVtYmVycyBhcmUgc2VyaWFsaXplZCwgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncyBhbmQgbnVtYmVycyB0aGF0XHJcbiAgICAgIC8vIGluZGljYXRlcyB3aGljaCBwcm9wZXJ0aWVzIHNob3VsZCBiZSBzZXJpYWxpemVkLiBUaGUgb3B0aW9uYWwgYHdpZHRoYFxyXG4gICAgICAvLyBhcmd1bWVudCBtYXkgYmUgZWl0aGVyIGEgc3RyaW5nIG9yIG51bWJlciB0aGF0IHNwZWNpZmllcyB0aGUgaW5kZW50YXRpb25cclxuICAgICAgLy8gbGV2ZWwgb2YgdGhlIG91dHB1dC5cclxuICAgICAgaWYgKCFoYXMoXCJqc29uLXN0cmluZ2lmeVwiKSkge1xyXG4gICAgICAgIC8vIEludGVybmFsOiBBIG1hcCBvZiBjb250cm9sIGNoYXJhY3RlcnMgYW5kIHRoZWlyIGVzY2FwZWQgZXF1aXZhbGVudHMuXHJcbiAgICAgICAgdmFyIEVzY2FwZXMgPSB7XHJcbiAgICAgICAgICA5MjogXCJcXFxcXFxcXFwiLFxyXG4gICAgICAgICAgMzQ6ICdcXFxcXCInLFxyXG4gICAgICAgICAgODogXCJcXFxcYlwiLFxyXG4gICAgICAgICAgMTI6IFwiXFxcXGZcIixcclxuICAgICAgICAgIDEwOiBcIlxcXFxuXCIsXHJcbiAgICAgICAgICAxMzogXCJcXFxcclwiLFxyXG4gICAgICAgICAgOTogXCJcXFxcdFwiXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gSW50ZXJuYWw6IENvbnZlcnRzIGB2YWx1ZWAgaW50byBhIHplcm8tcGFkZGVkIHN0cmluZyBzdWNoIHRoYXQgaXRzXHJcbiAgICAgICAgLy8gbGVuZ3RoIGlzIGF0IGxlYXN0IGVxdWFsIHRvIGB3aWR0aGAuIFRoZSBgd2lkdGhgIG11c3QgYmUgPD0gNi5cclxuICAgICAgICB2YXIgbGVhZGluZ1plcm9lcyA9IFwiMDAwMDAwXCI7XHJcbiAgICAgICAgdmFyIHRvUGFkZGVkU3RyaW5nID0gZnVuY3Rpb24gKHdpZHRoLCB2YWx1ZSkge1xyXG4gICAgICAgICAgLy8gVGhlIGB8fCAwYCBleHByZXNzaW9uIGlzIG5lY2Vzc2FyeSB0byB3b3JrIGFyb3VuZCBhIGJ1ZyBpblxyXG4gICAgICAgICAgLy8gT3BlcmEgPD0gNy41NHUyIHdoZXJlIGAwID09IC0wYCwgYnV0IGBTdHJpbmcoLTApICE9PSBcIjBcImAuXHJcbiAgICAgICAgICByZXR1cm4gKGxlYWRpbmdaZXJvZXMgKyAodmFsdWUgfHwgMCkpLnNsaWNlKC13aWR0aCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gSW50ZXJuYWw6IERvdWJsZS1xdW90ZXMgYSBzdHJpbmcgYHZhbHVlYCwgcmVwbGFjaW5nIGFsbCBBU0NJSSBjb250cm9sXHJcbiAgICAgICAgLy8gY2hhcmFjdGVycyAoY2hhcmFjdGVycyB3aXRoIGNvZGUgdW5pdCB2YWx1ZXMgYmV0d2VlbiAwIGFuZCAzMSkgd2l0aFxyXG4gICAgICAgIC8vIHRoZWlyIGVzY2FwZWQgZXF1aXZhbGVudHMuIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgdGhlXHJcbiAgICAgICAgLy8gYFF1b3RlKHZhbHVlKWAgb3BlcmF0aW9uIGRlZmluZWQgaW4gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMy5cclxuICAgICAgICB2YXIgdW5pY29kZVByZWZpeCA9IFwiXFxcXHUwMFwiO1xyXG4gICAgICAgIHZhciBxdW90ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgdmFyIHJlc3VsdCA9ICdcIicsIGluZGV4ID0gMCwgbGVuZ3RoID0gdmFsdWUubGVuZ3RoLCB1c2VDaGFySW5kZXggPSAhY2hhckluZGV4QnVnZ3kgfHwgbGVuZ3RoID4gMTA7XHJcbiAgICAgICAgICB2YXIgc3ltYm9scyA9IHVzZUNoYXJJbmRleCAmJiAoY2hhckluZGV4QnVnZ3kgPyB2YWx1ZS5zcGxpdChcIlwiKSA6IHZhbHVlKTtcclxuICAgICAgICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgICAgICB2YXIgY2hhckNvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KGluZGV4KTtcclxuICAgICAgICAgICAgLy8gSWYgdGhlIGNoYXJhY3RlciBpcyBhIGNvbnRyb2wgY2hhcmFjdGVyLCBhcHBlbmQgaXRzIFVuaWNvZGUgb3JcclxuICAgICAgICAgICAgLy8gc2hvcnRoYW5kIGVzY2FwZSBzZXF1ZW5jZTsgb3RoZXJ3aXNlLCBhcHBlbmQgdGhlIGNoYXJhY3RlciBhcy1pcy5cclxuICAgICAgICAgICAgc3dpdGNoIChjaGFyQ29kZSkge1xyXG4gICAgICAgICAgICAgIGNhc2UgODogY2FzZSA5OiBjYXNlIDEwOiBjYXNlIDEyOiBjYXNlIDEzOiBjYXNlIDM0OiBjYXNlIDkyOlxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IEVzY2FwZXNbY2hhckNvZGVdO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA8IDMyKSB7XHJcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSB1bmljb2RlUHJlZml4ICsgdG9QYWRkZWRTdHJpbmcoMiwgY2hhckNvZGUudG9TdHJpbmcoMTYpKTtcclxuICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gdXNlQ2hhckluZGV4ID8gc3ltYm9sc1tpbmRleF0gOiB2YWx1ZS5jaGFyQXQoaW5kZXgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgJ1wiJztcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBJbnRlcm5hbDogUmVjdXJzaXZlbHkgc2VyaWFsaXplcyBhbiBvYmplY3QuIEltcGxlbWVudHMgdGhlXHJcbiAgICAgICAgLy8gYFN0cihrZXksIGhvbGRlcilgLCBgSk8odmFsdWUpYCwgYW5kIGBKQSh2YWx1ZSlgIG9wZXJhdGlvbnMuXHJcbiAgICAgICAgdmFyIHNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSwgb2JqZWN0LCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgaW5kZW50YXRpb24sIHN0YWNrKSB7XHJcbiAgICAgICAgICB2YXIgdmFsdWUsIGNsYXNzTmFtZSwgeWVhciwgbW9udGgsIGRhdGUsIHRpbWUsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIHJlc3VsdHMsIGVsZW1lbnQsIGluZGV4LCBsZW5ndGgsIHByZWZpeCwgcmVzdWx0O1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgLy8gTmVjZXNzYXJ5IGZvciBob3N0IG9iamVjdCBzdXBwb3J0LlxyXG4gICAgICAgICAgICB2YWx1ZSA9IG9iamVjdFtwcm9wZXJ0eV07XHJcbiAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XHJcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIgJiYgdmFsdWUpIHtcclxuICAgICAgICAgICAgY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh2YWx1ZSk7XHJcbiAgICAgICAgICAgIGlmIChjbGFzc05hbWUgPT0gZGF0ZUNsYXNzICYmICFpc1Byb3BlcnR5LmNhbGwodmFsdWUsIFwidG9KU09OXCIpKSB7XHJcbiAgICAgICAgICAgICAgaWYgKHZhbHVlID4gLTEgLyAwICYmIHZhbHVlIDwgMSAvIDApIHtcclxuICAgICAgICAgICAgICAgIC8vIERhdGVzIGFyZSBzZXJpYWxpemVkIGFjY29yZGluZyB0byB0aGUgYERhdGUjdG9KU09OYCBtZXRob2RcclxuICAgICAgICAgICAgICAgIC8vIHNwZWNpZmllZCBpbiBFUyA1LjEgc2VjdGlvbiAxNS45LjUuNDQuIFNlZSBzZWN0aW9uIDE1LjkuMS4xNVxyXG4gICAgICAgICAgICAgICAgLy8gZm9yIHRoZSBJU08gODYwMSBkYXRlIHRpbWUgc3RyaW5nIGZvcm1hdC5cclxuICAgICAgICAgICAgICAgIGlmIChnZXREYXkpIHtcclxuICAgICAgICAgICAgICAgICAgLy8gTWFudWFsbHkgY29tcHV0ZSB0aGUgeWVhciwgbW9udGgsIGRhdGUsIGhvdXJzLCBtaW51dGVzLFxyXG4gICAgICAgICAgICAgICAgICAvLyBzZWNvbmRzLCBhbmQgbWlsbGlzZWNvbmRzIGlmIHRoZSBgZ2V0VVRDKmAgbWV0aG9kcyBhcmVcclxuICAgICAgICAgICAgICAgICAgLy8gYnVnZ3kuIEFkYXB0ZWQgZnJvbSBAWWFmZmxlJ3MgYGRhdGUtc2hpbWAgcHJvamVjdC5cclxuICAgICAgICAgICAgICAgICAgZGF0ZSA9IGZsb29yKHZhbHVlIC8gODY0ZTUpO1xyXG4gICAgICAgICAgICAgICAgICBmb3IgKHllYXIgPSBmbG9vcihkYXRlIC8gMzY1LjI0MjUpICsgMTk3MCAtIDE7IGdldERheSh5ZWFyICsgMSwgMCkgPD0gZGF0ZTsgeWVhcisrKTtcclxuICAgICAgICAgICAgICAgICAgZm9yIChtb250aCA9IGZsb29yKChkYXRlIC0gZ2V0RGF5KHllYXIsIDApKSAvIDMwLjQyKTsgZ2V0RGF5KHllYXIsIG1vbnRoICsgMSkgPD0gZGF0ZTsgbW9udGgrKyk7XHJcbiAgICAgICAgICAgICAgICAgIGRhdGUgPSAxICsgZGF0ZSAtIGdldERheSh5ZWFyLCBtb250aCk7XHJcbiAgICAgICAgICAgICAgICAgIC8vIFRoZSBgdGltZWAgdmFsdWUgc3BlY2lmaWVzIHRoZSB0aW1lIHdpdGhpbiB0aGUgZGF5IChzZWUgRVNcclxuICAgICAgICAgICAgICAgICAgLy8gNS4xIHNlY3Rpb24gMTUuOS4xLjIpLiBUaGUgZm9ybXVsYSBgKEEgJSBCICsgQikgJSBCYCBpcyB1c2VkXHJcbiAgICAgICAgICAgICAgICAgIC8vIHRvIGNvbXB1dGUgYEEgbW9kdWxvIEJgLCBhcyB0aGUgYCVgIG9wZXJhdG9yIGRvZXMgbm90XHJcbiAgICAgICAgICAgICAgICAgIC8vIGNvcnJlc3BvbmQgdG8gdGhlIGBtb2R1bG9gIG9wZXJhdGlvbiBmb3IgbmVnYXRpdmUgbnVtYmVycy5cclxuICAgICAgICAgICAgICAgICAgdGltZSA9ICh2YWx1ZSAlIDg2NGU1ICsgODY0ZTUpICUgODY0ZTU7XHJcbiAgICAgICAgICAgICAgICAgIC8vIFRoZSBob3VycywgbWludXRlcywgc2Vjb25kcywgYW5kIG1pbGxpc2Vjb25kcyBhcmUgb2J0YWluZWQgYnlcclxuICAgICAgICAgICAgICAgICAgLy8gZGVjb21wb3NpbmcgdGhlIHRpbWUgd2l0aGluIHRoZSBkYXkuIFNlZSBzZWN0aW9uIDE1LjkuMS4xMC5cclxuICAgICAgICAgICAgICAgICAgaG91cnMgPSBmbG9vcih0aW1lIC8gMzZlNSkgJSAyNDtcclxuICAgICAgICAgICAgICAgICAgbWludXRlcyA9IGZsb29yKHRpbWUgLyA2ZTQpICUgNjA7XHJcbiAgICAgICAgICAgICAgICAgIHNlY29uZHMgPSBmbG9vcih0aW1lIC8gMWUzKSAlIDYwO1xyXG4gICAgICAgICAgICAgICAgICBtaWxsaXNlY29uZHMgPSB0aW1lICUgMWUzO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgeWVhciA9IHZhbHVlLmdldFVUQ0Z1bGxZZWFyKCk7XHJcbiAgICAgICAgICAgICAgICAgIG1vbnRoID0gdmFsdWUuZ2V0VVRDTW9udGgoKTtcclxuICAgICAgICAgICAgICAgICAgZGF0ZSA9IHZhbHVlLmdldFVUQ0RhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgaG91cnMgPSB2YWx1ZS5nZXRVVENIb3VycygpO1xyXG4gICAgICAgICAgICAgICAgICBtaW51dGVzID0gdmFsdWUuZ2V0VVRDTWludXRlcygpO1xyXG4gICAgICAgICAgICAgICAgICBzZWNvbmRzID0gdmFsdWUuZ2V0VVRDU2Vjb25kcygpO1xyXG4gICAgICAgICAgICAgICAgICBtaWxsaXNlY29uZHMgPSB2YWx1ZS5nZXRVVENNaWxsaXNlY29uZHMoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIFNlcmlhbGl6ZSBleHRlbmRlZCB5ZWFycyBjb3JyZWN0bHkuXHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICh5ZWFyIDw9IDAgfHwgeWVhciA+PSAxZTQgPyAoeWVhciA8IDAgPyBcIi1cIiA6IFwiK1wiKSArIHRvUGFkZGVkU3RyaW5nKDYsIHllYXIgPCAwID8gLXllYXIgOiB5ZWFyKSA6IHRvUGFkZGVkU3RyaW5nKDQsIHllYXIpKSArXHJcbiAgICAgICAgICAgICAgICAgIFwiLVwiICsgdG9QYWRkZWRTdHJpbmcoMiwgbW9udGggKyAxKSArIFwiLVwiICsgdG9QYWRkZWRTdHJpbmcoMiwgZGF0ZSkgK1xyXG4gICAgICAgICAgICAgICAgICAvLyBNb250aHMsIGRhdGVzLCBob3VycywgbWludXRlcywgYW5kIHNlY29uZHMgc2hvdWxkIGhhdmUgdHdvXHJcbiAgICAgICAgICAgICAgICAgIC8vIGRpZ2l0czsgbWlsbGlzZWNvbmRzIHNob3VsZCBoYXZlIHRocmVlLlxyXG4gICAgICAgICAgICAgICAgICBcIlRcIiArIHRvUGFkZGVkU3RyaW5nKDIsIGhvdXJzKSArIFwiOlwiICsgdG9QYWRkZWRTdHJpbmcoMiwgbWludXRlcykgKyBcIjpcIiArIHRvUGFkZGVkU3RyaW5nKDIsIHNlY29uZHMpICtcclxuICAgICAgICAgICAgICAgICAgLy8gTWlsbGlzZWNvbmRzIGFyZSBvcHRpb25hbCBpbiBFUyA1LjAsIGJ1dCByZXF1aXJlZCBpbiA1LjEuXHJcbiAgICAgICAgICAgICAgICAgIFwiLlwiICsgdG9QYWRkZWRTdHJpbmcoMywgbWlsbGlzZWNvbmRzKSArIFwiWlwiO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZS50b0pTT04gPT0gXCJmdW5jdGlvblwiICYmICgoY2xhc3NOYW1lICE9IG51bWJlckNsYXNzICYmIGNsYXNzTmFtZSAhPSBzdHJpbmdDbGFzcyAmJiBjbGFzc05hbWUgIT0gYXJyYXlDbGFzcykgfHwgaXNQcm9wZXJ0eS5jYWxsKHZhbHVlLCBcInRvSlNPTlwiKSkpIHtcclxuICAgICAgICAgICAgICAvLyBQcm90b3R5cGUgPD0gMS42LjEgYWRkcyBub24tc3RhbmRhcmQgYHRvSlNPTmAgbWV0aG9kcyB0byB0aGVcclxuICAgICAgICAgICAgICAvLyBgTnVtYmVyYCwgYFN0cmluZ2AsIGBEYXRlYCwgYW5kIGBBcnJheWAgcHJvdG90eXBlcy4gSlNPTiAzXHJcbiAgICAgICAgICAgICAgLy8gaWdub3JlcyBhbGwgYHRvSlNPTmAgbWV0aG9kcyBvbiB0aGVzZSBvYmplY3RzIHVubGVzcyB0aGV5IGFyZVxyXG4gICAgICAgICAgICAgIC8vIGRlZmluZWQgZGlyZWN0bHkgb24gYW4gaW5zdGFuY2UuXHJcbiAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0pTT04ocHJvcGVydHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgLy8gSWYgYSByZXBsYWNlbWVudCBmdW5jdGlvbiB3YXMgcHJvdmlkZWQsIGNhbGwgaXQgdG8gb2J0YWluIHRoZSB2YWx1ZVxyXG4gICAgICAgICAgICAvLyBmb3Igc2VyaWFsaXphdGlvbi5cclxuICAgICAgICAgICAgdmFsdWUgPSBjYWxsYmFjay5jYWxsKG9iamVjdCwgcHJvcGVydHksIHZhbHVlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gXCJudWxsXCI7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHZhbHVlKTtcclxuICAgICAgICAgIGlmIChjbGFzc05hbWUgPT0gYm9vbGVhbkNsYXNzKSB7XHJcbiAgICAgICAgICAgIC8vIEJvb2xlYW5zIGFyZSByZXByZXNlbnRlZCBsaXRlcmFsbHkuXHJcbiAgICAgICAgICAgIHJldHVybiBcIlwiICsgdmFsdWU7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBudW1iZXJDbGFzcykge1xyXG4gICAgICAgICAgICAvLyBKU09OIG51bWJlcnMgbXVzdCBiZSBmaW5pdGUuIGBJbmZpbml0eWAgYW5kIGBOYU5gIGFyZSBzZXJpYWxpemVkIGFzXHJcbiAgICAgICAgICAgIC8vIGBcIm51bGxcImAuXHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSA+IC0xIC8gMCAmJiB2YWx1ZSA8IDEgLyAwID8gXCJcIiArIHZhbHVlIDogXCJudWxsXCI7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBzdHJpbmdDbGFzcykge1xyXG4gICAgICAgICAgICAvLyBTdHJpbmdzIGFyZSBkb3VibGUtcXVvdGVkIGFuZCBlc2NhcGVkLlxyXG4gICAgICAgICAgICByZXR1cm4gcXVvdGUoXCJcIiArIHZhbHVlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSBvYmplY3RzIGFuZCBhcnJheXMuXHJcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGN5Y2xpYyBzdHJ1Y3R1cmVzLiBUaGlzIGlzIGEgbGluZWFyIHNlYXJjaDsgcGVyZm9ybWFuY2VcclxuICAgICAgICAgICAgLy8gaXMgaW52ZXJzZWx5IHByb3BvcnRpb25hbCB0byB0aGUgbnVtYmVyIG9mIHVuaXF1ZSBuZXN0ZWQgb2JqZWN0cy5cclxuICAgICAgICAgICAgZm9yIChsZW5ndGggPSBzdGFjay5sZW5ndGg7IGxlbmd0aC0tOykge1xyXG4gICAgICAgICAgICAgIGlmIChzdGFja1tsZW5ndGhdID09PSB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gQ3ljbGljIHN0cnVjdHVyZXMgY2Fubm90IGJlIHNlcmlhbGl6ZWQgYnkgYEpTT04uc3RyaW5naWZ5YC5cclxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcigpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBBZGQgdGhlIG9iamVjdCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXHJcbiAgICAgICAgICAgIHN0YWNrLnB1c2godmFsdWUpO1xyXG4gICAgICAgICAgICByZXN1bHRzID0gW107XHJcbiAgICAgICAgICAgIC8vIFNhdmUgdGhlIGN1cnJlbnQgaW5kZW50YXRpb24gbGV2ZWwgYW5kIGluZGVudCBvbmUgYWRkaXRpb25hbCBsZXZlbC5cclxuICAgICAgICAgICAgcHJlZml4ID0gaW5kZW50YXRpb247XHJcbiAgICAgICAgICAgIGluZGVudGF0aW9uICs9IHdoaXRlc3BhY2U7XHJcbiAgICAgICAgICAgIGlmIChjbGFzc05hbWUgPT0gYXJyYXlDbGFzcykge1xyXG4gICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSBhcnJheSBlbGVtZW50cy5cclxuICAgICAgICAgICAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gdmFsdWUubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IHNlcmlhbGl6ZShpbmRleCwgdmFsdWUsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBpbmRlbnRhdGlvbiwgc3RhY2spO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGVsZW1lbnQgPT09IHVuZGVmID8gXCJudWxsXCIgOiBlbGVtZW50KTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0cy5sZW5ndGggPyAod2hpdGVzcGFjZSA/IFwiW1xcblwiICsgaW5kZW50YXRpb24gKyByZXN1bHRzLmpvaW4oXCIsXFxuXCIgKyBpbmRlbnRhdGlvbikgKyBcIlxcblwiICsgcHJlZml4ICsgXCJdXCIgOiAoXCJbXCIgKyByZXN1bHRzLmpvaW4oXCIsXCIpICsgXCJdXCIpKSA6IFwiW11cIjtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgb2JqZWN0IG1lbWJlcnMuIE1lbWJlcnMgYXJlIHNlbGVjdGVkIGZyb21cclxuICAgICAgICAgICAgICAvLyBlaXRoZXIgYSB1c2VyLXNwZWNpZmllZCBsaXN0IG9mIHByb3BlcnR5IG5hbWVzLCBvciB0aGUgb2JqZWN0XHJcbiAgICAgICAgICAgICAgLy8gaXRzZWxmLlxyXG4gICAgICAgICAgICAgIGZvckVhY2gocHJvcGVydGllcyB8fCB2YWx1ZSwgZnVuY3Rpb24gKHByb3BlcnR5KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHNlcmlhbGl6ZShwcm9wZXJ0eSwgdmFsdWUsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBpbmRlbnRhdGlvbiwgc3RhY2spO1xyXG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQgIT09IHVuZGVmKSB7XHJcbiAgICAgICAgICAgICAgICAgIC8vIEFjY29yZGluZyB0byBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zOiBcIklmIGBnYXBgIHt3aGl0ZXNwYWNlfVxyXG4gICAgICAgICAgICAgICAgICAvLyBpcyBub3QgdGhlIGVtcHR5IHN0cmluZywgbGV0IGBtZW1iZXJgIHtxdW90ZShwcm9wZXJ0eSkgKyBcIjpcIn1cclxuICAgICAgICAgICAgICAgICAgLy8gYmUgdGhlIGNvbmNhdGVuYXRpb24gb2YgYG1lbWJlcmAgYW5kIHRoZSBgc3BhY2VgIGNoYXJhY3Rlci5cIlxyXG4gICAgICAgICAgICAgICAgICAvLyBUaGUgXCJgc3BhY2VgIGNoYXJhY3RlclwiIHJlZmVycyB0byB0aGUgbGl0ZXJhbCBzcGFjZVxyXG4gICAgICAgICAgICAgICAgICAvLyBjaGFyYWN0ZXIsIG5vdCB0aGUgYHNwYWNlYCB7d2lkdGh9IGFyZ3VtZW50IHByb3ZpZGVkIHRvXHJcbiAgICAgICAgICAgICAgICAgIC8vIGBKU09OLnN0cmluZ2lmeWAuXHJcbiAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChxdW90ZShwcm9wZXJ0eSkgKyBcIjpcIiArICh3aGl0ZXNwYWNlID8gXCIgXCIgOiBcIlwiKSArIGVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdHMubGVuZ3RoID8gKHdoaXRlc3BhY2UgPyBcIntcXG5cIiArIGluZGVudGF0aW9uICsgcmVzdWx0cy5qb2luKFwiLFxcblwiICsgaW5kZW50YXRpb24pICsgXCJcXG5cIiArIHByZWZpeCArIFwifVwiIDogKFwie1wiICsgcmVzdWx0cy5qb2luKFwiLFwiKSArIFwifVwiKSkgOiBcInt9XCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBvYmplY3QgZnJvbSB0aGUgdHJhdmVyc2VkIG9iamVjdCBzdGFjay5cclxuICAgICAgICAgICAgc3RhY2sucG9wKCk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gUHVibGljOiBgSlNPTi5zdHJpbmdpZnlgLiBTZWUgRVMgNS4xIHNlY3Rpb24gMTUuMTIuMy5cclxuICAgICAgICBleHBvcnRzLnN0cmluZ2lmeSA9IGZ1bmN0aW9uIChzb3VyY2UsIGZpbHRlciwgd2lkdGgpIHtcclxuICAgICAgICAgIHZhciB3aGl0ZXNwYWNlLCBjYWxsYmFjaywgcHJvcGVydGllcywgY2xhc3NOYW1lO1xyXG4gICAgICAgICAgaWYgKG9iamVjdFR5cGVzW3R5cGVvZiBmaWx0ZXJdICYmIGZpbHRlcikge1xyXG4gICAgICAgICAgICBpZiAoKGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwoZmlsdGVyKSkgPT0gZnVuY3Rpb25DbGFzcykge1xyXG4gICAgICAgICAgICAgIGNhbGxiYWNrID0gZmlsdGVyO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBhcnJheUNsYXNzKSB7XHJcbiAgICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgcHJvcGVydHkgbmFtZXMgYXJyYXkgaW50byBhIG1ha2VzaGlmdCBzZXQuXHJcbiAgICAgICAgICAgICAgcHJvcGVydGllcyA9IHt9O1xyXG4gICAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMCwgbGVuZ3RoID0gZmlsdGVyLmxlbmd0aCwgdmFsdWU7IGluZGV4IDwgbGVuZ3RoOyB2YWx1ZSA9IGZpbHRlcltpbmRleCsrXSwgKChjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHZhbHVlKSksIGNsYXNzTmFtZSA9PSBzdHJpbmdDbGFzcyB8fCBjbGFzc05hbWUgPT0gbnVtYmVyQ2xhc3MpICYmIChwcm9wZXJ0aWVzW3ZhbHVlXSA9IDEpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKHdpZHRoKSB7XHJcbiAgICAgICAgICAgIGlmICgoY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh3aWR0aCkpID09IG51bWJlckNsYXNzKSB7XHJcbiAgICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgYHdpZHRoYCB0byBhbiBpbnRlZ2VyIGFuZCBjcmVhdGUgYSBzdHJpbmcgY29udGFpbmluZ1xyXG4gICAgICAgICAgICAgIC8vIGB3aWR0aGAgbnVtYmVyIG9mIHNwYWNlIGNoYXJhY3RlcnMuXHJcbiAgICAgICAgICAgICAgaWYgKCh3aWR0aCAtPSB3aWR0aCAlIDEpID4gMCkge1xyXG4gICAgICAgICAgICAgICAgZm9yICh3aGl0ZXNwYWNlID0gXCJcIiwgd2lkdGggPiAxMCAmJiAod2lkdGggPSAxMCk7IHdoaXRlc3BhY2UubGVuZ3RoIDwgd2lkdGg7IHdoaXRlc3BhY2UgKz0gXCIgXCIpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MpIHtcclxuICAgICAgICAgICAgICB3aGl0ZXNwYWNlID0gd2lkdGgubGVuZ3RoIDw9IDEwID8gd2lkdGggOiB3aWR0aC5zbGljZSgwLCAxMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIC8vIE9wZXJhIDw9IDcuNTR1MiBkaXNjYXJkcyB0aGUgdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCBlbXB0eSBzdHJpbmcga2V5c1xyXG4gICAgICAgICAgLy8gKGBcIlwiYCkgb25seSBpZiB0aGV5IGFyZSB1c2VkIGRpcmVjdGx5IHdpdGhpbiBhbiBvYmplY3QgbWVtYmVyIGxpc3RcclxuICAgICAgICAgIC8vIChlLmcuLCBgIShcIlwiIGluIHsgXCJcIjogMX0pYCkuXHJcbiAgICAgICAgICByZXR1cm4gc2VyaWFsaXplKFwiXCIsICh2YWx1ZSA9IHt9LCB2YWx1ZVtcIlwiXSA9IHNvdXJjZSwgdmFsdWUpLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgXCJcIiwgW10pO1xyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFB1YmxpYzogUGFyc2VzIGEgSlNPTiBzb3VyY2Ugc3RyaW5nLlxyXG4gICAgICBpZiAoIWhhcyhcImpzb24tcGFyc2VcIikpIHtcclxuICAgICAgICB2YXIgZnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcclxuXHJcbiAgICAgICAgLy8gSW50ZXJuYWw6IEEgbWFwIG9mIGVzY2FwZWQgY29udHJvbCBjaGFyYWN0ZXJzIGFuZCB0aGVpciB1bmVzY2FwZWRcclxuICAgICAgICAvLyBlcXVpdmFsZW50cy5cclxuICAgICAgICB2YXIgVW5lc2NhcGVzID0ge1xyXG4gICAgICAgICAgOTI6IFwiXFxcXFwiLFxyXG4gICAgICAgICAgMzQ6ICdcIicsXHJcbiAgICAgICAgICA0NzogXCIvXCIsXHJcbiAgICAgICAgICA5ODogXCJcXGJcIixcclxuICAgICAgICAgIDExNjogXCJcXHRcIixcclxuICAgICAgICAgIDExMDogXCJcXG5cIixcclxuICAgICAgICAgIDEwMjogXCJcXGZcIixcclxuICAgICAgICAgIDExNDogXCJcXHJcIlxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIEludGVybmFsOiBTdG9yZXMgdGhlIHBhcnNlciBzdGF0ZS5cclxuICAgICAgICB2YXIgSW5kZXgsIFNvdXJjZTtcclxuXHJcbiAgICAgICAgLy8gSW50ZXJuYWw6IFJlc2V0cyB0aGUgcGFyc2VyIHN0YXRlIGFuZCB0aHJvd3MgYSBgU3ludGF4RXJyb3JgLlxyXG4gICAgICAgIHZhciBhYm9ydCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIEluZGV4ID0gU291cmNlID0gbnVsbDtcclxuICAgICAgICAgIHRocm93IFN5bnRheEVycm9yKCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gSW50ZXJuYWw6IFJldHVybnMgdGhlIG5leHQgdG9rZW4sIG9yIGBcIiRcImAgaWYgdGhlIHBhcnNlciBoYXMgcmVhY2hlZFxyXG4gICAgICAgIC8vIHRoZSBlbmQgb2YgdGhlIHNvdXJjZSBzdHJpbmcuIEEgdG9rZW4gbWF5IGJlIGEgc3RyaW5nLCBudW1iZXIsIGBudWxsYFxyXG4gICAgICAgIC8vIGxpdGVyYWwsIG9yIEJvb2xlYW4gbGl0ZXJhbC5cclxuICAgICAgICB2YXIgbGV4ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgdmFyIHNvdXJjZSA9IFNvdXJjZSwgbGVuZ3RoID0gc291cmNlLmxlbmd0aCwgdmFsdWUsIGJlZ2luLCBwb3NpdGlvbiwgaXNTaWduZWQsIGNoYXJDb2RlO1xyXG4gICAgICAgICAgd2hpbGUgKEluZGV4IDwgbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGNoYXJDb2RlKSB7XHJcbiAgICAgICAgICAgICAgY2FzZSA5OiBjYXNlIDEwOiBjYXNlIDEzOiBjYXNlIDMyOlxyXG4gICAgICAgICAgICAgICAgLy8gU2tpcCB3aGl0ZXNwYWNlIHRva2VucywgaW5jbHVkaW5nIHRhYnMsIGNhcnJpYWdlIHJldHVybnMsIGxpbmVcclxuICAgICAgICAgICAgICAgIC8vIGZlZWRzLCBhbmQgc3BhY2UgY2hhcmFjdGVycy5cclxuICAgICAgICAgICAgICAgIEluZGV4Kys7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICBjYXNlIDEyMzogY2FzZSAxMjU6IGNhc2UgOTE6IGNhc2UgOTM6IGNhc2UgNTg6IGNhc2UgNDQ6XHJcbiAgICAgICAgICAgICAgICAvLyBQYXJzZSBhIHB1bmN0dWF0b3IgdG9rZW4gKGB7YCwgYH1gLCBgW2AsIGBdYCwgYDpgLCBvciBgLGApIGF0XHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgY3VycmVudCBwb3NpdGlvbi5cclxuICAgICAgICAgICAgICAgIHZhbHVlID0gY2hhckluZGV4QnVnZ3kgPyBzb3VyY2UuY2hhckF0KEluZGV4KSA6IHNvdXJjZVtJbmRleF07XHJcbiAgICAgICAgICAgICAgICBJbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgICAgICAgIGNhc2UgMzQ6XHJcbiAgICAgICAgICAgICAgICAvLyBgXCJgIGRlbGltaXRzIGEgSlNPTiBzdHJpbmc7IGFkdmFuY2UgdG8gdGhlIG5leHQgY2hhcmFjdGVyIGFuZFxyXG4gICAgICAgICAgICAgICAgLy8gYmVnaW4gcGFyc2luZyB0aGUgc3RyaW5nLiBTdHJpbmcgdG9rZW5zIGFyZSBwcmVmaXhlZCB3aXRoIHRoZVxyXG4gICAgICAgICAgICAgICAgLy8gc2VudGluZWwgYEBgIGNoYXJhY3RlciB0byBkaXN0aW5ndWlzaCB0aGVtIGZyb20gcHVuY3R1YXRvcnMgYW5kXHJcbiAgICAgICAgICAgICAgICAvLyBlbmQtb2Ytc3RyaW5nIHRva2Vucy5cclxuICAgICAgICAgICAgICAgIGZvciAodmFsdWUgPSBcIkBcIiwgSW5kZXgrKzsgSW5kZXggPCBsZW5ndGg7KSB7XHJcbiAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPCAzMikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFVuZXNjYXBlZCBBU0NJSSBjb250cm9sIGNoYXJhY3RlcnMgKHRob3NlIHdpdGggYSBjb2RlIHVuaXRcclxuICAgICAgICAgICAgICAgICAgICAvLyBsZXNzIHRoYW4gdGhlIHNwYWNlIGNoYXJhY3RlcikgYXJlIG5vdCBwZXJtaXR0ZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcclxuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGFyQ29kZSA9PSA5Mikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEEgcmV2ZXJzZSBzb2xpZHVzIChgXFxgKSBtYXJrcyB0aGUgYmVnaW5uaW5nIG9mIGFuIGVzY2FwZWRcclxuICAgICAgICAgICAgICAgICAgICAvLyBjb250cm9sIGNoYXJhY3RlciAoaW5jbHVkaW5nIGBcImAsIGBcXGAsIGFuZCBgL2ApIG9yIFVuaWNvZGVcclxuICAgICAgICAgICAgICAgICAgICAvLyBlc2NhcGUgc2VxdWVuY2UuXHJcbiAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoYXJDb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDkyOiBjYXNlIDM0OiBjYXNlIDQ3OiBjYXNlIDk4OiBjYXNlIDExNjogY2FzZSAxMTA6IGNhc2UgMTAyOiBjYXNlIDExNDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV2aXZlIGVzY2FwZWQgY29udHJvbCBjaGFyYWN0ZXJzLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBVbmVzY2FwZXNbY2hhckNvZGVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBJbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTE3OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBgXFx1YCBtYXJrcyB0aGUgYmVnaW5uaW5nIG9mIGEgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgdG8gdGhlIGZpcnN0IGNoYXJhY3RlciBhbmQgdmFsaWRhdGUgdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvdXItZGlnaXQgY29kZSBwb2ludC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYmVnaW4gPSArK0luZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHBvc2l0aW9uID0gSW5kZXggKyA0OyBJbmRleCA8IHBvc2l0aW9uOyBJbmRleCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQSB2YWxpZCBzZXF1ZW5jZSBjb21wcmlzZXMgZm91ciBoZXhkaWdpdHMgKGNhc2UtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5zZW5zaXRpdmUpIHRoYXQgZm9ybSBhIHNpbmdsZSBoZXhhZGVjaW1hbCB2YWx1ZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1NyB8fCBjaGFyQ29kZSA+PSA5NyAmJiBjaGFyQ29kZSA8PSAxMDIgfHwgY2hhckNvZGUgPj0gNjUgJiYgY2hhckNvZGUgPD0gNzApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV2aXZlIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gZnJvbUNoYXJDb2RlKFwiMHhcIiArIHNvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIGVzY2FwZSBzZXF1ZW5jZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDM0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAvLyBBbiB1bmVzY2FwZWQgZG91YmxlLXF1b3RlIGNoYXJhY3RlciBtYXJrcyB0aGUgZW5kIG9mIHRoZVxyXG4gICAgICAgICAgICAgICAgICAgICAgLy8gc3RyaW5nLlxyXG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJlZ2luID0gSW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gT3B0aW1pemUgZm9yIHRoZSBjb21tb24gY2FzZSB3aGVyZSBhIHN0cmluZyBpcyB2YWxpZC5cclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY2hhckNvZGUgPj0gMzIgJiYgY2hhckNvZGUgIT0gOTIgJiYgY2hhckNvZGUgIT0gMzQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEFwcGVuZCB0aGUgc3RyaW5nIGFzLWlzLlxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IHNvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpID09IDM0KSB7XHJcbiAgICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgdG8gdGhlIG5leHQgY2hhcmFjdGVyIGFuZCByZXR1cm4gdGhlIHJldml2ZWQgc3RyaW5nLlxyXG4gICAgICAgICAgICAgICAgICBJbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBVbnRlcm1pbmF0ZWQgc3RyaW5nLlxyXG4gICAgICAgICAgICAgICAgYWJvcnQoKTtcclxuICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgbnVtYmVycyBhbmQgbGl0ZXJhbHMuXHJcbiAgICAgICAgICAgICAgICBiZWdpbiA9IEluZGV4O1xyXG4gICAgICAgICAgICAgICAgLy8gQWR2YW5jZSBwYXN0IHRoZSBuZWdhdGl2ZSBzaWduLCBpZiBvbmUgaXMgc3BlY2lmaWVkLlxyXG4gICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDQ1KSB7XHJcbiAgICAgICAgICAgICAgICAgIGlzU2lnbmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIFBhcnNlIGFuIGludGVnZXIgb3IgZmxvYXRpbmctcG9pbnQgdmFsdWUuXHJcbiAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpIHtcclxuICAgICAgICAgICAgICAgICAgLy8gTGVhZGluZyB6ZXJvZXMgYXJlIGludGVycHJldGVkIGFzIG9jdGFsIGxpdGVyYWxzLlxyXG4gICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gNDggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4ICsgMSkpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1NykpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBJbGxlZ2FsIG9jdGFsIGxpdGVyYWwuXHJcbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICBpc1NpZ25lZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgaW50ZWdlciBjb21wb25lbnQuXHJcbiAgICAgICAgICAgICAgICAgIGZvciAoOyBJbmRleCA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBJbmRleCsrKTtcclxuICAgICAgICAgICAgICAgICAgLy8gRmxvYXRzIGNhbm5vdCBjb250YWluIGEgbGVhZGluZyBkZWNpbWFsIHBvaW50OyBob3dldmVyLCB0aGlzXHJcbiAgICAgICAgICAgICAgICAgIC8vIGNhc2UgaXMgYWxyZWFkeSBhY2NvdW50ZWQgZm9yIGJ5IHRoZSBwYXJzZXIuXHJcbiAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChJbmRleCkgPT0gNDYpIHtcclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9ICsrSW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGRlY2ltYWwgY29tcG9uZW50LlxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBwb3NpdGlvbiA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQocG9zaXRpb24pKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBwb3NpdGlvbisrKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPT0gSW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWwgdHJhaWxpbmcgZGVjaW1hbC5cclxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIEluZGV4ID0gcG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgZXhwb25lbnRzLiBUaGUgYGVgIGRlbm90aW5nIHRoZSBleHBvbmVudCBpc1xyXG4gICAgICAgICAgICAgICAgICAvLyBjYXNlLWluc2Vuc2l0aXZlLlxyXG4gICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDEwMSB8fCBjaGFyQ29kZSA9PSA2OSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU2tpcCBwYXN0IHRoZSBzaWduIGZvbGxvd2luZyB0aGUgZXhwb25lbnQsIGlmIG9uZSBpc1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNwZWNpZmllZC5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gNDMgfHwgY2hhckNvZGUgPT0gNDUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIEluZGV4Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBleHBvbmVudGlhbCBjb21wb25lbnQuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChwb3NpdGlvbiA9IEluZGV4OyBwb3NpdGlvbiA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQocG9zaXRpb24pKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBwb3NpdGlvbisrKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPT0gSW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWwgZW1wdHkgZXhwb25lbnQuXHJcbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBJbmRleCA9IHBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIC8vIENvZXJjZSB0aGUgcGFyc2VkIHZhbHVlIHRvIGEgSmF2YVNjcmlwdCBudW1iZXIuXHJcbiAgICAgICAgICAgICAgICAgIHJldHVybiArc291cmNlLnNsaWNlKGJlZ2luLCBJbmRleCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBBIG5lZ2F0aXZlIHNpZ24gbWF5IG9ubHkgcHJlY2VkZSBudW1iZXJzLlxyXG4gICAgICAgICAgICAgICAgaWYgKGlzU2lnbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgIGFib3J0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBgdHJ1ZWAsIGBmYWxzZWAsIGFuZCBgbnVsbGAgbGl0ZXJhbHMuXHJcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLnNsaWNlKEluZGV4LCBJbmRleCArIDQpID09IFwidHJ1ZVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgIEluZGV4ICs9IDQ7XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2Uuc2xpY2UoSW5kZXgsIEluZGV4ICsgNSkgPT0gXCJmYWxzZVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgIEluZGV4ICs9IDU7XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlLnNsaWNlKEluZGV4LCBJbmRleCArIDQpID09IFwibnVsbFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgIEluZGV4ICs9IDQ7XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gVW5yZWNvZ25pemVkIHRva2VuLlxyXG4gICAgICAgICAgICAgICAgYWJvcnQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgLy8gUmV0dXJuIHRoZSBzZW50aW5lbCBgJGAgY2hhcmFjdGVyIGlmIHRoZSBwYXJzZXIgaGFzIHJlYWNoZWQgdGhlIGVuZFxyXG4gICAgICAgICAgLy8gb2YgdGhlIHNvdXJjZSBzdHJpbmcuXHJcbiAgICAgICAgICByZXR1cm4gXCIkXCI7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gSW50ZXJuYWw6IFBhcnNlcyBhIEpTT04gYHZhbHVlYCB0b2tlbi5cclxuICAgICAgICB2YXIgZ2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICB2YXIgcmVzdWx0cywgaGFzTWVtYmVycztcclxuICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIiRcIikge1xyXG4gICAgICAgICAgICAvLyBVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dC5cclxuICAgICAgICAgICAgYWJvcnQoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICBpZiAoKGNoYXJJbmRleEJ1Z2d5ID8gdmFsdWUuY2hhckF0KDApIDogdmFsdWVbMF0pID09IFwiQFwiKSB7XHJcbiAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBzZW50aW5lbCBgQGAgY2hhcmFjdGVyLlxyXG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5zbGljZSgxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBQYXJzZSBvYmplY3QgYW5kIGFycmF5IGxpdGVyYWxzLlxyXG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJbXCIpIHtcclxuICAgICAgICAgICAgICAvLyBQYXJzZXMgYSBKU09OIGFycmF5LCByZXR1cm5pbmcgYSBuZXcgSmF2YVNjcmlwdCBhcnJheS5cclxuICAgICAgICAgICAgICByZXN1bHRzID0gW107XHJcbiAgICAgICAgICAgICAgZm9yICg7OyBoYXNNZW1iZXJzIHx8IChoYXNNZW1iZXJzID0gdHJ1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XHJcbiAgICAgICAgICAgICAgICAvLyBBIGNsb3Npbmcgc3F1YXJlIGJyYWNrZXQgbWFya3MgdGhlIGVuZCBvZiB0aGUgYXJyYXkgbGl0ZXJhbC5cclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIl1cIikge1xyXG4gICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBhcnJheSBsaXRlcmFsIGNvbnRhaW5zIGVsZW1lbnRzLCB0aGUgY3VycmVudCB0b2tlblxyXG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGEgY29tbWEgc2VwYXJhdGluZyB0aGUgcHJldmlvdXMgZWxlbWVudCBmcm9tIHRoZVxyXG4gICAgICAgICAgICAgICAgLy8gbmV4dC5cclxuICAgICAgICAgICAgICAgIGlmIChoYXNNZW1iZXJzKSB7XHJcbiAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiXVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAvLyBVbmV4cGVjdGVkIHRyYWlsaW5nIGAsYCBpbiBhcnJheSBsaXRlcmFsLlxyXG4gICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQSBgLGAgbXVzdCBzZXBhcmF0ZSBlYWNoIGFycmF5IGVsZW1lbnQuXHJcbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gRWxpc2lvbnMgYW5kIGxlYWRpbmcgY29tbWFzIGFyZSBub3QgcGVybWl0dGVkLlxyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgIGFib3J0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZ2V0KHZhbHVlKSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09IFwie1wiKSB7XHJcbiAgICAgICAgICAgICAgLy8gUGFyc2VzIGEgSlNPTiBvYmplY3QsIHJldHVybmluZyBhIG5ldyBKYXZhU2NyaXB0IG9iamVjdC5cclxuICAgICAgICAgICAgICByZXN1bHRzID0ge307XHJcbiAgICAgICAgICAgICAgZm9yICg7OyBoYXNNZW1iZXJzIHx8IChoYXNNZW1iZXJzID0gdHJ1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XHJcbiAgICAgICAgICAgICAgICAvLyBBIGNsb3NpbmcgY3VybHkgYnJhY2UgbWFya3MgdGhlIGVuZCBvZiB0aGUgb2JqZWN0IGxpdGVyYWwuXHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJ9XCIpIHtcclxuICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgb2JqZWN0IGxpdGVyYWwgY29udGFpbnMgbWVtYmVycywgdGhlIGN1cnJlbnQgdG9rZW5cclxuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBiZSBhIGNvbW1hIHNlcGFyYXRvci5cclxuICAgICAgICAgICAgICAgIGlmIChoYXNNZW1iZXJzKSB7XHJcbiAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwifVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAvLyBVbmV4cGVjdGVkIHRyYWlsaW5nIGAsYCBpbiBvYmplY3QgbGl0ZXJhbC5cclxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEEgYCxgIG11c3Qgc2VwYXJhdGUgZWFjaCBvYmplY3QgbWVtYmVyLlxyXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIExlYWRpbmcgY29tbWFzIGFyZSBub3QgcGVybWl0dGVkLCBvYmplY3QgcHJvcGVydHkgbmFtZXMgbXVzdCBiZVxyXG4gICAgICAgICAgICAgICAgLy8gZG91YmxlLXF1b3RlZCBzdHJpbmdzLCBhbmQgYSBgOmAgbXVzdCBzZXBhcmF0ZSBlYWNoIHByb3BlcnR5XHJcbiAgICAgICAgICAgICAgICAvLyBuYW1lIGFuZCB2YWx1ZS5cclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIiB8fCB0eXBlb2YgdmFsdWUgIT0gXCJzdHJpbmdcIiB8fCAoY2hhckluZGV4QnVnZ3kgPyB2YWx1ZS5jaGFyQXQoMCkgOiB2YWx1ZVswXSkgIT0gXCJAXCIgfHwgbGV4KCkgIT0gXCI6XCIpIHtcclxuICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlc3VsdHNbdmFsdWUuc2xpY2UoMSldID0gZ2V0KGxleCgpKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gVW5leHBlY3RlZCB0b2tlbiBlbmNvdW50ZXJlZC5cclxuICAgICAgICAgICAgYWJvcnQoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBJbnRlcm5hbDogVXBkYXRlcyBhIHRyYXZlcnNlZCBvYmplY3QgbWVtYmVyLlxyXG4gICAgICAgIHZhciB1cGRhdGUgPSBmdW5jdGlvbiAoc291cmNlLCBwcm9wZXJ0eSwgY2FsbGJhY2spIHtcclxuICAgICAgICAgIHZhciBlbGVtZW50ID0gd2Fsayhzb3VyY2UsIHByb3BlcnR5LCBjYWxsYmFjayk7XHJcbiAgICAgICAgICBpZiAoZWxlbWVudCA9PT0gdW5kZWYpIHtcclxuICAgICAgICAgICAgZGVsZXRlIHNvdXJjZVtwcm9wZXJ0eV07XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzb3VyY2VbcHJvcGVydHldID0gZWxlbWVudDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBJbnRlcm5hbDogUmVjdXJzaXZlbHkgdHJhdmVyc2VzIGEgcGFyc2VkIEpTT04gb2JqZWN0LCBpbnZva2luZyB0aGVcclxuICAgICAgICAvLyBgY2FsbGJhY2tgIGZ1bmN0aW9uIGZvciBlYWNoIHZhbHVlLiBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIHRoZVxyXG4gICAgICAgIC8vIGBXYWxrKGhvbGRlciwgbmFtZSlgIG9wZXJhdGlvbiBkZWZpbmVkIGluIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjIuXHJcbiAgICAgICAgdmFyIHdhbGsgPSBmdW5jdGlvbiAoc291cmNlLCBwcm9wZXJ0eSwgY2FsbGJhY2spIHtcclxuICAgICAgICAgIHZhciB2YWx1ZSA9IHNvdXJjZVtwcm9wZXJ0eV0sIGxlbmd0aDtcclxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIiAmJiB2YWx1ZSkge1xyXG4gICAgICAgICAgICAvLyBgZm9yRWFjaGAgY2FuJ3QgYmUgdXNlZCB0byB0cmF2ZXJzZSBhbiBhcnJheSBpbiBPcGVyYSA8PSA4LjU0XHJcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgaXRzIGBPYmplY3QjaGFzT3duUHJvcGVydHlgIGltcGxlbWVudGF0aW9uIHJldHVybnMgYGZhbHNlYFxyXG4gICAgICAgICAgICAvLyBmb3IgYXJyYXkgaW5kaWNlcyAoZS5nLiwgYCFbMSwgMiwgM10uaGFzT3duUHJvcGVydHkoXCIwXCIpYCkuXHJcbiAgICAgICAgICAgIGlmIChnZXRDbGFzcy5jYWxsKHZhbHVlKSA9PSBhcnJheUNsYXNzKSB7XHJcbiAgICAgICAgICAgICAgZm9yIChsZW5ndGggPSB2YWx1ZS5sZW5ndGg7IGxlbmd0aC0tOykge1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlKHZhbHVlLCBsZW5ndGgsIGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgZm9yRWFjaCh2YWx1ZSwgZnVuY3Rpb24gKHByb3BlcnR5KSB7XHJcbiAgICAgICAgICAgICAgICB1cGRhdGUodmFsdWUsIHByb3BlcnR5LCBjYWxsYmFjayk7XHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHNvdXJjZSwgcHJvcGVydHksIHZhbHVlKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBQdWJsaWM6IGBKU09OLnBhcnNlYC4gU2VlIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjIuXHJcbiAgICAgICAgZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uIChzb3VyY2UsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICB2YXIgcmVzdWx0LCB2YWx1ZTtcclxuICAgICAgICAgIEluZGV4ID0gMDtcclxuICAgICAgICAgIFNvdXJjZSA9IFwiXCIgKyBzb3VyY2U7XHJcbiAgICAgICAgICByZXN1bHQgPSBnZXQobGV4KCkpO1xyXG4gICAgICAgICAgLy8gSWYgYSBKU09OIHN0cmluZyBjb250YWlucyBtdWx0aXBsZSB0b2tlbnMsIGl0IGlzIGludmFsaWQuXHJcbiAgICAgICAgICBpZiAobGV4KCkgIT0gXCIkXCIpIHtcclxuICAgICAgICAgICAgYWJvcnQoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIC8vIFJlc2V0IHRoZSBwYXJzZXIgc3RhdGUuXHJcbiAgICAgICAgICBJbmRleCA9IFNvdXJjZSA9IG51bGw7XHJcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2sgJiYgZ2V0Q2xhc3MuY2FsbChjYWxsYmFjaykgPT0gZnVuY3Rpb25DbGFzcyA/IHdhbGsoKHZhbHVlID0ge30sIHZhbHVlW1wiXCJdID0gcmVzdWx0LCB2YWx1ZSksIFwiXCIsIGNhbGxiYWNrKSA6IHJlc3VsdDtcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZXhwb3J0c1tcInJ1bkluQ29udGV4dFwiXSA9IHJ1bkluQ29udGV4dDtcclxuICAgIHJldHVybiBleHBvcnRzO1xyXG4gIH1cclxuXHJcbiAgaWYgKGZyZWVFeHBvcnRzICYmICFpc0xvYWRlcikge1xyXG4gICAgLy8gRXhwb3J0IGZvciBDb21tb25KUyBlbnZpcm9ubWVudHMuXHJcbiAgICBydW5JbkNvbnRleHQocm9vdCwgZnJlZUV4cG9ydHMpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICAvLyBFeHBvcnQgZm9yIHdlYiBicm93c2VycyBhbmQgSmF2YVNjcmlwdCBlbmdpbmVzLlxyXG4gICAgdmFyIG5hdGl2ZUpTT04gPSByb290LkpTT04sXHJcbiAgICAgICAgcHJldmlvdXNKU09OID0gcm9vdFtcIkpTT04zXCJdLFxyXG4gICAgICAgIGlzUmVzdG9yZWQgPSBmYWxzZTtcclxuXHJcbiAgICB2YXIgSlNPTjMgPSBydW5JbkNvbnRleHQocm9vdCwgKHJvb3RbXCJKU09OM1wiXSA9IHtcclxuICAgICAgLy8gUHVibGljOiBSZXN0b3JlcyB0aGUgb3JpZ2luYWwgdmFsdWUgb2YgdGhlIGdsb2JhbCBgSlNPTmAgb2JqZWN0IGFuZFxyXG4gICAgICAvLyByZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBgSlNPTjNgIG9iamVjdC5cclxuICAgICAgXCJub0NvbmZsaWN0XCI6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIWlzUmVzdG9yZWQpIHtcclxuICAgICAgICAgIGlzUmVzdG9yZWQgPSB0cnVlO1xyXG4gICAgICAgICAgcm9vdC5KU09OID0gbmF0aXZlSlNPTjtcclxuICAgICAgICAgIHJvb3RbXCJKU09OM1wiXSA9IHByZXZpb3VzSlNPTjtcclxuICAgICAgICAgIG5hdGl2ZUpTT04gPSBwcmV2aW91c0pTT04gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gSlNPTjM7XHJcbiAgICAgIH1cclxuICAgIH0pKTtcclxuXHJcbiAgICByb290LkpTT04gPSB7XHJcbiAgICAgIFwicGFyc2VcIjogSlNPTjMucGFyc2UsXHJcbiAgICAgIFwic3RyaW5naWZ5XCI6IEpTT04zLnN0cmluZ2lmeVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8vIEV4cG9ydCBmb3IgYXN5bmNocm9ub3VzIG1vZHVsZSBsb2FkZXJzLlxyXG4gIGlmIChpc0xvYWRlcikge1xyXG4gICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIEpTT04zO1xyXG4gICAgfSk7XHJcbiAgfVxyXG59KS5jYWxsKHRoaXMpO1xyXG5cclxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXHJcblxyXG59LHt9XSw1ODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbi8qKlxyXG4gKiBIZWxwZXJzLlxyXG4gKi9cclxuXHJcbnZhciBzID0gMTAwMDtcclxudmFyIG0gPSBzICogNjA7XHJcbnZhciBoID0gbSAqIDYwO1xyXG52YXIgZCA9IGggKiAyNDtcclxudmFyIHkgPSBkICogMzY1LjI1O1xyXG5cclxuLyoqXHJcbiAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXHJcbiAqXHJcbiAqIE9wdGlvbnM6XHJcbiAqXHJcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAqIEB0aHJvd3Mge0Vycm9yfSB0aHJvdyBhbiBlcnJvciBpZiB2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIG51bWJlclxyXG4gKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKSB7XHJcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsO1xyXG4gIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xyXG4gICAgcmV0dXJuIHBhcnNlKHZhbCk7XHJcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWwpID09PSBmYWxzZSkge1xyXG4gICAgcmV0dXJuIG9wdGlvbnMubG9uZyA/IGZtdExvbmcodmFsKSA6IGZtdFNob3J0KHZhbCk7XHJcbiAgfVxyXG4gIHRocm93IG5ldyBFcnJvcihcclxuICAgICd2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIHZhbGlkIG51bWJlci4gdmFsPScgK1xyXG4gICAgICBKU09OLnN0cmluZ2lmeSh2YWwpXHJcbiAgKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcclxuICogQHJldHVybiB7TnVtYmVyfVxyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcblxyXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcclxuICBzdHIgPSBTdHJpbmcoc3RyKTtcclxuICBpZiAoc3RyLmxlbmd0aCA+IDEwMCkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICB2YXIgbWF0Y2ggPSAvXigoPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKFxyXG4gICAgc3RyXHJcbiAgKTtcclxuICBpZiAoIW1hdGNoKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XHJcbiAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcclxuICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgIGNhc2UgJ3llYXJzJzpcclxuICAgIGNhc2UgJ3llYXInOlxyXG4gICAgY2FzZSAneXJzJzpcclxuICAgIGNhc2UgJ3lyJzpcclxuICAgIGNhc2UgJ3knOlxyXG4gICAgICByZXR1cm4gbiAqIHk7XHJcbiAgICBjYXNlICdkYXlzJzpcclxuICAgIGNhc2UgJ2RheSc6XHJcbiAgICBjYXNlICdkJzpcclxuICAgICAgcmV0dXJuIG4gKiBkO1xyXG4gICAgY2FzZSAnaG91cnMnOlxyXG4gICAgY2FzZSAnaG91cic6XHJcbiAgICBjYXNlICdocnMnOlxyXG4gICAgY2FzZSAnaHInOlxyXG4gICAgY2FzZSAnaCc6XHJcbiAgICAgIHJldHVybiBuICogaDtcclxuICAgIGNhc2UgJ21pbnV0ZXMnOlxyXG4gICAgY2FzZSAnbWludXRlJzpcclxuICAgIGNhc2UgJ21pbnMnOlxyXG4gICAgY2FzZSAnbWluJzpcclxuICAgIGNhc2UgJ20nOlxyXG4gICAgICByZXR1cm4gbiAqIG07XHJcbiAgICBjYXNlICdzZWNvbmRzJzpcclxuICAgIGNhc2UgJ3NlY29uZCc6XHJcbiAgICBjYXNlICdzZWNzJzpcclxuICAgIGNhc2UgJ3NlYyc6XHJcbiAgICBjYXNlICdzJzpcclxuICAgICAgcmV0dXJuIG4gKiBzO1xyXG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcclxuICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcclxuICAgIGNhc2UgJ21zZWNzJzpcclxuICAgIGNhc2UgJ21zZWMnOlxyXG4gICAgY2FzZSAnbXMnOlxyXG4gICAgICByZXR1cm4gbjtcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxyXG4gKlxyXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcclxuICogQHJldHVybiB7U3RyaW5nfVxyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcblxyXG5mdW5jdGlvbiBmbXRTaG9ydChtcykge1xyXG4gIGlmIChtcyA+PSBkKSB7XHJcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xyXG4gIH1cclxuICBpZiAobXMgPj0gaCkge1xyXG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcclxuICB9XHJcbiAgaWYgKG1zID49IG0pIHtcclxuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XHJcbiAgfVxyXG4gIGlmIChtcyA+PSBzKSB7XHJcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xyXG4gIH1cclxuICByZXR1cm4gbXMgKyAnbXMnO1xyXG59XHJcblxyXG4vKipcclxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XHJcbiAqIEBhcGkgcHJpdmF0ZVxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcclxuICByZXR1cm4gcGx1cmFsKG1zLCBkLCAnZGF5JykgfHxcclxuICAgIHBsdXJhbChtcywgaCwgJ2hvdXInKSB8fFxyXG4gICAgcGx1cmFsKG1zLCBtLCAnbWludXRlJykgfHxcclxuICAgIHBsdXJhbChtcywgcywgJ3NlY29uZCcpIHx8XHJcbiAgICBtcyArICcgbXMnO1xyXG59XHJcblxyXG4vKipcclxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gcGx1cmFsKG1zLCBuLCBuYW1lKSB7XHJcbiAgaWYgKG1zIDwgbikge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBpZiAobXMgPCBuICogMS41KSB7XHJcbiAgICByZXR1cm4gTWF0aC5mbG9vcihtcyAvIG4pICsgJyAnICsgbmFtZTtcclxuICB9XHJcbiAgcmV0dXJuIE1hdGguY2VpbChtcyAvIG4pICsgJyAnICsgbmFtZSArICdzJztcclxufVxyXG5cclxufSx7fV0sNTk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcclxuXHJcbi8qKlxyXG4gKiBEZWNvZGUgYSBVUkkgZW5jb2RlZCBzdHJpbmcuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgVVJJIGVuY29kZWQgc3RyaW5nLlxyXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgZGVjb2RlZCBzdHJpbmcuXHJcbiAqIEBhcGkgcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XHJcbiAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChpbnB1dC5yZXBsYWNlKC9cXCsvZywgJyAnKSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTaW1wbGUgcXVlcnkgc3RyaW5nIHBhcnNlci5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IHF1ZXJ5IFRoZSBxdWVyeSBzdHJpbmcgdGhhdCBuZWVkcyB0byBiZSBwYXJzZWQuXHJcbiAqIEByZXR1cm5zIHtPYmplY3R9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBxdWVyeXN0cmluZyhxdWVyeSkge1xyXG4gIHZhciBwYXJzZXIgPSAvKFtePT8mXSspPT8oW14mXSopL2dcclxuICAgICwgcmVzdWx0ID0ge31cclxuICAgICwgcGFydDtcclxuXHJcbiAgd2hpbGUgKHBhcnQgPSBwYXJzZXIuZXhlYyhxdWVyeSkpIHtcclxuICAgIHZhciBrZXkgPSBkZWNvZGUocGFydFsxXSlcclxuICAgICAgLCB2YWx1ZSA9IGRlY29kZShwYXJ0WzJdKTtcclxuXHJcbiAgICAvL1xyXG4gICAgLy8gUHJldmVudCBvdmVycmlkaW5nIG9mIGV4aXN0aW5nIHByb3BlcnRpZXMuIFRoaXMgZW5zdXJlcyB0aGF0IGJ1aWxkLWluXHJcbiAgICAvLyBtZXRob2RzIGxpa2UgYHRvU3RyaW5nYCBvciBfX3Byb3RvX18gYXJlIG5vdCBvdmVycmlkZW4gYnkgbWFsaWNpb3VzXHJcbiAgICAvLyBxdWVyeXN0cmluZ3MuXHJcbiAgICAvL1xyXG4gICAgaWYgKGtleSBpbiByZXN1bHQpIGNvbnRpbnVlO1xyXG4gICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcclxuICB9XHJcblxyXG4gIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUcmFuc2Zvcm0gYSBxdWVyeSBzdHJpbmcgdG8gYW4gb2JqZWN0LlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIE9iamVjdCB0aGF0IHNob3VsZCBiZSB0cmFuc2Zvcm1lZC5cclxuICogQHBhcmFtIHtTdHJpbmd9IHByZWZpeCBPcHRpb25hbCBwcmVmaXguXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBxdWVyeXN0cmluZ2lmeShvYmosIHByZWZpeCkge1xyXG4gIHByZWZpeCA9IHByZWZpeCB8fCAnJztcclxuXHJcbiAgdmFyIHBhaXJzID0gW107XHJcblxyXG4gIC8vXHJcbiAgLy8gT3B0aW9uYWxseSBwcmVmaXggd2l0aCBhICc/JyBpZiBuZWVkZWRcclxuICAvL1xyXG4gIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIHByZWZpeCkgcHJlZml4ID0gJz8nO1xyXG5cclxuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XHJcbiAgICBpZiAoaGFzLmNhbGwob2JqLCBrZXkpKSB7XHJcbiAgICAgIHBhaXJzLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyc9JysgZW5jb2RlVVJJQ29tcG9uZW50KG9ialtrZXldKSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gcGFpcnMubGVuZ3RoID8gcHJlZml4ICsgcGFpcnMuam9pbignJicpIDogJyc7XHJcbn1cclxuXHJcbi8vXHJcbi8vIEV4cG9zZSB0aGUgbW9kdWxlLlxyXG4vL1xyXG5leHBvcnRzLnN0cmluZ2lmeSA9IHF1ZXJ5c3RyaW5naWZ5O1xyXG5leHBvcnRzLnBhcnNlID0gcXVlcnlzdHJpbmc7XHJcblxyXG59LHt9XSw2MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiB3ZSdyZSByZXF1aXJlZCB0byBhZGQgYSBwb3J0IG51bWJlci5cclxuICpcclxuICogQHNlZSBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RlZmF1bHQtcG9ydFxyXG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IHBvcnQgUG9ydCBudW1iZXIgd2UgbmVlZCB0byBjaGVja1xyXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvdG9jb2wgUHJvdG9jb2wgd2UgbmVlZCB0byBjaGVjayBhZ2FpbnN0LlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gSXMgaXQgYSBkZWZhdWx0IHBvcnQgZm9yIHRoZSBnaXZlbiBwcm90b2NvbFxyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmVxdWlyZWQocG9ydCwgcHJvdG9jb2wpIHtcclxuICBwcm90b2NvbCA9IHByb3RvY29sLnNwbGl0KCc6JylbMF07XHJcbiAgcG9ydCA9ICtwb3J0O1xyXG5cclxuICBpZiAoIXBvcnQpIHJldHVybiBmYWxzZTtcclxuXHJcbiAgc3dpdGNoIChwcm90b2NvbCkge1xyXG4gICAgY2FzZSAnaHR0cCc6XHJcbiAgICBjYXNlICd3cyc6XHJcbiAgICByZXR1cm4gcG9ydCAhPT0gODA7XHJcblxyXG4gICAgY2FzZSAnaHR0cHMnOlxyXG4gICAgY2FzZSAnd3NzJzpcclxuICAgIHJldHVybiBwb3J0ICE9PSA0NDM7XHJcblxyXG4gICAgY2FzZSAnZnRwJzpcclxuICAgIHJldHVybiBwb3J0ICE9PSAyMTtcclxuXHJcbiAgICBjYXNlICdnb3BoZXInOlxyXG4gICAgcmV0dXJuIHBvcnQgIT09IDcwO1xyXG5cclxuICAgIGNhc2UgJ2ZpbGUnOlxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHBvcnQgIT09IDA7XHJcbn07XHJcblxyXG59LHt9XSw2MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XHJcbihmdW5jdGlvbiAoZ2xvYmFsKXtcclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIHJlcXVpcmVkID0gcmVxdWlyZSgncmVxdWlyZXMtcG9ydCcpXHJcbiAgLCBxcyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5naWZ5JylcclxuICAsIHByb3RvY29scmUgPSAvXihbYS16XVthLXowLTkuKy1dKjopPyhcXC9cXC8pPyhbXFxTXFxzXSopL2lcclxuICAsIHNsYXNoZXMgPSAvXltBLVphLXpdW0EtWmEtejAtOSstLl0qOlxcL1xcLy87XHJcblxyXG4vKipcclxuICogVGhlc2UgYXJlIHRoZSBwYXJzZSBydWxlcyBmb3IgdGhlIFVSTCBwYXJzZXIsIGl0IGluZm9ybXMgdGhlIHBhcnNlclxyXG4gKiBhYm91dDpcclxuICpcclxuICogMC4gVGhlIGNoYXIgaXQgTmVlZHMgdG8gcGFyc2UsIGlmIGl0J3MgYSBzdHJpbmcgaXQgc2hvdWxkIGJlIGRvbmUgdXNpbmdcclxuICogICAgaW5kZXhPZiwgUmVnRXhwIHVzaW5nIGV4ZWMgYW5kIE5hTiBtZWFucyBzZXQgYXMgY3VycmVudCB2YWx1ZS5cclxuICogMS4gVGhlIHByb3BlcnR5IHdlIHNob3VsZCBzZXQgd2hlbiBwYXJzaW5nIHRoaXMgdmFsdWUuXHJcbiAqIDIuIEluZGljYXRpb24gaWYgaXQncyBiYWNrd2FyZHMgb3IgZm9yd2FyZCBwYXJzaW5nLCB3aGVuIHNldCBhcyBudW1iZXIgaXQnc1xyXG4gKiAgICB0aGUgdmFsdWUgb2YgZXh0cmEgY2hhcnMgdGhhdCBzaG91bGQgYmUgc3BsaXQgb2ZmLlxyXG4gKiAzLiBJbmhlcml0IGZyb20gbG9jYXRpb24gaWYgbm9uIGV4aXN0aW5nIGluIHRoZSBwYXJzZXIuXHJcbiAqIDQuIGB0b0xvd2VyQ2FzZWAgdGhlIHJlc3VsdGluZyB2YWx1ZS5cclxuICovXHJcbnZhciBydWxlcyA9IFtcclxuICBbJyMnLCAnaGFzaCddLCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgZnJvbSB0aGUgYmFjay5cclxuICBbJz8nLCAncXVlcnknXSwgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgZnJvbSB0aGUgYmFjay5cclxuICBbJy8nLCAncGF0aG5hbWUnXSwgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgZnJvbSB0aGUgYmFjay5cclxuICBbJ0AnLCAnYXV0aCcsIDFdLCAgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgZnJvbSB0aGUgZnJvbnQuXHJcbiAgW05hTiwgJ2hvc3QnLCB1bmRlZmluZWQsIDEsIDFdLCAgICAgICAvLyBTZXQgbGVmdCBvdmVyIHZhbHVlLlxyXG4gIFsvOihcXGQrKSQvLCAncG9ydCcsIHVuZGVmaW5lZCwgMV0sICAgIC8vIFJlZ0V4cCB0aGUgYmFjay5cclxuICBbTmFOLCAnaG9zdG5hbWUnLCB1bmRlZmluZWQsIDEsIDFdICAgIC8vIFNldCBsZWZ0IG92ZXIuXHJcbl07XHJcblxyXG4vKipcclxuICogVGhlc2UgcHJvcGVydGllcyBzaG91bGQgbm90IGJlIGNvcGllZCBvciBpbmhlcml0ZWQgZnJvbS4gVGhpcyBpcyBvbmx5IG5lZWRlZFxyXG4gKiBmb3IgYWxsIG5vbiBibG9iIFVSTCdzIGFzIGEgYmxvYiBVUkwgZG9lcyBub3QgaW5jbHVkZSBhIGhhc2gsIG9ubHkgdGhlXHJcbiAqIG9yaWdpbi5cclxuICpcclxuICogQHR5cGUge09iamVjdH1cclxuICogQHByaXZhdGVcclxuICovXHJcbnZhciBpZ25vcmUgPSB7IGhhc2g6IDEsIHF1ZXJ5OiAxIH07XHJcblxyXG4vKipcclxuICogVGhlIGxvY2F0aW9uIG9iamVjdCBkaWZmZXJzIHdoZW4geW91ciBjb2RlIGlzIGxvYWRlZCB0aHJvdWdoIGEgbm9ybWFsIHBhZ2UsXHJcbiAqIFdvcmtlciBvciB0aHJvdWdoIGEgd29ya2VyIHVzaW5nIGEgYmxvYi4gQW5kIHdpdGggdGhlIGJsb2JibGUgYmVnaW5zIHRoZVxyXG4gKiB0cm91YmxlIGFzIHRoZSBsb2NhdGlvbiBvYmplY3Qgd2lsbCBjb250YWluIHRoZSBVUkwgb2YgdGhlIGJsb2IsIG5vdCB0aGVcclxuICogbG9jYXRpb24gb2YgdGhlIHBhZ2Ugd2hlcmUgb3VyIGNvZGUgaXMgbG9hZGVkIGluLiBUaGUgYWN0dWFsIG9yaWdpbiBpc1xyXG4gKiBlbmNvZGVkIGluIHRoZSBgcGF0aG5hbWVgIHNvIHdlIGNhbiB0aGFua2Z1bGx5IGdlbmVyYXRlIGEgZ29vZCBcImRlZmF1bHRcIlxyXG4gKiBsb2NhdGlvbiBmcm9tIGl0IHNvIHdlIGNhbiBnZW5lcmF0ZSBwcm9wZXIgcmVsYXRpdmUgVVJMJ3MgYWdhaW4uXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gbG9jIE9wdGlvbmFsIGRlZmF1bHQgbG9jYXRpb24gb2JqZWN0LlxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBsb2xjYXRpb24gb2JqZWN0LlxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gbG9sY2F0aW9uKGxvYykge1xyXG4gIGxvYyA9IGxvYyB8fCBnbG9iYWwubG9jYXRpb24gfHwge307XHJcblxyXG4gIHZhciBmaW5hbGRlc3RpbmF0aW9uID0ge31cclxuICAgICwgdHlwZSA9IHR5cGVvZiBsb2NcclxuICAgICwga2V5O1xyXG5cclxuICBpZiAoJ2Jsb2I6JyA9PT0gbG9jLnByb3RvY29sKSB7XHJcbiAgICBmaW5hbGRlc3RpbmF0aW9uID0gbmV3IFVSTCh1bmVzY2FwZShsb2MucGF0aG5hbWUpLCB7fSk7XHJcbiAgfSBlbHNlIGlmICgnc3RyaW5nJyA9PT0gdHlwZSkge1xyXG4gICAgZmluYWxkZXN0aW5hdGlvbiA9IG5ldyBVUkwobG9jLCB7fSk7XHJcbiAgICBmb3IgKGtleSBpbiBpZ25vcmUpIGRlbGV0ZSBmaW5hbGRlc3RpbmF0aW9uW2tleV07XHJcbiAgfSBlbHNlIGlmICgnb2JqZWN0JyA9PT0gdHlwZSkge1xyXG4gICAgZm9yIChrZXkgaW4gbG9jKSB7XHJcbiAgICAgIGlmIChrZXkgaW4gaWdub3JlKSBjb250aW51ZTtcclxuICAgICAgZmluYWxkZXN0aW5hdGlvbltrZXldID0gbG9jW2tleV07XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGZpbmFsZGVzdGluYXRpb24uc2xhc2hlcyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGZpbmFsZGVzdGluYXRpb24uc2xhc2hlcyA9IHNsYXNoZXMudGVzdChsb2MuaHJlZik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZmluYWxkZXN0aW5hdGlvbjtcclxufVxyXG5cclxuLyoqXHJcbiAqIEB0eXBlZGVmIFByb3RvY29sRXh0cmFjdFxyXG4gKiBAdHlwZSBPYmplY3RcclxuICogQHByb3BlcnR5IHtTdHJpbmd9IHByb3RvY29sIFByb3RvY29sIG1hdGNoZWQgaW4gdGhlIFVSTCwgaW4gbG93ZXJjYXNlLlxyXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IHNsYXNoZXMgYHRydWVgIGlmIHByb3RvY29sIGlzIGZvbGxvd2VkIGJ5IFwiLy9cIiwgZWxzZSBgZmFsc2VgLlxyXG4gKiBAcHJvcGVydHkge1N0cmluZ30gcmVzdCBSZXN0IG9mIHRoZSBVUkwgdGhhdCBpcyBub3QgcGFydCBvZiB0aGUgcHJvdG9jb2wuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEV4dHJhY3QgcHJvdG9jb2wgaW5mb3JtYXRpb24gZnJvbSBhIFVSTCB3aXRoL3dpdGhvdXQgZG91YmxlIHNsYXNoIChcIi8vXCIpLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzcyBVUkwgd2Ugd2FudCB0byBleHRyYWN0IGZyb20uXHJcbiAqIEByZXR1cm4ge1Byb3RvY29sRXh0cmFjdH0gRXh0cmFjdGVkIGluZm9ybWF0aW9uLlxyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGV4dHJhY3RQcm90b2NvbChhZGRyZXNzKSB7XHJcbiAgdmFyIG1hdGNoID0gcHJvdG9jb2xyZS5leGVjKGFkZHJlc3MpO1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgcHJvdG9jb2w6IG1hdGNoWzFdID8gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKSA6ICcnLFxyXG4gICAgc2xhc2hlczogISFtYXRjaFsyXSxcclxuICAgIHJlc3Q6IG1hdGNoWzNdXHJcbiAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlc29sdmUgYSByZWxhdGl2ZSBVUkwgcGF0aG5hbWUgYWdhaW5zdCBhIGJhc2UgVVJMIHBhdGhuYW1lLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVsYXRpdmUgUGF0aG5hbWUgb2YgdGhlIHJlbGF0aXZlIFVSTC5cclxuICogQHBhcmFtIHtTdHJpbmd9IGJhc2UgUGF0aG5hbWUgb2YgdGhlIGJhc2UgVVJMLlxyXG4gKiBAcmV0dXJuIHtTdHJpbmd9IFJlc29sdmVkIHBhdGhuYW1lLlxyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHJlc29sdmUocmVsYXRpdmUsIGJhc2UpIHtcclxuICB2YXIgcGF0aCA9IChiYXNlIHx8ICcvJykuc3BsaXQoJy8nKS5zbGljZSgwLCAtMSkuY29uY2F0KHJlbGF0aXZlLnNwbGl0KCcvJykpXHJcbiAgICAsIGkgPSBwYXRoLmxlbmd0aFxyXG4gICAgLCBsYXN0ID0gcGF0aFtpIC0gMV1cclxuICAgICwgdW5zaGlmdCA9IGZhbHNlXHJcbiAgICAsIHVwID0gMDtcclxuXHJcbiAgd2hpbGUgKGktLSkge1xyXG4gICAgaWYgKHBhdGhbaV0gPT09ICcuJykge1xyXG4gICAgICBwYXRoLnNwbGljZShpLCAxKTtcclxuICAgIH0gZWxzZSBpZiAocGF0aFtpXSA9PT0gJy4uJykge1xyXG4gICAgICBwYXRoLnNwbGljZShpLCAxKTtcclxuICAgICAgdXArKztcclxuICAgIH0gZWxzZSBpZiAodXApIHtcclxuICAgICAgaWYgKGkgPT09IDApIHVuc2hpZnQgPSB0cnVlO1xyXG4gICAgICBwYXRoLnNwbGljZShpLCAxKTtcclxuICAgICAgdXAtLTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmICh1bnNoaWZ0KSBwYXRoLnVuc2hpZnQoJycpO1xyXG4gIGlmIChsYXN0ID09PSAnLicgfHwgbGFzdCA9PT0gJy4uJykgcGF0aC5wdXNoKCcnKTtcclxuXHJcbiAgcmV0dXJuIHBhdGguam9pbignLycpO1xyXG59XHJcblxyXG4vKipcclxuICogVGhlIGFjdHVhbCBVUkwgaW5zdGFuY2UuIEluc3RlYWQgb2YgcmV0dXJuaW5nIGFuIG9iamVjdCB3ZSd2ZSBvcHRlZC1pbiB0b1xyXG4gKiBjcmVhdGUgYW4gYWN0dWFsIGNvbnN0cnVjdG9yIGFzIGl0J3MgbXVjaCBtb3JlIG1lbW9yeSBlZmZpY2llbnQgYW5kXHJcbiAqIGZhc3RlciBhbmQgaXQgcGxlYXNlcyBteSBPQ0QuXHJcbiAqXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzcyBVUkwgd2Ugd2FudCB0byBwYXJzZS5cclxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBsb2NhdGlvbiBMb2NhdGlvbiBkZWZhdWx0cyBmb3IgcmVsYXRpdmUgcGF0aHMuXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbnxGdW5jdGlvbn0gcGFyc2VyIFBhcnNlciBmb3IgdGhlIHF1ZXJ5IHN0cmluZy5cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIFVSTChhZGRyZXNzLCBsb2NhdGlvbiwgcGFyc2VyKSB7XHJcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFVSTCkpIHtcclxuICAgIHJldHVybiBuZXcgVVJMKGFkZHJlc3MsIGxvY2F0aW9uLCBwYXJzZXIpO1xyXG4gIH1cclxuXHJcbiAgdmFyIHJlbGF0aXZlLCBleHRyYWN0ZWQsIHBhcnNlLCBpbnN0cnVjdGlvbiwgaW5kZXgsIGtleVxyXG4gICAgLCBpbnN0cnVjdGlvbnMgPSBydWxlcy5zbGljZSgpXHJcbiAgICAsIHR5cGUgPSB0eXBlb2YgbG9jYXRpb25cclxuICAgICwgdXJsID0gdGhpc1xyXG4gICAgLCBpID0gMDtcclxuXHJcbiAgLy9cclxuICAvLyBUaGUgZm9sbG93aW5nIGlmIHN0YXRlbWVudHMgYWxsb3dzIHRoaXMgbW9kdWxlIHR3byBoYXZlIGNvbXBhdGliaWxpdHkgd2l0aFxyXG4gIC8vIDIgZGlmZmVyZW50IEFQSTpcclxuICAvL1xyXG4gIC8vIDEuIE5vZGUuanMncyBgdXJsLnBhcnNlYCBhcGkgd2hpY2ggYWNjZXB0cyBhIFVSTCwgYm9vbGVhbiBhcyBhcmd1bWVudHNcclxuICAvLyAgICB3aGVyZSB0aGUgYm9vbGVhbiBpbmRpY2F0ZXMgdGhhdCB0aGUgcXVlcnkgc3RyaW5nIHNob3VsZCBhbHNvIGJlIHBhcnNlZC5cclxuICAvL1xyXG4gIC8vIDIuIFRoZSBgVVJMYCBpbnRlcmZhY2Ugb2YgdGhlIGJyb3dzZXIgd2hpY2ggYWNjZXB0cyBhIFVSTCwgb2JqZWN0IGFzXHJcbiAgLy8gICAgYXJndW1lbnRzLiBUaGUgc3VwcGxpZWQgb2JqZWN0IHdpbGwgYmUgdXNlZCBhcyBkZWZhdWx0IHZhbHVlcyAvIGZhbGwtYmFja1xyXG4gIC8vICAgIGZvciByZWxhdGl2ZSBwYXRocy5cclxuICAvL1xyXG4gIGlmICgnb2JqZWN0JyAhPT0gdHlwZSAmJiAnc3RyaW5nJyAhPT0gdHlwZSkge1xyXG4gICAgcGFyc2VyID0gbG9jYXRpb247XHJcbiAgICBsb2NhdGlvbiA9IG51bGw7XHJcbiAgfVxyXG5cclxuICBpZiAocGFyc2VyICYmICdmdW5jdGlvbicgIT09IHR5cGVvZiBwYXJzZXIpIHBhcnNlciA9IHFzLnBhcnNlO1xyXG5cclxuICBsb2NhdGlvbiA9IGxvbGNhdGlvbihsb2NhdGlvbik7XHJcblxyXG4gIC8vXHJcbiAgLy8gRXh0cmFjdCBwcm90b2NvbCBpbmZvcm1hdGlvbiBiZWZvcmUgcnVubmluZyB0aGUgaW5zdHJ1Y3Rpb25zLlxyXG4gIC8vXHJcbiAgZXh0cmFjdGVkID0gZXh0cmFjdFByb3RvY29sKGFkZHJlc3MgfHwgJycpO1xyXG4gIHJlbGF0aXZlID0gIWV4dHJhY3RlZC5wcm90b2NvbCAmJiAhZXh0cmFjdGVkLnNsYXNoZXM7XHJcbiAgdXJsLnNsYXNoZXMgPSBleHRyYWN0ZWQuc2xhc2hlcyB8fCByZWxhdGl2ZSAmJiBsb2NhdGlvbi5zbGFzaGVzO1xyXG4gIHVybC5wcm90b2NvbCA9IGV4dHJhY3RlZC5wcm90b2NvbCB8fCBsb2NhdGlvbi5wcm90b2NvbCB8fCAnJztcclxuICBhZGRyZXNzID0gZXh0cmFjdGVkLnJlc3Q7XHJcblxyXG4gIC8vXHJcbiAgLy8gV2hlbiB0aGUgYXV0aG9yaXR5IGNvbXBvbmVudCBpcyBhYnNlbnQgdGhlIFVSTCBzdGFydHMgd2l0aCBhIHBhdGhcclxuICAvLyBjb21wb25lbnQuXHJcbiAgLy9cclxuICBpZiAoIWV4dHJhY3RlZC5zbGFzaGVzKSBpbnN0cnVjdGlvbnNbMl0gPSBbLyguKikvLCAncGF0aG5hbWUnXTtcclxuXHJcbiAgZm9yICg7IGkgPCBpbnN0cnVjdGlvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgIGluc3RydWN0aW9uID0gaW5zdHJ1Y3Rpb25zW2ldO1xyXG4gICAgcGFyc2UgPSBpbnN0cnVjdGlvblswXTtcclxuICAgIGtleSA9IGluc3RydWN0aW9uWzFdO1xyXG5cclxuICAgIGlmIChwYXJzZSAhPT0gcGFyc2UpIHtcclxuICAgICAgdXJsW2tleV0gPSBhZGRyZXNzO1xyXG4gICAgfSBlbHNlIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHBhcnNlKSB7XHJcbiAgICAgIGlmICh+KGluZGV4ID0gYWRkcmVzcy5pbmRleE9mKHBhcnNlKSkpIHtcclxuICAgICAgICBpZiAoJ251bWJlcicgPT09IHR5cGVvZiBpbnN0cnVjdGlvblsyXSkge1xyXG4gICAgICAgICAgdXJsW2tleV0gPSBhZGRyZXNzLnNsaWNlKDAsIGluZGV4KTtcclxuICAgICAgICAgIGFkZHJlc3MgPSBhZGRyZXNzLnNsaWNlKGluZGV4ICsgaW5zdHJ1Y3Rpb25bMl0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB1cmxba2V5XSA9IGFkZHJlc3Muc2xpY2UoaW5kZXgpO1xyXG4gICAgICAgICAgYWRkcmVzcyA9IGFkZHJlc3Muc2xpY2UoMCwgaW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmICgoaW5kZXggPSBwYXJzZS5leGVjKGFkZHJlc3MpKSkge1xyXG4gICAgICB1cmxba2V5XSA9IGluZGV4WzFdO1xyXG4gICAgICBhZGRyZXNzID0gYWRkcmVzcy5zbGljZSgwLCBpbmRleC5pbmRleCk7XHJcbiAgICB9XHJcblxyXG4gICAgdXJsW2tleV0gPSB1cmxba2V5XSB8fCAoXHJcbiAgICAgIHJlbGF0aXZlICYmIGluc3RydWN0aW9uWzNdID8gbG9jYXRpb25ba2V5XSB8fCAnJyA6ICcnXHJcbiAgICApO1xyXG5cclxuICAgIC8vXHJcbiAgICAvLyBIb3N0bmFtZSwgaG9zdCBhbmQgcHJvdG9jb2wgc2hvdWxkIGJlIGxvd2VyY2FzZWQgc28gdGhleSBjYW4gYmUgdXNlZCB0b1xyXG4gICAgLy8gY3JlYXRlIGEgcHJvcGVyIGBvcmlnaW5gLlxyXG4gICAgLy9cclxuICAgIGlmIChpbnN0cnVjdGlvbls0XSkgdXJsW2tleV0gPSB1cmxba2V5XS50b0xvd2VyQ2FzZSgpO1xyXG4gIH1cclxuXHJcbiAgLy9cclxuICAvLyBBbHNvIHBhcnNlIHRoZSBzdXBwbGllZCBxdWVyeSBzdHJpbmcgaW4gdG8gYW4gb2JqZWN0LiBJZiB3ZSdyZSBzdXBwbGllZFxyXG4gIC8vIHdpdGggYSBjdXN0b20gcGFyc2VyIGFzIGZ1bmN0aW9uIHVzZSB0aGF0IGluc3RlYWQgb2YgdGhlIGRlZmF1bHQgYnVpbGQtaW5cclxuICAvLyBwYXJzZXIuXHJcbiAgLy9cclxuICBpZiAocGFyc2VyKSB1cmwucXVlcnkgPSBwYXJzZXIodXJsLnF1ZXJ5KTtcclxuXHJcbiAgLy9cclxuICAvLyBJZiB0aGUgVVJMIGlzIHJlbGF0aXZlLCByZXNvbHZlIHRoZSBwYXRobmFtZSBhZ2FpbnN0IHRoZSBiYXNlIFVSTC5cclxuICAvL1xyXG4gIGlmIChcclxuICAgICAgcmVsYXRpdmVcclxuICAgICYmIGxvY2F0aW9uLnNsYXNoZXNcclxuICAgICYmIHVybC5wYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJ1xyXG4gICAgJiYgKHVybC5wYXRobmFtZSAhPT0gJycgfHwgbG9jYXRpb24ucGF0aG5hbWUgIT09ICcnKVxyXG4gICkge1xyXG4gICAgdXJsLnBhdGhuYW1lID0gcmVzb2x2ZSh1cmwucGF0aG5hbWUsIGxvY2F0aW9uLnBhdGhuYW1lKTtcclxuICB9XHJcblxyXG4gIC8vXHJcbiAgLy8gV2Ugc2hvdWxkIG5vdCBhZGQgcG9ydCBudW1iZXJzIGlmIHRoZXkgYXJlIGFscmVhZHkgdGhlIGRlZmF1bHQgcG9ydCBudW1iZXJcclxuICAvLyBmb3IgYSBnaXZlbiBwcm90b2NvbC4gQXMgdGhlIGhvc3QgYWxzbyBjb250YWlucyB0aGUgcG9ydCBudW1iZXIgd2UncmUgZ29pbmdcclxuICAvLyBvdmVycmlkZSBpdCB3aXRoIHRoZSBob3N0bmFtZSB3aGljaCBjb250YWlucyBubyBwb3J0IG51bWJlci5cclxuICAvL1xyXG4gIGlmICghcmVxdWlyZWQodXJsLnBvcnQsIHVybC5wcm90b2NvbCkpIHtcclxuICAgIHVybC5ob3N0ID0gdXJsLmhvc3RuYW1lO1xyXG4gICAgdXJsLnBvcnQgPSAnJztcclxuICB9XHJcblxyXG4gIC8vXHJcbiAgLy8gUGFyc2UgZG93biB0aGUgYGF1dGhgIGZvciB0aGUgdXNlcm5hbWUgYW5kIHBhc3N3b3JkLlxyXG4gIC8vXHJcbiAgdXJsLnVzZXJuYW1lID0gdXJsLnBhc3N3b3JkID0gJyc7XHJcbiAgaWYgKHVybC5hdXRoKSB7XHJcbiAgICBpbnN0cnVjdGlvbiA9IHVybC5hdXRoLnNwbGl0KCc6Jyk7XHJcbiAgICB1cmwudXNlcm5hbWUgPSBpbnN0cnVjdGlvblswXSB8fCAnJztcclxuICAgIHVybC5wYXNzd29yZCA9IGluc3RydWN0aW9uWzFdIHx8ICcnO1xyXG4gIH1cclxuXHJcbiAgdXJsLm9yaWdpbiA9IHVybC5wcm90b2NvbCAmJiB1cmwuaG9zdCAmJiB1cmwucHJvdG9jb2wgIT09ICdmaWxlOidcclxuICAgID8gdXJsLnByb3RvY29sICsnLy8nKyB1cmwuaG9zdFxyXG4gICAgOiAnbnVsbCc7XHJcblxyXG4gIC8vXHJcbiAgLy8gVGhlIGhyZWYgaXMganVzdCB0aGUgY29tcGlsZWQgcmVzdWx0LlxyXG4gIC8vXHJcbiAgdXJsLmhyZWYgPSB1cmwudG9TdHJpbmcoKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoaXMgaXMgY29udmVuaWVuY2UgbWV0aG9kIGZvciBjaGFuZ2luZyBwcm9wZXJ0aWVzIGluIHRoZSBVUkwgaW5zdGFuY2UgdG9cclxuICogaW5zdXJlIHRoYXQgdGhleSBhbGwgcHJvcGFnYXRlIGNvcnJlY3RseS5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IHBhcnQgICAgICAgICAgUHJvcGVydHkgd2UgbmVlZCB0byBhZGp1c3QuXHJcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlICAgICAgICAgIFRoZSBuZXdseSBhc3NpZ25lZCB2YWx1ZS5cclxuICogQHBhcmFtIHtCb29sZWFufEZ1bmN0aW9ufSBmbiAgV2hlbiBzZXR0aW5nIHRoZSBxdWVyeSwgaXQgd2lsbCBiZSB0aGUgZnVuY3Rpb25cclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlZCB0byBwYXJzZSB0aGUgcXVlcnkuXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFdoZW4gc2V0dGluZyB0aGUgcHJvdG9jb2wsIGRvdWJsZSBzbGFzaCB3aWxsIGJlXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZWQgZnJvbSB0aGUgZmluYWwgdXJsIGlmIGl0IGlzIHRydWUuXHJcbiAqIEByZXR1cm5zIHtVUkx9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXQocGFydCwgdmFsdWUsIGZuKSB7XHJcbiAgdmFyIHVybCA9IHRoaXM7XHJcblxyXG4gIHN3aXRjaCAocGFydCkge1xyXG4gICAgY2FzZSAncXVlcnknOlxyXG4gICAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiB2YWx1ZSAmJiB2YWx1ZS5sZW5ndGgpIHtcclxuICAgICAgICB2YWx1ZSA9IChmbiB8fCBxcy5wYXJzZSkodmFsdWUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcclxuICAgICAgYnJlYWs7XHJcblxyXG4gICAgY2FzZSAncG9ydCc6XHJcbiAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xyXG5cclxuICAgICAgaWYgKCFyZXF1aXJlZCh2YWx1ZSwgdXJsLnByb3RvY29sKSkge1xyXG4gICAgICAgIHVybC5ob3N0ID0gdXJsLmhvc3RuYW1lO1xyXG4gICAgICAgIHVybFtwYXJ0XSA9ICcnO1xyXG4gICAgICB9IGVsc2UgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgdXJsLmhvc3QgPSB1cmwuaG9zdG5hbWUgKyc6JysgdmFsdWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGJyZWFrO1xyXG5cclxuICAgIGNhc2UgJ2hvc3RuYW1lJzpcclxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XHJcblxyXG4gICAgICBpZiAodXJsLnBvcnQpIHZhbHVlICs9ICc6JysgdXJsLnBvcnQ7XHJcbiAgICAgIHVybC5ob3N0ID0gdmFsdWU7XHJcbiAgICAgIGJyZWFrO1xyXG5cclxuICAgIGNhc2UgJ2hvc3QnOlxyXG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcclxuXHJcbiAgICAgIGlmICgvOlxcZCskLy50ZXN0KHZhbHVlKSkge1xyXG4gICAgICAgIHZhbHVlID0gdmFsdWUuc3BsaXQoJzonKTtcclxuICAgICAgICB1cmwucG9ydCA9IHZhbHVlLnBvcCgpO1xyXG4gICAgICAgIHVybC5ob3N0bmFtZSA9IHZhbHVlLmpvaW4oJzonKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB1cmwuaG9zdG5hbWUgPSB2YWx1ZTtcclxuICAgICAgICB1cmwucG9ydCA9ICcnO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBicmVhaztcclxuXHJcbiAgICBjYXNlICdwcm90b2NvbCc6XHJcbiAgICAgIHVybC5wcm90b2NvbCA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgIHVybC5zbGFzaGVzID0gIWZuO1xyXG4gICAgICBicmVhaztcclxuXHJcbiAgICBjYXNlICdwYXRobmFtZSc6XHJcbiAgICBjYXNlICdoYXNoJzpcclxuICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIGNoYXIgPSBwYXJ0ID09PSAncGF0aG5hbWUnID8gJy8nIDogJyMnO1xyXG4gICAgICAgIHVybFtwYXJ0XSA9IHZhbHVlLmNoYXJBdCgwKSAhPT0gY2hhciA/IGNoYXIgKyB2YWx1ZSA6IHZhbHVlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xyXG4gICAgICB9XHJcbiAgICAgIGJyZWFrO1xyXG5cclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xyXG4gIH1cclxuXHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgdmFyIGlucyA9IHJ1bGVzW2ldO1xyXG5cclxuICAgIGlmIChpbnNbNF0pIHVybFtpbnNbMV1dID0gdXJsW2luc1sxXV0udG9Mb3dlckNhc2UoKTtcclxuICB9XHJcblxyXG4gIHVybC5vcmlnaW4gPSB1cmwucHJvdG9jb2wgJiYgdXJsLmhvc3QgJiYgdXJsLnByb3RvY29sICE9PSAnZmlsZTonXHJcbiAgICA/IHVybC5wcm90b2NvbCArJy8vJysgdXJsLmhvc3RcclxuICAgIDogJ251bGwnO1xyXG5cclxuICB1cmwuaHJlZiA9IHVybC50b1N0cmluZygpO1xyXG5cclxuICByZXR1cm4gdXJsO1xyXG59XHJcblxyXG4vKipcclxuICogVHJhbnNmb3JtIHRoZSBwcm9wZXJ0aWVzIGJhY2sgaW4gdG8gYSB2YWxpZCBhbmQgZnVsbCBVUkwgc3RyaW5nLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmdpZnkgT3B0aW9uYWwgcXVlcnkgc3RyaW5naWZ5IGZ1bmN0aW9uLlxyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gdG9TdHJpbmcoc3RyaW5naWZ5KSB7XHJcbiAgaWYgKCFzdHJpbmdpZnkgfHwgJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIHN0cmluZ2lmeSkgc3RyaW5naWZ5ID0gcXMuc3RyaW5naWZ5O1xyXG5cclxuICB2YXIgcXVlcnlcclxuICAgICwgdXJsID0gdGhpc1xyXG4gICAgLCBwcm90b2NvbCA9IHVybC5wcm90b2NvbDtcclxuXHJcbiAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLmNoYXJBdChwcm90b2NvbC5sZW5ndGggLSAxKSAhPT0gJzonKSBwcm90b2NvbCArPSAnOic7XHJcblxyXG4gIHZhciByZXN1bHQgPSBwcm90b2NvbCArICh1cmwuc2xhc2hlcyA/ICcvLycgOiAnJyk7XHJcblxyXG4gIGlmICh1cmwudXNlcm5hbWUpIHtcclxuICAgIHJlc3VsdCArPSB1cmwudXNlcm5hbWU7XHJcbiAgICBpZiAodXJsLnBhc3N3b3JkKSByZXN1bHQgKz0gJzonKyB1cmwucGFzc3dvcmQ7XHJcbiAgICByZXN1bHQgKz0gJ0AnO1xyXG4gIH1cclxuXHJcbiAgcmVzdWx0ICs9IHVybC5ob3N0ICsgdXJsLnBhdGhuYW1lO1xyXG5cclxuICBxdWVyeSA9ICdvYmplY3QnID09PSB0eXBlb2YgdXJsLnF1ZXJ5ID8gc3RyaW5naWZ5KHVybC5xdWVyeSkgOiB1cmwucXVlcnk7XHJcbiAgaWYgKHF1ZXJ5KSByZXN1bHQgKz0gJz8nICE9PSBxdWVyeS5jaGFyQXQoMCkgPyAnPycrIHF1ZXJ5IDogcXVlcnk7XHJcblxyXG4gIGlmICh1cmwuaGFzaCkgcmVzdWx0ICs9IHVybC5oYXNoO1xyXG5cclxuICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5VUkwucHJvdG90eXBlID0geyBzZXQ6IHNldCwgdG9TdHJpbmc6IHRvU3RyaW5nIH07XHJcblxyXG4vL1xyXG4vLyBFeHBvc2UgdGhlIFVSTCBwYXJzZXIgYW5kIHNvbWUgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHRoYXQgbWlnaHQgYmUgdXNlZnVsIGZvclxyXG4vLyBvdGhlcnMgb3IgdGVzdGluZy5cclxuLy9cclxuVVJMLmV4dHJhY3RQcm90b2NvbCA9IGV4dHJhY3RQcm90b2NvbDtcclxuVVJMLmxvY2F0aW9uID0gbG9sY2F0aW9uO1xyXG5VUkwucXMgPSBxcztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVVJMO1xyXG5cclxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXHJcblxyXG59LHtcInF1ZXJ5c3RyaW5naWZ5XCI6NTksXCJyZXF1aXJlcy1wb3J0XCI6NjB9XX0se30sWzFdKSgxKVxyXG59KTtcclxuXHJcblxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zb2NranMuanMubWFwXHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///15\\n\")},function(module,exports,__webpack_require__){\"use strict\";eval(\"\\n\\n// The error overlay is inspired (and mostly copied) from Create React App (https://github.com/facebookincubator/create-react-app)\\n// They, in turn, got inspired by webpack-hot-middleware (https://github.com/glenjamin/webpack-hot-middleware).\\n\\nvar ansiHTML = __webpack_require__(17);\\nvar Entities = __webpack_require__(18).AllHtmlEntities;\\n\\nvar entities = new Entities();\\n\\nvar colors = {\\n  reset: ['transparent', 'transparent'],\\n  black: '181818',\\n  red: 'E36049',\\n  green: 'B3CB74',\\n  yellow: 'FFD080',\\n  blue: '7CAFC2',\\n  magenta: '7FACCA',\\n  cyan: 'C3C2EF',\\n  lightgrey: 'EBE7E3',\\n  darkgrey: '6D7891'\\n};\\nansiHTML.setColors(colors);\\n\\nfunction createOverlayIframe(onIframeLoad) {\\n  var iframe = document.createElement('iframe');\\n  iframe.id = 'webpack-dev-server-client-overlay';\\n  iframe.src = 'about:blank';\\n  iframe.style.position = 'fixed';\\n  iframe.style.left = 0;\\n  iframe.style.top = 0;\\n  iframe.style.right = 0;\\n  iframe.style.bottom = 0;\\n  iframe.style.width = '100vw';\\n  iframe.style.height = '100vh';\\n  iframe.style.border = 'none';\\n  iframe.style.zIndex = 9999999999;\\n  iframe.onload = onIframeLoad;\\n  return iframe;\\n}\\n\\nfunction addOverlayDivTo(iframe) {\\n  var div = iframe.contentDocument.createElement('div');\\n  div.id = 'webpack-dev-server-client-overlay-div';\\n  div.style.position = 'fixed';\\n  div.style.boxSizing = 'border-box';\\n  div.style.left = 0;\\n  div.style.top = 0;\\n  div.style.right = 0;\\n  div.style.bottom = 0;\\n  div.style.width = '100vw';\\n  div.style.height = '100vh';\\n  div.style.backgroundColor = 'rgba(0, 0, 0, 0.85)';\\n  div.style.color = '#E8E8E8';\\n  div.style.fontFamily = 'Menlo, Consolas, monospace';\\n  div.style.fontSize = 'large';\\n  div.style.padding = '2rem';\\n  div.style.lineHeight = '1.2';\\n  div.style.whiteSpace = 'pre-wrap';\\n  div.style.overflow = 'auto';\\n  iframe.contentDocument.body.appendChild(div);\\n  return div;\\n}\\n\\nvar overlayIframe = null;\\nvar overlayDiv = null;\\nvar lastOnOverlayDivReady = null;\\n\\nfunction ensureOverlayDivExists(onOverlayDivReady) {\\n  if (overlayDiv) {\\n    // Everything is ready, call the callback right away.\\n    onOverlayDivReady(overlayDiv);\\n    return;\\n  }\\n\\n  // Creating an iframe may be asynchronous so we'll schedule the callback.\\n  // In case of multiple calls, last callback wins.\\n  lastOnOverlayDivReady = onOverlayDivReady;\\n\\n  if (overlayIframe) {\\n    // We're already creating it.\\n    return;\\n  }\\n\\n  // Create iframe and, when it is ready, a div inside it.\\n  overlayIframe = createOverlayIframe(function () {\\n    overlayDiv = addOverlayDivTo(overlayIframe);\\n    // Now we can talk!\\n    lastOnOverlayDivReady(overlayDiv);\\n  });\\n\\n  // Zalgo alert: onIframeLoad() will be called either synchronously\\n  // or asynchronously depending on the browser.\\n  // We delay adding it so `overlayIframe` is set when `onIframeLoad` fires.\\n  document.body.appendChild(overlayIframe);\\n}\\n\\nfunction showMessageOverlay(message) {\\n  ensureOverlayDivExists(function (div) {\\n    // Make it look similar to our terminal.\\n    div.innerHTML = '<span style=\\\"color: #' + colors.red + '\\\">Failed to compile.</span><br><br>' + ansiHTML(entities.encode(message));\\n  });\\n}\\n\\nfunction destroyErrorOverlay() {\\n  if (!overlayDiv) {\\n    // It is not there in the first place.\\n    return;\\n  }\\n\\n  // Clean up and reset internal state.\\n  document.body.removeChild(overlayIframe);\\n  overlayDiv = null;\\n  overlayIframe = null;\\n  lastOnOverlayDivReady = null;\\n}\\n\\n// Successful compilation.\\nexports.clear = function handleSuccess() {\\n  destroyErrorOverlay();\\n};\\n\\n// Compilation with errors (e.g. syntax error or missing modules).\\nexports.showMessage = function handleMessage(messages) {\\n  showMessageOverlay(messages[0]);\\n};//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvY2xpZW50L292ZXJsYXkuanM/MmFjNiJdLCJuYW1lcyI6WyJhbnNpSFRNTCIsInJlcXVpcmUiLCJFbnRpdGllcyIsIkFsbEh0bWxFbnRpdGllcyIsImVudGl0aWVzIiwiY29sb3JzIiwicmVzZXQiLCJibGFjayIsInJlZCIsImdyZWVuIiwieWVsbG93IiwiYmx1ZSIsIm1hZ2VudGEiLCJjeWFuIiwibGlnaHRncmV5IiwiZGFya2dyZXkiLCJzZXRDb2xvcnMiLCJjcmVhdGVPdmVybGF5SWZyYW1lIiwib25JZnJhbWVMb2FkIiwiaWZyYW1lIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiaWQiLCJzcmMiLCJzdHlsZSIsInBvc2l0aW9uIiwibGVmdCIsInRvcCIsInJpZ2h0IiwiYm90dG9tIiwid2lkdGgiLCJoZWlnaHQiLCJib3JkZXIiLCJ6SW5kZXgiLCJvbmxvYWQiLCJhZGRPdmVybGF5RGl2VG8iLCJkaXYiLCJjb250ZW50RG9jdW1lbnQiLCJib3hTaXppbmciLCJiYWNrZ3JvdW5kQ29sb3IiLCJjb2xvciIsImZvbnRGYW1pbHkiLCJmb250U2l6ZSIsInBhZGRpbmciLCJsaW5lSGVpZ2h0Iiwid2hpdGVTcGFjZSIsIm92ZXJmbG93IiwiYm9keSIsImFwcGVuZENoaWxkIiwib3ZlcmxheUlmcmFtZSIsIm92ZXJsYXlEaXYiLCJsYXN0T25PdmVybGF5RGl2UmVhZHkiLCJlbnN1cmVPdmVybGF5RGl2RXhpc3RzIiwib25PdmVybGF5RGl2UmVhZHkiLCJzaG93TWVzc2FnZU92ZXJsYXkiLCJtZXNzYWdlIiwiaW5uZXJIVE1MIiwiZW5jb2RlIiwiZGVzdHJveUVycm9yT3ZlcmxheSIsInJlbW92ZUNoaWxkIiwiZXhwb3J0cyIsImNsZWFyIiwiaGFuZGxlU3VjY2VzcyIsInNob3dNZXNzYWdlIiwiaGFuZGxlTWVzc2FnZSIsIm1lc3NhZ2VzIl0sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBOztB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QUZEIiwiZmlsZSI6IjE2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxuLy8gVGhlIGVycm9yIG92ZXJsYXkgaXMgaW5zcGlyZWQgKGFuZCBtb3N0bHkgY29waWVkKSBmcm9tIENyZWF0ZSBSZWFjdCBBcHAgKGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9va2luY3ViYXRvci9jcmVhdGUtcmVhY3QtYXBwKVxyXG4vLyBUaGV5LCBpbiB0dXJuLCBnb3QgaW5zcGlyZWQgYnkgd2VicGFjay1ob3QtbWlkZGxld2FyZSAoaHR0cHM6Ly9naXRodWIuY29tL2dsZW5qYW1pbi93ZWJwYWNrLWhvdC1taWRkbGV3YXJlKS5cclxuXHJcbnZhciBhbnNpSFRNTCA9IHJlcXVpcmUoJ2Fuc2ktaHRtbCcpO1xyXG52YXIgRW50aXRpZXMgPSByZXF1aXJlKCdodG1sLWVudGl0aWVzJykuQWxsSHRtbEVudGl0aWVzO1xyXG5cclxudmFyIGVudGl0aWVzID0gbmV3IEVudGl0aWVzKCk7XHJcblxyXG52YXIgY29sb3JzID0ge1xyXG4gIHJlc2V0OiBbJ3RyYW5zcGFyZW50JywgJ3RyYW5zcGFyZW50J10sXHJcbiAgYmxhY2s6ICcxODE4MTgnLFxyXG4gIHJlZDogJ0UzNjA0OScsXHJcbiAgZ3JlZW46ICdCM0NCNzQnLFxyXG4gIHllbGxvdzogJ0ZGRDA4MCcsXHJcbiAgYmx1ZTogJzdDQUZDMicsXHJcbiAgbWFnZW50YTogJzdGQUNDQScsXHJcbiAgY3lhbjogJ0MzQzJFRicsXHJcbiAgbGlnaHRncmV5OiAnRUJFN0UzJyxcclxuICBkYXJrZ3JleTogJzZENzg5MSdcclxufTtcclxuYW5zaUhUTUwuc2V0Q29sb3JzKGNvbG9ycyk7XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVPdmVybGF5SWZyYW1lKG9uSWZyYW1lTG9hZCkge1xyXG4gIHZhciBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcclxuICBpZnJhbWUuaWQgPSAnd2VicGFjay1kZXYtc2VydmVyLWNsaWVudC1vdmVybGF5JztcclxuICBpZnJhbWUuc3JjID0gJ2Fib3V0OmJsYW5rJztcclxuICBpZnJhbWUuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xyXG4gIGlmcmFtZS5zdHlsZS5sZWZ0ID0gMDtcclxuICBpZnJhbWUuc3R5bGUudG9wID0gMDtcclxuICBpZnJhbWUuc3R5bGUucmlnaHQgPSAwO1xyXG4gIGlmcmFtZS5zdHlsZS5ib3R0b20gPSAwO1xyXG4gIGlmcmFtZS5zdHlsZS53aWR0aCA9ICcxMDB2dyc7XHJcbiAgaWZyYW1lLnN0eWxlLmhlaWdodCA9ICcxMDB2aCc7XHJcbiAgaWZyYW1lLnN0eWxlLmJvcmRlciA9ICdub25lJztcclxuICBpZnJhbWUuc3R5bGUuekluZGV4ID0gOTk5OTk5OTk5OTtcclxuICBpZnJhbWUub25sb2FkID0gb25JZnJhbWVMb2FkO1xyXG4gIHJldHVybiBpZnJhbWU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZE92ZXJsYXlEaXZUbyhpZnJhbWUpIHtcclxuICB2YXIgZGl2ID0gaWZyYW1lLmNvbnRlbnREb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICBkaXYuaWQgPSAnd2VicGFjay1kZXYtc2VydmVyLWNsaWVudC1vdmVybGF5LWRpdic7XHJcbiAgZGl2LnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcclxuICBkaXYuc3R5bGUuYm94U2l6aW5nID0gJ2JvcmRlci1ib3gnO1xyXG4gIGRpdi5zdHlsZS5sZWZ0ID0gMDtcclxuICBkaXYuc3R5bGUudG9wID0gMDtcclxuICBkaXYuc3R5bGUucmlnaHQgPSAwO1xyXG4gIGRpdi5zdHlsZS5ib3R0b20gPSAwO1xyXG4gIGRpdi5zdHlsZS53aWR0aCA9ICcxMDB2dyc7XHJcbiAgZGl2LnN0eWxlLmhlaWdodCA9ICcxMDB2aCc7XHJcbiAgZGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICdyZ2JhKDAsIDAsIDAsIDAuODUpJztcclxuICBkaXYuc3R5bGUuY29sb3IgPSAnI0U4RThFOCc7XHJcbiAgZGl2LnN0eWxlLmZvbnRGYW1pbHkgPSAnTWVubG8sIENvbnNvbGFzLCBtb25vc3BhY2UnO1xyXG4gIGRpdi5zdHlsZS5mb250U2l6ZSA9ICdsYXJnZSc7XHJcbiAgZGl2LnN0eWxlLnBhZGRpbmcgPSAnMnJlbSc7XHJcbiAgZGl2LnN0eWxlLmxpbmVIZWlnaHQgPSAnMS4yJztcclxuICBkaXYuc3R5bGUud2hpdGVTcGFjZSA9ICdwcmUtd3JhcCc7XHJcbiAgZGl2LnN0eWxlLm92ZXJmbG93ID0gJ2F1dG8nO1xyXG4gIGlmcmFtZS5jb250ZW50RG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpO1xyXG4gIHJldHVybiBkaXY7XHJcbn1cclxuXHJcbnZhciBvdmVybGF5SWZyYW1lID0gbnVsbDtcclxudmFyIG92ZXJsYXlEaXYgPSBudWxsO1xyXG52YXIgbGFzdE9uT3ZlcmxheURpdlJlYWR5ID0gbnVsbDtcclxuXHJcbmZ1bmN0aW9uIGVuc3VyZU92ZXJsYXlEaXZFeGlzdHMob25PdmVybGF5RGl2UmVhZHkpIHtcclxuICBpZiAob3ZlcmxheURpdikge1xyXG4gICAgLy8gRXZlcnl0aGluZyBpcyByZWFkeSwgY2FsbCB0aGUgY2FsbGJhY2sgcmlnaHQgYXdheS5cclxuICAgIG9uT3ZlcmxheURpdlJlYWR5KG92ZXJsYXlEaXYpO1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgLy8gQ3JlYXRpbmcgYW4gaWZyYW1lIG1heSBiZSBhc3luY2hyb25vdXMgc28gd2UnbGwgc2NoZWR1bGUgdGhlIGNhbGxiYWNrLlxyXG4gIC8vIEluIGNhc2Ugb2YgbXVsdGlwbGUgY2FsbHMsIGxhc3QgY2FsbGJhY2sgd2lucy5cclxuICBsYXN0T25PdmVybGF5RGl2UmVhZHkgPSBvbk92ZXJsYXlEaXZSZWFkeTtcclxuXHJcbiAgaWYgKG92ZXJsYXlJZnJhbWUpIHtcclxuICAgIC8vIFdlJ3JlIGFscmVhZHkgY3JlYXRpbmcgaXQuXHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICAvLyBDcmVhdGUgaWZyYW1lIGFuZCwgd2hlbiBpdCBpcyByZWFkeSwgYSBkaXYgaW5zaWRlIGl0LlxyXG4gIG92ZXJsYXlJZnJhbWUgPSBjcmVhdGVPdmVybGF5SWZyYW1lKGZ1bmN0aW9uICgpIHtcclxuICAgIG92ZXJsYXlEaXYgPSBhZGRPdmVybGF5RGl2VG8ob3ZlcmxheUlmcmFtZSk7XHJcbiAgICAvLyBOb3cgd2UgY2FuIHRhbGshXHJcbiAgICBsYXN0T25PdmVybGF5RGl2UmVhZHkob3ZlcmxheURpdik7XHJcbiAgfSk7XHJcblxyXG4gIC8vIFphbGdvIGFsZXJ0OiBvbklmcmFtZUxvYWQoKSB3aWxsIGJlIGNhbGxlZCBlaXRoZXIgc3luY2hyb25vdXNseVxyXG4gIC8vIG9yIGFzeW5jaHJvbm91c2x5IGRlcGVuZGluZyBvbiB0aGUgYnJvd3Nlci5cclxuICAvLyBXZSBkZWxheSBhZGRpbmcgaXQgc28gYG92ZXJsYXlJZnJhbWVgIGlzIHNldCB3aGVuIGBvbklmcmFtZUxvYWRgIGZpcmVzLlxyXG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQob3ZlcmxheUlmcmFtZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNob3dNZXNzYWdlT3ZlcmxheShtZXNzYWdlKSB7XHJcbiAgZW5zdXJlT3ZlcmxheURpdkV4aXN0cyhmdW5jdGlvbiAoZGl2KSB7XHJcbiAgICAvLyBNYWtlIGl0IGxvb2sgc2ltaWxhciB0byBvdXIgdGVybWluYWwuXHJcbiAgICBkaXYuaW5uZXJIVE1MID0gJzxzcGFuIHN0eWxlPVwiY29sb3I6ICMnICsgY29sb3JzLnJlZCArICdcIj5GYWlsZWQgdG8gY29tcGlsZS48L3NwYW4+PGJyPjxicj4nICsgYW5zaUhUTUwoZW50aXRpZXMuZW5jb2RlKG1lc3NhZ2UpKTtcclxuICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gZGVzdHJveUVycm9yT3ZlcmxheSgpIHtcclxuICBpZiAoIW92ZXJsYXlEaXYpIHtcclxuICAgIC8vIEl0IGlzIG5vdCB0aGVyZSBpbiB0aGUgZmlyc3QgcGxhY2UuXHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICAvLyBDbGVhbiB1cCBhbmQgcmVzZXQgaW50ZXJuYWwgc3RhdGUuXHJcbiAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChvdmVybGF5SWZyYW1lKTtcclxuICBvdmVybGF5RGl2ID0gbnVsbDtcclxuICBvdmVybGF5SWZyYW1lID0gbnVsbDtcclxuICBsYXN0T25PdmVybGF5RGl2UmVhZHkgPSBudWxsO1xyXG59XHJcblxyXG4vLyBTdWNjZXNzZnVsIGNvbXBpbGF0aW9uLlxyXG5leHBvcnRzLmNsZWFyID0gZnVuY3Rpb24gaGFuZGxlU3VjY2VzcygpIHtcclxuICBkZXN0cm95RXJyb3JPdmVybGF5KCk7XHJcbn07XHJcblxyXG4vLyBDb21waWxhdGlvbiB3aXRoIGVycm9ycyAoZS5nLiBzeW50YXggZXJyb3Igb3IgbWlzc2luZyBtb2R1bGVzKS5cclxuZXhwb3J0cy5zaG93TWVzc2FnZSA9IGZ1bmN0aW9uIGhhbmRsZU1lc3NhZ2UobWVzc2FnZXMpIHtcclxuICBzaG93TWVzc2FnZU92ZXJsYXkobWVzc2FnZXNbMF0pO1xyXG59OyJdLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///16\\n\")},function(module,exports){eval(\"throw new Error(\\\"Module build failed (from ./node_modules/babel-loader/lib/index.js):\\\\nError: ENOENT: no such file or directory, open 'C:\\\\\\\\Users\\\\\\\\DENN_\\\\\\\\OneDrive\\\\\\\\\\\\\\\\GitHub\\\\\\\\JavaScript2\\\\\\\\Dz-7\\\\\\\\node_modules\\\\\\\\ansi-html\\\\\\\\index.js'\\\");//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiIxNy5qcyIsInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///17\\n\")},function(module,exports){eval(\"throw new Error(\\\"Module build failed (from ./node_modules/babel-loader/lib/index.js):\\\\nError: ENOENT: no such file or directory, open 'C:\\\\\\\\Users\\\\\\\\DENN_\\\\\\\\OneDrive\\\\\\\\\\\\\\\\GitHub\\\\\\\\JavaScript2\\\\\\\\Dz-7\\\\\\\\node_modules\\\\\\\\html-entities\\\\\\\\index.js'\\\");//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiIxOC5qcyIsInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///18\\n\")},,,function(module,exports,__webpack_require__){eval('var map = {\\n\\t\"./log\": 22\\n};\\n\\n\\nfunction webpackContext(req) {\\n\\tvar id = webpackContextResolve(req);\\n\\treturn __webpack_require__(id);\\n}\\nfunction webpackContextResolve(req) {\\n\\tvar id = map[req];\\n\\tif(!(id + 1)) { // check for number or string\\n\\t\\tvar e = new Error(\"Cannot find module \\'\" + req + \"\\'\");\\n\\t\\te.code = \\'MODULE_NOT_FOUND\\';\\n\\t\\tthrow e;\\n\\t}\\n\\treturn id;\\n}\\nwebpackContext.keys = function webpackContextKeys() {\\n\\treturn Object.keys(map);\\n};\\nwebpackContext.resolve = webpackContextResolve;\\nmodule.exports = webpackContext;\\nwebpackContext.id = 21;//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2hvdCBzeW5jIG5vbnJlY3Vyc2l2ZSBeXFwuXFwvbG9nJD8xYzNkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIyMS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBtYXAgPSB7XG5cdFwiLi9sb2dcIjogMjJcbn07XG5cblxuZnVuY3Rpb24gd2VicGFja0NvbnRleHQocmVxKSB7XG5cdHZhciBpZCA9IHdlYnBhY2tDb250ZXh0UmVzb2x2ZShyZXEpO1xuXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhpZCk7XG59XG5mdW5jdGlvbiB3ZWJwYWNrQ29udGV4dFJlc29sdmUocmVxKSB7XG5cdHZhciBpZCA9IG1hcFtyZXFdO1xuXHRpZighKGlkICsgMSkpIHsgLy8gY2hlY2sgZm9yIG51bWJlciBvciBzdHJpbmdcblx0XHR2YXIgZSA9IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIgKyByZXEgKyBcIidcIik7XG5cdFx0ZS5jb2RlID0gJ01PRFVMRV9OT1RfRk9VTkQnO1xuXHRcdHRocm93IGU7XG5cdH1cblx0cmV0dXJuIGlkO1xufVxud2VicGFja0NvbnRleHQua2V5cyA9IGZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0S2V5cygpIHtcblx0cmV0dXJuIE9iamVjdC5rZXlzKG1hcCk7XG59O1xud2VicGFja0NvbnRleHQucmVzb2x2ZSA9IHdlYnBhY2tDb250ZXh0UmVzb2x2ZTtcbm1vZHVsZS5leHBvcnRzID0gd2VicGFja0NvbnRleHQ7XG53ZWJwYWNrQ29udGV4dC5pZCA9IDIxOyJdLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///21\\n')},function(module,exports){eval('var logLevel = \"info\";\\n\\nfunction dummy() {}\\n\\nfunction shouldLog(level) {\\n\\tvar shouldLog = logLevel === \"info\" && level === \"info\" || [\"info\", \"warning\"].indexOf(logLevel) >= 0 && level === \"warning\" || [\"info\", \"warning\", \"error\"].indexOf(logLevel) >= 0 && level === \"error\";\\n\\treturn shouldLog;\\n}\\n\\nfunction logGroup(logFn) {\\n\\treturn function (level, msg) {\\n\\t\\tif (shouldLog(level)) {\\n\\t\\t\\tlogFn(msg);\\n\\t\\t}\\n\\t};\\n}\\n\\nmodule.exports = function (level, msg) {\\n\\tif (shouldLog(level)) {\\n\\t\\tif (level === \"info\") {\\n\\t\\t\\tconsole.log(msg);\\n\\t\\t} else if (level === \"warning\") {\\n\\t\\t\\tconsole.warn(msg);\\n\\t\\t} else if (level === \"error\") {\\n\\t\\t\\tconsole.error(msg);\\n\\t\\t}\\n\\t}\\n};\\n\\n/* eslint-disable node/no-unsupported-features/node-builtins */\\nvar group = console.group || dummy;\\nvar groupCollapsed = console.groupCollapsed || dummy;\\nvar groupEnd = console.groupEnd || dummy;\\n/* eslint-enable node/no-unsupported-features/node-builtins */\\n\\nmodule.exports.group = logGroup(group);\\n\\nmodule.exports.groupCollapsed = logGroup(groupCollapsed);\\n\\nmodule.exports.groupEnd = logGroup(groupEnd);\\n\\nmodule.exports.setLogLevel = function (level) {\\n\\tlogLevel = level;\\n};//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2hvdC9sb2cuanM/MWFmZCJdLCJuYW1lcyI6WyJsb2dMZXZlbCIsImR1bW15Iiwic2hvdWxkTG9nIiwibGV2ZWwiLCJpbmRleE9mIiwibG9nR3JvdXAiLCJsb2dGbiIsIm1zZyIsIm1vZHVsZSIsImV4cG9ydHMiLCJjb25zb2xlIiwibG9nIiwid2FybiIsImVycm9yIiwiZ3JvdXAiLCJncm91cENvbGxhcHNlZCIsImdyb3VwRW5kIiwic2V0TG9nTGV2ZWwiXSwibWFwcGluZ3MiOiJBQUFBLElBQUlBLFdBQVcsTUFBZjs7QUFFQSxTQUFTQyxLQUFULEdBQWlCLENBQUU7O0FBRW5CLFNBQVNDLFNBQVQsQ0FBbUJDLEtBQW5CLEVBQTBCO0FBQ3pCLEtBQUlELFlBQ0ZGLGFBQWEsTUFBYixJQUF1QkcsVUFBVSxNQUFsQyxJQUNDLENBQUMsTUFBRCxFQUFTLFNBQVQsRUFBb0JDLE9BQXBCLENBQTRCSixRQUE1QixLQUF5QyxDQUF6QyxJQUE4Q0csVUFBVSxTQUR6RCxJQUVDLENBQUMsTUFBRCxFQUFTLFNBQVQsRUFBb0IsT0FBcEIsRUFBNkJDLE9BQTdCLENBQXFDSixRQUFyQyxLQUFrRCxDQUFsRCxJQUF1REcsVUFBVSxPQUhuRTtBQUlBLFFBQU9ELFNBQVA7QUFDQTs7QUFFRCxTQUFTRyxRQUFULENBQWtCQyxLQUFsQixFQUF5QjtBQUN4QixRQUFPLFVBQVNILEtBQVQsRUFBZ0JJLEdBQWhCLEVBQXFCO0FBQzNCLE1BQUlMLFVBQVVDLEtBQVYsQ0FBSixFQUFzQjtBQUNyQkcsU0FBTUMsR0FBTjtBQUNBO0FBQ0QsRUFKRDtBQUtBOztBQUVEQyxPQUFPQyxPQUFQLEdBQWlCLFVBQVNOLEtBQVQsRUFBZ0JJLEdBQWhCLEVBQXFCO0FBQ3JDLEtBQUlMLFVBQVVDLEtBQVYsQ0FBSixFQUFzQjtBQUNyQixNQUFJQSxVQUFVLE1BQWQsRUFBc0I7QUFDckJPLFdBQVFDLEdBQVIsQ0FBWUosR0FBWjtBQUNBLEdBRkQsTUFFTyxJQUFJSixVQUFVLFNBQWQsRUFBeUI7QUFDL0JPLFdBQVFFLElBQVIsQ0FBYUwsR0FBYjtBQUNBLEdBRk0sTUFFQSxJQUFJSixVQUFVLE9BQWQsRUFBdUI7QUFDN0JPLFdBQVFHLEtBQVIsQ0FBY04sR0FBZDtBQUNBO0FBQ0Q7QUFDRCxDQVZEOztBQVlBO0FBQ0EsSUFBSU8sUUFBUUosUUFBUUksS0FBUixJQUFpQmIsS0FBN0I7QUFDQSxJQUFJYyxpQkFBaUJMLFFBQVFLLGNBQVIsSUFBMEJkLEtBQS9DO0FBQ0EsSUFBSWUsV0FBV04sUUFBUU0sUUFBUixJQUFvQmYsS0FBbkM7QUFDQTs7QUFFQU8sT0FBT0MsT0FBUCxDQUFlSyxLQUFmLEdBQXVCVCxTQUFTUyxLQUFULENBQXZCOztBQUVBTixPQUFPQyxPQUFQLENBQWVNLGNBQWYsR0FBZ0NWLFNBQVNVLGNBQVQsQ0FBaEM7O0FBRUFQLE9BQU9DLE9BQVAsQ0FBZU8sUUFBZixHQUEwQlgsU0FBU1csUUFBVCxDQUExQjs7QUFFQVIsT0FBT0MsT0FBUCxDQUFlUSxXQUFmLEdBQTZCLFVBQVNkLEtBQVQsRUFBZ0I7QUFDNUNILFlBQVdHLEtBQVg7QUFDQSxDQUZEIiwiZmlsZSI6IjIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGxvZ0xldmVsID0gXCJpbmZvXCI7XHJcblxyXG5mdW5jdGlvbiBkdW1teSgpIHt9XHJcblxyXG5mdW5jdGlvbiBzaG91bGRMb2cobGV2ZWwpIHtcclxuXHR2YXIgc2hvdWxkTG9nID1cclxuXHRcdChsb2dMZXZlbCA9PT0gXCJpbmZvXCIgJiYgbGV2ZWwgPT09IFwiaW5mb1wiKSB8fFxyXG5cdFx0KFtcImluZm9cIiwgXCJ3YXJuaW5nXCJdLmluZGV4T2YobG9nTGV2ZWwpID49IDAgJiYgbGV2ZWwgPT09IFwid2FybmluZ1wiKSB8fFxyXG5cdFx0KFtcImluZm9cIiwgXCJ3YXJuaW5nXCIsIFwiZXJyb3JcIl0uaW5kZXhPZihsb2dMZXZlbCkgPj0gMCAmJiBsZXZlbCA9PT0gXCJlcnJvclwiKTtcclxuXHRyZXR1cm4gc2hvdWxkTG9nO1xyXG59XHJcblxyXG5mdW5jdGlvbiBsb2dHcm91cChsb2dGbikge1xyXG5cdHJldHVybiBmdW5jdGlvbihsZXZlbCwgbXNnKSB7XHJcblx0XHRpZiAoc2hvdWxkTG9nKGxldmVsKSkge1xyXG5cdFx0XHRsb2dGbihtc2cpO1xyXG5cdFx0fVxyXG5cdH07XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGV2ZWwsIG1zZykge1xyXG5cdGlmIChzaG91bGRMb2cobGV2ZWwpKSB7XHJcblx0XHRpZiAobGV2ZWwgPT09IFwiaW5mb1wiKSB7XHJcblx0XHRcdGNvbnNvbGUubG9nKG1zZyk7XHJcblx0XHR9IGVsc2UgaWYgKGxldmVsID09PSBcIndhcm5pbmdcIikge1xyXG5cdFx0XHRjb25zb2xlLndhcm4obXNnKTtcclxuXHRcdH0gZWxzZSBpZiAobGV2ZWwgPT09IFwiZXJyb3JcIikge1xyXG5cdFx0XHRjb25zb2xlLmVycm9yKG1zZyk7XHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG5cclxuLyogZXNsaW50LWRpc2FibGUgbm9kZS9uby11bnN1cHBvcnRlZC1mZWF0dXJlcy9ub2RlLWJ1aWx0aW5zICovXHJcbnZhciBncm91cCA9IGNvbnNvbGUuZ3JvdXAgfHwgZHVtbXk7XHJcbnZhciBncm91cENvbGxhcHNlZCA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQgfHwgZHVtbXk7XHJcbnZhciBncm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQgfHwgZHVtbXk7XHJcbi8qIGVzbGludC1lbmFibGUgbm9kZS9uby11bnN1cHBvcnRlZC1mZWF0dXJlcy9ub2RlLWJ1aWx0aW5zICovXHJcblxyXG5tb2R1bGUuZXhwb3J0cy5ncm91cCA9IGxvZ0dyb3VwKGdyb3VwKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzLmdyb3VwQ29sbGFwc2VkID0gbG9nR3JvdXAoZ3JvdXBDb2xsYXBzZWQpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMuZ3JvdXBFbmQgPSBsb2dHcm91cChncm91cEVuZCk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cy5zZXRMb2dMZXZlbCA9IGZ1bmN0aW9uKGxldmVsKSB7XHJcblx0bG9nTGV2ZWwgPSBsZXZlbDtcclxufTtcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///22\\n')},function(module,exports,__webpack_require__){eval(\"var EventEmitter = __webpack_require__(24);\\nmodule.exports = new EventEmitter();//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2hvdC9lbWl0dGVyLmpzP2E2YmQiXSwibmFtZXMiOlsiRXZlbnRFbWl0dGVyIiwicmVxdWlyZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiJBQUFBLElBQUlBLGVBQWVDLG1CQUFPQSxDQUFDLEVBQVIsQ0FBbkI7QUFDQUMsT0FBT0MsT0FBUCxHQUFpQixJQUFJSCxZQUFKLEVBQWpCIiwiZmlsZSI6IjIzLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoXCJldmVudHNcIik7XHJcbm1vZHVsZS5leHBvcnRzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4iXSwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///23\\n\")},function(module,exports){eval(\"throw new Error(\\\"Module build failed (from ./node_modules/babel-loader/lib/index.js):\\\\nError: ENOENT: no such file or directory, open 'C:\\\\\\\\Users\\\\\\\\DENN_\\\\\\\\OneDrive\\\\\\\\\\\\\\\\GitHub\\\\\\\\JavaScript2\\\\\\\\Dz-7\\\\\\\\node_modules\\\\\\\\events\\\\\\\\package.json'\\\\n    at Object.fs.openSync (fs.js:646:18)\\\\n    at Object.fs.readFileSync (fs.js:551:33)\\\\n    at ConfigChainBuilder.addConfig (C:\\\\\\\\Users\\\\\\\\DENN_\\\\\\\\OneDrive\\\\\\\\\\\\\\\\GitHub\\\\\\\\JavaScript2\\\\\\\\Dz-7\\\\\\\\node_modules\\\\\\\\babel-core\\\\\\\\lib\\\\\\\\transformation\\\\\\\\file\\\\\\\\options\\\\\\\\build-config-chain.js:146:32)\\\\n    at ConfigChainBuilder.findConfigs (C:\\\\\\\\Users\\\\\\\\DENN_\\\\\\\\OneDrive\\\\\\\\\\\\\\\\GitHub\\\\\\\\JavaScript2\\\\\\\\Dz-7\\\\\\\\node_modules\\\\\\\\babel-core\\\\\\\\lib\\\\\\\\transformation\\\\\\\\file\\\\\\\\options\\\\\\\\build-config-chain.js:102:30)\\\\n    at buildConfigChain (C:\\\\\\\\Users\\\\\\\\DENN_\\\\\\\\OneDrive\\\\\\\\\\\\\\\\GitHub\\\\\\\\JavaScript2\\\\\\\\Dz-7\\\\\\\\node_modules\\\\\\\\babel-core\\\\\\\\lib\\\\\\\\transformation\\\\\\\\file\\\\\\\\options\\\\\\\\build-config-chain.js:61:13)\\\\n    at OptionManager.init (C:\\\\\\\\Users\\\\\\\\DENN_\\\\\\\\OneDrive\\\\\\\\\\\\\\\\GitHub\\\\\\\\JavaScript2\\\\\\\\Dz-7\\\\\\\\node_modules\\\\\\\\babel-core\\\\\\\\lib\\\\\\\\transformation\\\\\\\\file\\\\\\\\options\\\\\\\\option-manager.js:354:58)\\\\n    at File.initOptions (C:\\\\\\\\Users\\\\\\\\DENN_\\\\\\\\OneDrive\\\\\\\\\\\\\\\\GitHub\\\\\\\\JavaScript2\\\\\\\\Dz-7\\\\\\\\node_modules\\\\\\\\babel-core\\\\\\\\lib\\\\\\\\transformation\\\\\\\\file\\\\\\\\index.js:212:65)\\\\n    at new File (C:\\\\\\\\Users\\\\\\\\DENN_\\\\\\\\OneDrive\\\\\\\\\\\\\\\\GitHub\\\\\\\\JavaScript2\\\\\\\\Dz-7\\\\\\\\node_modules\\\\\\\\babel-core\\\\\\\\lib\\\\\\\\transformation\\\\\\\\file\\\\\\\\index.js:135:24)\\\\n    at Pipeline.transform (C:\\\\\\\\Users\\\\\\\\DENN_\\\\\\\\OneDrive\\\\\\\\\\\\\\\\GitHub\\\\\\\\JavaScript2\\\\\\\\Dz-7\\\\\\\\node_modules\\\\\\\\babel-core\\\\\\\\lib\\\\\\\\transformation\\\\\\\\pipeline.js:46:16)\\\\n    at transpile (C:\\\\\\\\Users\\\\\\\\DENN_\\\\\\\\OneDrive\\\\\\\\\\\\\\\\GitHub\\\\\\\\JavaScript2\\\\\\\\Dz-7\\\\\\\\node_modules\\\\\\\\babel-loader\\\\\\\\lib\\\\\\\\index.js:50:20)\\\\n    at Object.module.exports (C:\\\\\\\\Users\\\\\\\\DENN_\\\\\\\\OneDrive\\\\\\\\\\\\\\\\GitHub\\\\\\\\JavaScript2\\\\\\\\Dz-7\\\\\\\\node_modules\\\\\\\\babel-loader\\\\\\\\lib\\\\\\\\index.js:173:20)\\\");//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiIyNC5qcyIsInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///24\\n\")},function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony import */ var _index_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(26);\\n/* harmony import */ var _index_html__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_index_html__WEBPACK_IMPORTED_MODULE_0__);\\n/* harmony import */ var _css_style_scss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(27);\\n/* harmony import */ var _css_style_scss__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_style_scss__WEBPACK_IMPORTED_MODULE_1__);\\n//import $ from \\\"jquery\\\";\\n\\n\\n//import \\\"./index.html\\\";/// ?????????????\\n\\n//$(function () {\\n//    $('.test').html('jqueryTest');\\n//});\\n\\nlet b = 8;\\nconsole.log(b);//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanM/YjYzNSJdLCJuYW1lcyI6WyJiIiwiY29uc29sZSIsImxvZyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQyxJQUFJQSxJQUFHLENBQVA7QUFDQUMsUUFBUUMsR0FBUixDQUFZRixDQUFaIiwiZmlsZSI6IjI1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy9pbXBvcnQgJCBmcm9tIFwianF1ZXJ5XCI7XHJcbmltcG9ydCBcIi4uL2luZGV4Lmh0bWxcIjtcclxuaW1wb3J0IFwiLi9jc3Mvc3R5bGUuc2Nzc1wiO1xyXG4vL2ltcG9ydCBcIi4vaW5kZXguaHRtbFwiOy8vLyA/Pz8/Pz8/Pz8/Pz8/XHJcblxyXG4vLyQoZnVuY3Rpb24gKCkge1xyXG4vLyAgICAkKCcudGVzdCcpLmh0bWwoJ2pxdWVyeVRlc3QnKTtcclxuLy99KTtcclxuXHJcblx0bGV0IGIgPTg7XHJcblx0Y29uc29sZS5sb2coYik7XHJcblxyXG4iXSwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///25\\n\")},function(module,exports){eval('module.exports = \"<!DOCTYPE html>\\\\r\\\\n<html>\\\\r\\\\n<head>\\\\r\\\\n    <meta charset=\\\\\"UTF-8\\\\\">\\\\r\\\\n    <title>webpack</title>\\\\r\\\\n    <script src=\\\\\"dist/main.js\\\\\"><\\/script>\\\\r\\\\n</head>\\\\r\\\\n<body>\\\\r\\\\n   <h1 class=\\\\\"test\\\\\"></h1>\\\\r\\\\n   <div class=\\\\\"sass\\\\\">Sass <span class=\\\\\"span\\\\\">test</span></div>\\\\r\\\\n</body>\\\\r\\\\n</html>\";//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9pbmRleC5odG1sPzBjNjciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiMjYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiPCFET0NUWVBFIGh0bWw+XFxyXFxuPGh0bWw+XFxyXFxuPGhlYWQ+XFxyXFxuICAgIDxtZXRhIGNoYXJzZXQ9XFxcIlVURi04XFxcIj5cXHJcXG4gICAgPHRpdGxlPndlYnBhY2s8L3RpdGxlPlxcclxcbiAgICA8c2NyaXB0IHNyYz1cXFwiZGlzdC9tYWluLmpzXFxcIj48L3NjcmlwdD5cXHJcXG48L2hlYWQ+XFxyXFxuPGJvZHk+XFxyXFxuICAgPGgxIGNsYXNzPVxcXCJ0ZXN0XFxcIj48L2gxPlxcclxcbiAgIDxkaXYgY2xhc3M9XFxcInNhc3NcXFwiPlNhc3MgPHNwYW4gY2xhc3M9XFxcInNwYW5cXFwiPnRlc3Q8L3NwYW4+PC9kaXY+XFxyXFxuPC9ib2R5PlxcclxcbjwvaHRtbD5cIjsiXSwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///26\\n')},function(module,exports,__webpack_require__){eval(\"\\nvar content = __webpack_require__(28);\\n\\nif(typeof content === 'string') content = [[module.i, content, '']];\\n\\nvar transform;\\nvar insertInto;\\n\\n\\n\\nvar options = {\\\"hmr\\\":true}\\n\\noptions.transform = transform\\noptions.insertInto = undefined;\\n\\nvar update = __webpack_require__(30)(content, options);\\n\\nif(content.locals) module.exports = content.locals;\\n\\nif(false) {}//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY3NzL3N0eWxlLnNjc3M/ZjdiZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLEVBQW9HOztBQUUxSCw0Q0FBNEMsUUFBUzs7QUFFckQ7QUFDQTs7OztBQUlBLGVBQWU7O0FBRWY7QUFDQTs7QUFFQSxhQUFhLG1CQUFPLENBQUMsRUFBbUQ7O0FBRXhFOztBQUVBLEdBQUcsS0FBVSxFQUFFIiwiZmlsZSI6IjI3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS4vc3R5bGUuc2Nzc1wiKTtcblxuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5cbnZhciB0cmFuc2Zvcm07XG52YXIgaW5zZXJ0SW50bztcblxuXG5cbnZhciBvcHRpb25zID0ge1wiaG1yXCI6dHJ1ZX1cblxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbm9wdGlvbnMuaW5zZXJ0SW50byA9IHVuZGVmaW5lZDtcblxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscztcblxuaWYobW9kdWxlLmhvdCkge1xuXHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi9zdHlsZS5zY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi9zdHlsZS5zY3NzXCIpO1xuXG5cdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cblx0XHR2YXIgbG9jYWxzID0gKGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHZhciBrZXksIGlkeCA9IDA7XG5cblx0XHRcdGZvcihrZXkgaW4gYSkge1xuXHRcdFx0XHRpZighYiB8fCBhW2tleV0gIT09IGJba2V5XSkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRpZHgrKztcblx0XHRcdH1cblxuXHRcdFx0Zm9yKGtleSBpbiBiKSBpZHgtLTtcblxuXHRcdFx0cmV0dXJuIGlkeCA9PT0gMDtcblx0XHR9KGNvbnRlbnQubG9jYWxzLCBuZXdDb250ZW50LmxvY2FscykpO1xuXG5cdFx0aWYoIWxvY2FscykgdGhyb3cgbmV3IEVycm9yKCdBYm9ydGluZyBDU1MgSE1SIGR1ZSB0byBjaGFuZ2VkIGNzcy1tb2R1bGVzIGxvY2Fscy4nKTtcblxuXHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0fSk7XG5cblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59Il0sInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///27\\n\")},function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(29)(false);\\n// imports\\n\\n\\n// module\\nexports.push([module.i, \".sass {\\\\n  color: blue; }\\\\n  .sass .span {\\\\n    color: red; }\\\\n\", \"\"]);\\n\\n// exports\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY3NzL3N0eWxlLnNjc3M/Yzk3YiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSwyQkFBMkIsbUJBQU8sQ0FBQyxFQUErQztBQUNsRjs7O0FBR0E7QUFDQSxjQUFjLFFBQVMsVUFBVSxnQkFBZ0IsRUFBRSxpQkFBaUIsaUJBQWlCLEVBQUU7O0FBRXZGIiwiZmlsZSI6IjI4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKShmYWxzZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIuc2FzcyB7XFxuICBjb2xvcjogYmx1ZTsgfVxcbiAgLnNhc3MgLnNwYW4ge1xcbiAgICBjb2xvcjogcmVkOyB9XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///28\\n')},function(module,exports){eval(\"throw new Error(\\\"Module build failed (from ./node_modules/babel-loader/lib/index.js):\\\\nError: ENOENT: no such file or directory, open 'C:\\\\\\\\Users\\\\\\\\DENN_\\\\\\\\OneDrive\\\\\\\\\\\\\\\\GitHub\\\\\\\\JavaScript2\\\\\\\\Dz-7\\\\\\\\node_modules\\\\\\\\css-loader\\\\\\\\lib\\\\\\\\css-base.js'\\\");//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiIyOS5qcyIsInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///29\\n\")},function(module,exports,__webpack_require__){eval('/*\\r\\n\\tMIT License http://www.opensource.org/licenses/mit-license.php\\r\\n\\tAuthor Tobias Koppers @sokra\\r\\n*/\\r\\n\\r\\nvar stylesInDom = {};\\r\\n\\r\\nvar\\tmemoize = function (fn) {\\r\\n\\tvar memo;\\r\\n\\r\\n\\treturn function () {\\r\\n\\t\\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\\r\\n\\t\\treturn memo;\\r\\n\\t};\\r\\n};\\r\\n\\r\\nvar isOldIE = memoize(function () {\\r\\n\\t// Test for IE <= 9 as proposed by Browserhacks\\r\\n\\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\\r\\n\\t// Tests for existence of standard globals is to allow style-loader\\r\\n\\t// to operate correctly into non-standard environments\\r\\n\\t// @see https://github.com/webpack-contrib/style-loader/issues/177\\r\\n\\treturn window && document && document.all && !window.atob;\\r\\n});\\r\\n\\r\\nvar getTarget = function (target, parent) {\\r\\n  if (parent){\\r\\n    return parent.querySelector(target);\\r\\n  }\\r\\n  return document.querySelector(target);\\r\\n};\\r\\n\\r\\nvar getElement = (function (fn) {\\r\\n\\tvar memo = {};\\r\\n\\r\\n\\treturn function(target, parent) {\\r\\n                // If passing function in options, then use it for resolve \"head\" element.\\r\\n                // Useful for Shadow Root style i.e\\r\\n                // {\\r\\n                //   insertInto: function () { return document.querySelector(\"#foo\").shadowRoot }\\r\\n                // }\\r\\n                if (typeof target === \\'function\\') {\\r\\n                        return target();\\r\\n                }\\r\\n                if (typeof memo[target] === \"undefined\") {\\r\\n\\t\\t\\tvar styleTarget = getTarget.call(this, target, parent);\\r\\n\\t\\t\\t// Special case to return head of iframe instead of iframe itself\\r\\n\\t\\t\\tif (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\\r\\n\\t\\t\\t\\ttry {\\r\\n\\t\\t\\t\\t\\t// This will throw an exception if access to iframe is blocked\\r\\n\\t\\t\\t\\t\\t// due to cross-origin restrictions\\r\\n\\t\\t\\t\\t\\tstyleTarget = styleTarget.contentDocument.head;\\r\\n\\t\\t\\t\\t} catch(e) {\\r\\n\\t\\t\\t\\t\\tstyleTarget = null;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tmemo[target] = styleTarget;\\r\\n\\t\\t}\\r\\n\\t\\treturn memo[target]\\r\\n\\t};\\r\\n})();\\r\\n\\r\\nvar singleton = null;\\r\\nvar\\tsingletonCounter = 0;\\r\\nvar\\tstylesInsertedAtTop = [];\\r\\n\\r\\nvar\\tfixUrls = __webpack_require__(31);\\r\\n\\r\\nmodule.exports = function(list, options) {\\r\\n\\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\\r\\n\\t\\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\\r\\n\\t}\\r\\n\\r\\n\\toptions = options || {};\\r\\n\\r\\n\\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\\r\\n\\r\\n\\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\\r\\n\\t// tags it will allow on a page\\r\\n\\tif (!options.singleton && typeof options.singleton !== \"boolean\") options.singleton = isOldIE();\\r\\n\\r\\n\\t// By default, add <style> tags to the <head> element\\r\\n        if (!options.insertInto) options.insertInto = \"head\";\\r\\n\\r\\n\\t// By default, add <style> tags to the bottom of the target\\r\\n\\tif (!options.insertAt) options.insertAt = \"bottom\";\\r\\n\\r\\n\\tvar styles = listToStyles(list, options);\\r\\n\\r\\n\\taddStylesToDom(styles, options);\\r\\n\\r\\n\\treturn function update (newList) {\\r\\n\\t\\tvar mayRemove = [];\\r\\n\\r\\n\\t\\tfor (var i = 0; i < styles.length; i++) {\\r\\n\\t\\t\\tvar item = styles[i];\\r\\n\\t\\t\\tvar domStyle = stylesInDom[item.id];\\r\\n\\r\\n\\t\\t\\tdomStyle.refs--;\\r\\n\\t\\t\\tmayRemove.push(domStyle);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif(newList) {\\r\\n\\t\\t\\tvar newStyles = listToStyles(newList, options);\\r\\n\\t\\t\\taddStylesToDom(newStyles, options);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfor (var i = 0; i < mayRemove.length; i++) {\\r\\n\\t\\t\\tvar domStyle = mayRemove[i];\\r\\n\\r\\n\\t\\t\\tif(domStyle.refs === 0) {\\r\\n\\t\\t\\t\\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\\r\\n\\r\\n\\t\\t\\t\\tdelete stylesInDom[domStyle.id];\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t};\\r\\n};\\r\\n\\r\\nfunction addStylesToDom (styles, options) {\\r\\n\\tfor (var i = 0; i < styles.length; i++) {\\r\\n\\t\\tvar item = styles[i];\\r\\n\\t\\tvar domStyle = stylesInDom[item.id];\\r\\n\\r\\n\\t\\tif(domStyle) {\\r\\n\\t\\t\\tdomStyle.refs++;\\r\\n\\r\\n\\t\\t\\tfor(var j = 0; j < domStyle.parts.length; j++) {\\r\\n\\t\\t\\t\\tdomStyle.parts[j](item.parts[j]);\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tfor(; j < item.parts.length; j++) {\\r\\n\\t\\t\\t\\tdomStyle.parts.push(addStyle(item.parts[j], options));\\r\\n\\t\\t\\t}\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tvar parts = [];\\r\\n\\r\\n\\t\\t\\tfor(var j = 0; j < item.parts.length; j++) {\\r\\n\\t\\t\\t\\tparts.push(addStyle(item.parts[j], options));\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\r\\n\\r\\nfunction listToStyles (list, options) {\\r\\n\\tvar styles = [];\\r\\n\\tvar newStyles = {};\\r\\n\\r\\n\\tfor (var i = 0; i < list.length; i++) {\\r\\n\\t\\tvar item = list[i];\\r\\n\\t\\tvar id = options.base ? item[0] + options.base : item[0];\\r\\n\\t\\tvar css = item[1];\\r\\n\\t\\tvar media = item[2];\\r\\n\\t\\tvar sourceMap = item[3];\\r\\n\\t\\tvar part = {css: css, media: media, sourceMap: sourceMap};\\r\\n\\r\\n\\t\\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\\r\\n\\t\\telse newStyles[id].parts.push(part);\\r\\n\\t}\\r\\n\\r\\n\\treturn styles;\\r\\n}\\r\\n\\r\\nfunction insertStyleElement (options, style) {\\r\\n\\tvar target = getElement(options.insertInto)\\r\\n\\r\\n\\tif (!target) {\\r\\n\\t\\tthrow new Error(\"Couldn\\'t find a style target. This probably means that the value for the \\'insertInto\\' parameter is invalid.\");\\r\\n\\t}\\r\\n\\r\\n\\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\\r\\n\\r\\n\\tif (options.insertAt === \"top\") {\\r\\n\\t\\tif (!lastStyleElementInsertedAtTop) {\\r\\n\\t\\t\\ttarget.insertBefore(style, target.firstChild);\\r\\n\\t\\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\\r\\n\\t\\t\\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\\r\\n\\t\\t} else {\\r\\n\\t\\t\\ttarget.appendChild(style);\\r\\n\\t\\t}\\r\\n\\t\\tstylesInsertedAtTop.push(style);\\r\\n\\t} else if (options.insertAt === \"bottom\") {\\r\\n\\t\\ttarget.appendChild(style);\\r\\n\\t} else if (typeof options.insertAt === \"object\" && options.insertAt.before) {\\r\\n\\t\\tvar nextSibling = getElement(options.insertAt.before, target);\\r\\n\\t\\ttarget.insertBefore(style, nextSibling);\\r\\n\\t} else {\\r\\n\\t\\tthrow new Error(\"[Style Loader]\\\\n\\\\n Invalid value for parameter \\'insertAt\\' (\\'options.insertAt\\') found.\\\\n Must be \\'top\\', \\'bottom\\', or Object.\\\\n (https://github.com/webpack-contrib/style-loader#insertat)\\\\n\");\\r\\n\\t}\\r\\n}\\r\\n\\r\\nfunction removeStyleElement (style) {\\r\\n\\tif (style.parentNode === null) return false;\\r\\n\\tstyle.parentNode.removeChild(style);\\r\\n\\r\\n\\tvar idx = stylesInsertedAtTop.indexOf(style);\\r\\n\\tif(idx >= 0) {\\r\\n\\t\\tstylesInsertedAtTop.splice(idx, 1);\\r\\n\\t}\\r\\n}\\r\\n\\r\\nfunction createStyleElement (options) {\\r\\n\\tvar style = document.createElement(\"style\");\\r\\n\\r\\n\\tif(options.attrs.type === undefined) {\\r\\n\\t\\toptions.attrs.type = \"text/css\";\\r\\n\\t}\\r\\n\\r\\n\\tif(options.attrs.nonce === undefined) {\\r\\n\\t\\tvar nonce = getNonce();\\r\\n\\t\\tif (nonce) {\\r\\n\\t\\t\\toptions.attrs.nonce = nonce;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\taddAttrs(style, options.attrs);\\r\\n\\tinsertStyleElement(options, style);\\r\\n\\r\\n\\treturn style;\\r\\n}\\r\\n\\r\\nfunction createLinkElement (options) {\\r\\n\\tvar link = document.createElement(\"link\");\\r\\n\\r\\n\\tif(options.attrs.type === undefined) {\\r\\n\\t\\toptions.attrs.type = \"text/css\";\\r\\n\\t}\\r\\n\\toptions.attrs.rel = \"stylesheet\";\\r\\n\\r\\n\\taddAttrs(link, options.attrs);\\r\\n\\tinsertStyleElement(options, link);\\r\\n\\r\\n\\treturn link;\\r\\n}\\r\\n\\r\\nfunction addAttrs (el, attrs) {\\r\\n\\tObject.keys(attrs).forEach(function (key) {\\r\\n\\t\\tel.setAttribute(key, attrs[key]);\\r\\n\\t});\\r\\n}\\r\\n\\r\\nfunction getNonce() {\\r\\n\\tif (false) {}\\r\\n\\r\\n\\treturn __webpack_require__.nc;\\r\\n}\\r\\n\\r\\nfunction addStyle (obj, options) {\\r\\n\\tvar style, update, remove, result;\\r\\n\\r\\n\\t// If a transform function was defined, run it on the css\\r\\n\\tif (options.transform && obj.css) {\\r\\n\\t    result = typeof options.transform === \\'function\\'\\r\\n\\t\\t ? options.transform(obj.css) \\r\\n\\t\\t : options.transform.default(obj.css);\\r\\n\\r\\n\\t    if (result) {\\r\\n\\t    \\t// If transform returns a value, use that instead of the original css.\\r\\n\\t    \\t// This allows running runtime transformations on the css.\\r\\n\\t    \\tobj.css = result;\\r\\n\\t    } else {\\r\\n\\t    \\t// If the transform function returns a falsy value, don\\'t add this css.\\r\\n\\t    \\t// This allows conditional loading of css\\r\\n\\t    \\treturn function() {\\r\\n\\t    \\t\\t// noop\\r\\n\\t    \\t};\\r\\n\\t    }\\r\\n\\t}\\r\\n\\r\\n\\tif (options.singleton) {\\r\\n\\t\\tvar styleIndex = singletonCounter++;\\r\\n\\r\\n\\t\\tstyle = singleton || (singleton = createStyleElement(options));\\r\\n\\r\\n\\t\\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\\r\\n\\t\\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\\r\\n\\r\\n\\t} else if (\\r\\n\\t\\tobj.sourceMap &&\\r\\n\\t\\ttypeof URL === \"function\" &&\\r\\n\\t\\ttypeof URL.createObjectURL === \"function\" &&\\r\\n\\t\\ttypeof URL.revokeObjectURL === \"function\" &&\\r\\n\\t\\ttypeof Blob === \"function\" &&\\r\\n\\t\\ttypeof btoa === \"function\"\\r\\n\\t) {\\r\\n\\t\\tstyle = createLinkElement(options);\\r\\n\\t\\tupdate = updateLink.bind(null, style, options);\\r\\n\\t\\tremove = function () {\\r\\n\\t\\t\\tremoveStyleElement(style);\\r\\n\\r\\n\\t\\t\\tif(style.href) URL.revokeObjectURL(style.href);\\r\\n\\t\\t};\\r\\n\\t} else {\\r\\n\\t\\tstyle = createStyleElement(options);\\r\\n\\t\\tupdate = applyToTag.bind(null, style);\\r\\n\\t\\tremove = function () {\\r\\n\\t\\t\\tremoveStyleElement(style);\\r\\n\\t\\t};\\r\\n\\t}\\r\\n\\r\\n\\tupdate(obj);\\r\\n\\r\\n\\treturn function updateStyle (newObj) {\\r\\n\\t\\tif (newObj) {\\r\\n\\t\\t\\tif (\\r\\n\\t\\t\\t\\tnewObj.css === obj.css &&\\r\\n\\t\\t\\t\\tnewObj.media === obj.media &&\\r\\n\\t\\t\\t\\tnewObj.sourceMap === obj.sourceMap\\r\\n\\t\\t\\t) {\\r\\n\\t\\t\\t\\treturn;\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tupdate(obj = newObj);\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tremove();\\r\\n\\t\\t}\\r\\n\\t};\\r\\n}\\r\\n\\r\\nvar replaceText = (function () {\\r\\n\\tvar textStore = [];\\r\\n\\r\\n\\treturn function (index, replacement) {\\r\\n\\t\\ttextStore[index] = replacement;\\r\\n\\r\\n\\t\\treturn textStore.filter(Boolean).join(\\'\\\\n\\');\\r\\n\\t};\\r\\n})();\\r\\n\\r\\nfunction applyToSingletonTag (style, index, remove, obj) {\\r\\n\\tvar css = remove ? \"\" : obj.css;\\r\\n\\r\\n\\tif (style.styleSheet) {\\r\\n\\t\\tstyle.styleSheet.cssText = replaceText(index, css);\\r\\n\\t} else {\\r\\n\\t\\tvar cssNode = document.createTextNode(css);\\r\\n\\t\\tvar childNodes = style.childNodes;\\r\\n\\r\\n\\t\\tif (childNodes[index]) style.removeChild(childNodes[index]);\\r\\n\\r\\n\\t\\tif (childNodes.length) {\\r\\n\\t\\t\\tstyle.insertBefore(cssNode, childNodes[index]);\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tstyle.appendChild(cssNode);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\r\\n\\r\\nfunction applyToTag (style, obj) {\\r\\n\\tvar css = obj.css;\\r\\n\\tvar media = obj.media;\\r\\n\\r\\n\\tif(media) {\\r\\n\\t\\tstyle.setAttribute(\"media\", media)\\r\\n\\t}\\r\\n\\r\\n\\tif(style.styleSheet) {\\r\\n\\t\\tstyle.styleSheet.cssText = css;\\r\\n\\t} else {\\r\\n\\t\\twhile(style.firstChild) {\\r\\n\\t\\t\\tstyle.removeChild(style.firstChild);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tstyle.appendChild(document.createTextNode(css));\\r\\n\\t}\\r\\n}\\r\\n\\r\\nfunction updateLink (link, options, obj) {\\r\\n\\tvar css = obj.css;\\r\\n\\tvar sourceMap = obj.sourceMap;\\r\\n\\r\\n\\t/*\\r\\n\\t\\tIf convertToAbsoluteUrls isn\\'t defined, but sourcemaps are enabled\\r\\n\\t\\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\\r\\n\\t\\ton by default.  Otherwise default to the convertToAbsoluteUrls option\\r\\n\\t\\tdirectly\\r\\n\\t*/\\r\\n\\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\\r\\n\\r\\n\\tif (options.convertToAbsoluteUrls || autoFixUrls) {\\r\\n\\t\\tcss = fixUrls(css);\\r\\n\\t}\\r\\n\\r\\n\\tif (sourceMap) {\\r\\n\\t\\t// http://stackoverflow.com/a/26603875\\r\\n\\t\\tcss += \"\\\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\\r\\n\\t}\\r\\n\\r\\n\\tvar blob = new Blob([css], { type: \"text/css\" });\\r\\n\\r\\n\\tvar oldSrc = link.href;\\r\\n\\r\\n\\tlink.href = URL.createObjectURL(blob);\\r\\n\\r\\n\\tif(oldSrc) URL.revokeObjectURL(oldSrc);\\r\\n}\\r\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanM/Njg0NCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBLGNBQWMsbUJBQU8sQ0FBQyxFQUFROztBQUU5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLG1CQUFtQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDOztBQUVBO0FBQ0EsbUJBQW1CLDJCQUEyQjs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQiwyQkFBMkI7QUFDNUM7QUFDQTs7QUFFQSxRQUFRLHVCQUF1QjtBQUMvQjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLGlCQUFpQix1QkFBdUI7QUFDeEM7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjOztBQUVkLGtEQUFrRCxzQkFBc0I7QUFDeEU7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQSxLQUFLLEtBQXdDLEVBQUUsRUFFN0M7O0FBRUYsUUFBUSxzQkFBaUI7QUFDekI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEOztBQUVBLDZCQUE2QixtQkFBbUI7O0FBRWhEOztBQUVBOztBQUVBO0FBQ0EiLCJmaWxlIjoiMzAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG5cclxudmFyIHN0eWxlc0luRG9tID0ge307XHJcblxyXG52YXJcdG1lbW9pemUgPSBmdW5jdGlvbiAoZm4pIHtcclxuXHR2YXIgbWVtbztcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0eXBlb2YgbWVtbyA9PT0gXCJ1bmRlZmluZWRcIikgbWVtbyA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblx0XHRyZXR1cm4gbWVtbztcclxuXHR9O1xyXG59O1xyXG5cclxudmFyIGlzT2xkSUUgPSBtZW1vaXplKGZ1bmN0aW9uICgpIHtcclxuXHQvLyBUZXN0IGZvciBJRSA8PSA5IGFzIHByb3Bvc2VkIGJ5IEJyb3dzZXJoYWNrc1xyXG5cdC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcclxuXHQvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyXHJcblx0Ly8gdG8gb3BlcmF0ZSBjb3JyZWN0bHkgaW50byBub24tc3RhbmRhcmQgZW52aXJvbm1lbnRzXHJcblx0Ly8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlci9pc3N1ZXMvMTc3XHJcblx0cmV0dXJuIHdpbmRvdyAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5hbGwgJiYgIXdpbmRvdy5hdG9iO1xyXG59KTtcclxuXHJcbnZhciBnZXRUYXJnZXQgPSBmdW5jdGlvbiAodGFyZ2V0LCBwYXJlbnQpIHtcclxuICBpZiAocGFyZW50KXtcclxuICAgIHJldHVybiBwYXJlbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpO1xyXG4gIH1cclxuICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpO1xyXG59O1xyXG5cclxudmFyIGdldEVsZW1lbnQgPSAoZnVuY3Rpb24gKGZuKSB7XHJcblx0dmFyIG1lbW8gPSB7fTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uKHRhcmdldCwgcGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiBwYXNzaW5nIGZ1bmN0aW9uIGluIG9wdGlvbnMsIHRoZW4gdXNlIGl0IGZvciByZXNvbHZlIFwiaGVhZFwiIGVsZW1lbnQuXHJcbiAgICAgICAgICAgICAgICAvLyBVc2VmdWwgZm9yIFNoYWRvdyBSb290IHN0eWxlIGkuZVxyXG4gICAgICAgICAgICAgICAgLy8ge1xyXG4gICAgICAgICAgICAgICAgLy8gICBpbnNlcnRJbnRvOiBmdW5jdGlvbiAoKSB7IHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2Zvb1wiKS5zaGFkb3dSb290IH1cclxuICAgICAgICAgICAgICAgIC8vIH1cclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVtb1t0YXJnZXRdID09PSBcInVuZGVmaW5lZFwiKSB7XHJcblx0XHRcdHZhciBzdHlsZVRhcmdldCA9IGdldFRhcmdldC5jYWxsKHRoaXMsIHRhcmdldCwgcGFyZW50KTtcclxuXHRcdFx0Ly8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcclxuXHRcdFx0aWYgKHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCAmJiBzdHlsZVRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCkge1xyXG5cdFx0XHRcdHRyeSB7XHJcblx0XHRcdFx0XHQvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxyXG5cdFx0XHRcdFx0Ly8gZHVlIHRvIGNyb3NzLW9yaWdpbiByZXN0cmljdGlvbnNcclxuXHRcdFx0XHRcdHN0eWxlVGFyZ2V0ID0gc3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7XHJcblx0XHRcdFx0fSBjYXRjaChlKSB7XHJcblx0XHRcdFx0XHRzdHlsZVRhcmdldCA9IG51bGw7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdG1lbW9bdGFyZ2V0XSA9IHN0eWxlVGFyZ2V0O1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG1lbW9bdGFyZ2V0XVxyXG5cdH07XHJcbn0pKCk7XHJcblxyXG52YXIgc2luZ2xldG9uID0gbnVsbDtcclxudmFyXHRzaW5nbGV0b25Db3VudGVyID0gMDtcclxudmFyXHRzdHlsZXNJbnNlcnRlZEF0VG9wID0gW107XHJcblxyXG52YXJcdGZpeFVybHMgPSByZXF1aXJlKFwiLi91cmxzXCIpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihsaXN0LCBvcHRpb25zKSB7XHJcblx0aWYgKHR5cGVvZiBERUJVRyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBERUJVRykge1xyXG5cdFx0aWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50XCIpO1xyXG5cdH1cclxuXHJcblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG5cdG9wdGlvbnMuYXR0cnMgPSB0eXBlb2Ygb3B0aW9ucy5hdHRycyA9PT0gXCJvYmplY3RcIiA/IG9wdGlvbnMuYXR0cnMgOiB7fTtcclxuXHJcblx0Ly8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XHJcblx0Ly8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxyXG5cdGlmICghb3B0aW9ucy5zaW5nbGV0b24gJiYgdHlwZW9mIG9wdGlvbnMuc2luZ2xldG9uICE9PSBcImJvb2xlYW5cIikgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XHJcblxyXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIDxoZWFkPiBlbGVtZW50XHJcbiAgICAgICAgaWYgKCFvcHRpb25zLmluc2VydEludG8pIG9wdGlvbnMuaW5zZXJ0SW50byA9IFwiaGVhZFwiO1xyXG5cclxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSBib3R0b20gb2YgdGhlIHRhcmdldFxyXG5cdGlmICghb3B0aW9ucy5pbnNlcnRBdCkgb3B0aW9ucy5pbnNlcnRBdCA9IFwiYm90dG9tXCI7XHJcblxyXG5cdHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMobGlzdCwgb3B0aW9ucyk7XHJcblxyXG5cdGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucyk7XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGUgKG5ld0xpc3QpIHtcclxuXHRcdHZhciBtYXlSZW1vdmUgPSBbXTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcclxuXHRcdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XHJcblxyXG5cdFx0XHRkb21TdHlsZS5yZWZzLS07XHJcblx0XHRcdG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZihuZXdMaXN0KSB7XHJcblx0XHRcdHZhciBuZXdTdHlsZXMgPSBsaXN0VG9TdHlsZXMobmV3TGlzdCwgb3B0aW9ucyk7XHJcblx0XHRcdGFkZFN0eWxlc1RvRG9tKG5ld1N0eWxlcywgb3B0aW9ucyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBtYXlSZW1vdmUubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldO1xyXG5cclxuXHRcdFx0aWYoZG9tU3R5bGUucmVmcyA9PT0gMCkge1xyXG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIGRvbVN0eWxlLnBhcnRzW2pdKCk7XHJcblxyXG5cdFx0XHRcdGRlbGV0ZSBzdHlsZXNJbkRvbVtkb21TdHlsZS5pZF07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9O1xyXG59O1xyXG5cclxuZnVuY3Rpb24gYWRkU3R5bGVzVG9Eb20gKHN0eWxlcywgb3B0aW9ucykge1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcclxuXHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xyXG5cclxuXHRcdGlmKGRvbVN0eWxlKSB7XHJcblx0XHRcdGRvbVN0eWxlLnJlZnMrKztcclxuXHJcblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzW2pdKGl0ZW0ucGFydHNbal0pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmb3IoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR2YXIgcGFydHMgPSBbXTtcclxuXHJcblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0cGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHN0eWxlc0luRG9tW2l0ZW0uaWRdID0ge2lkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHN9O1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gbGlzdFRvU3R5bGVzIChsaXN0LCBvcHRpb25zKSB7XHJcblx0dmFyIHN0eWxlcyA9IFtdO1xyXG5cdHZhciBuZXdTdHlsZXMgPSB7fTtcclxuXHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XHJcblx0XHR2YXIgaXRlbSA9IGxpc3RbaV07XHJcblx0XHR2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcclxuXHRcdHZhciBjc3MgPSBpdGVtWzFdO1xyXG5cdFx0dmFyIG1lZGlhID0gaXRlbVsyXTtcclxuXHRcdHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdO1xyXG5cdFx0dmFyIHBhcnQgPSB7Y3NzOiBjc3MsIG1lZGlhOiBtZWRpYSwgc291cmNlTWFwOiBzb3VyY2VNYXB9O1xyXG5cclxuXHRcdGlmKCFuZXdTdHlsZXNbaWRdKSBzdHlsZXMucHVzaChuZXdTdHlsZXNbaWRdID0ge2lkOiBpZCwgcGFydHM6IFtwYXJ0XX0pO1xyXG5cdFx0ZWxzZSBuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gc3R5bGVzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQgKG9wdGlvbnMsIHN0eWxlKSB7XHJcblx0dmFyIHRhcmdldCA9IGdldEVsZW1lbnQob3B0aW9ucy5pbnNlcnRJbnRvKVxyXG5cclxuXHRpZiAoIXRhcmdldCkge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnRJbnRvJyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XHJcblx0fVxyXG5cclxuXHR2YXIgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AgPSBzdHlsZXNJbnNlcnRlZEF0VG9wW3N0eWxlc0luc2VydGVkQXRUb3AubGVuZ3RoIC0gMV07XHJcblxyXG5cdGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcInRvcFwiKSB7XHJcblx0XHRpZiAoIWxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wKSB7XHJcblx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIHRhcmdldC5maXJzdENoaWxkKTtcclxuXHRcdH0gZWxzZSBpZiAobGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpIHtcclxuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcclxuXHRcdH1cclxuXHRcdHN0eWxlc0luc2VydGVkQXRUb3AucHVzaChzdHlsZSk7XHJcblx0fSBlbHNlIGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcImJvdHRvbVwiKSB7XHJcblx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xyXG5cdH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwib2JqZWN0XCIgJiYgb3B0aW9ucy5pbnNlcnRBdC5iZWZvcmUpIHtcclxuXHRcdHZhciBuZXh0U2libGluZyA9IGdldEVsZW1lbnQob3B0aW9ucy5pbnNlcnRBdC5iZWZvcmUsIHRhcmdldCk7XHJcblx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBuZXh0U2libGluZyk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIltTdHlsZSBMb2FkZXJdXFxuXFxuIEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciAnaW5zZXJ0QXQnICgnb3B0aW9ucy5pbnNlcnRBdCcpIGZvdW5kLlxcbiBNdXN0IGJlICd0b3AnLCAnYm90dG9tJywgb3IgT2JqZWN0LlxcbiAoaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIjaW5zZXJ0YXQpXFxuXCIpO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50IChzdHlsZSkge1xyXG5cdGlmIChzdHlsZS5wYXJlbnROb2RlID09PSBudWxsKSByZXR1cm4gZmFsc2U7XHJcblx0c3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSk7XHJcblxyXG5cdHZhciBpZHggPSBzdHlsZXNJbnNlcnRlZEF0VG9wLmluZGV4T2Yoc3R5bGUpO1xyXG5cdGlmKGlkeCA+PSAwKSB7XHJcblx0XHRzdHlsZXNJbnNlcnRlZEF0VG9wLnNwbGljZShpZHgsIDEpO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50IChvcHRpb25zKSB7XHJcblx0dmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xyXG5cclxuXHRpZihvcHRpb25zLmF0dHJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xyXG5cdH1cclxuXHJcblx0aWYob3B0aW9ucy5hdHRycy5ub25jZSA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHR2YXIgbm9uY2UgPSBnZXROb25jZSgpO1xyXG5cdFx0aWYgKG5vbmNlKSB7XHJcblx0XHRcdG9wdGlvbnMuYXR0cnMubm9uY2UgPSBub25jZTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGFkZEF0dHJzKHN0eWxlLCBvcHRpb25zLmF0dHJzKTtcclxuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgc3R5bGUpO1xyXG5cclxuXHRyZXR1cm4gc3R5bGU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUxpbmtFbGVtZW50IChvcHRpb25zKSB7XHJcblx0dmFyIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcclxuXHJcblx0aWYob3B0aW9ucy5hdHRycy50eXBlID09PSB1bmRlZmluZWQpIHtcclxuXHRcdG9wdGlvbnMuYXR0cnMudHlwZSA9IFwidGV4dC9jc3NcIjtcclxuXHR9XHJcblx0b3B0aW9ucy5hdHRycy5yZWwgPSBcInN0eWxlc2hlZXRcIjtcclxuXHJcblx0YWRkQXR0cnMobGluaywgb3B0aW9ucy5hdHRycyk7XHJcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIGxpbmspO1xyXG5cclxuXHRyZXR1cm4gbGluaztcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkQXR0cnMgKGVsLCBhdHRycykge1xyXG5cdE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuXHRcdGVsLnNldEF0dHJpYnV0ZShrZXksIGF0dHJzW2tleV0pO1xyXG5cdH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXROb25jZSgpIHtcclxuXHRpZiAodHlwZW9mIF9fd2VicGFja19ub25jZV9fID09PSAndW5kZWZpbmVkJykge1xyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gX193ZWJwYWNrX25vbmNlX187XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZFN0eWxlIChvYmosIG9wdGlvbnMpIHtcclxuXHR2YXIgc3R5bGUsIHVwZGF0ZSwgcmVtb3ZlLCByZXN1bHQ7XHJcblxyXG5cdC8vIElmIGEgdHJhbnNmb3JtIGZ1bmN0aW9uIHdhcyBkZWZpbmVkLCBydW4gaXQgb24gdGhlIGNzc1xyXG5cdGlmIChvcHRpb25zLnRyYW5zZm9ybSAmJiBvYmouY3NzKSB7XHJcblx0ICAgIHJlc3VsdCA9IHR5cGVvZiBvcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJ1xyXG5cdFx0ID8gb3B0aW9ucy50cmFuc2Zvcm0ob2JqLmNzcykgXHJcblx0XHQgOiBvcHRpb25zLnRyYW5zZm9ybS5kZWZhdWx0KG9iai5jc3MpO1xyXG5cclxuXHQgICAgaWYgKHJlc3VsdCkge1xyXG5cdCAgICBcdC8vIElmIHRyYW5zZm9ybSByZXR1cm5zIGEgdmFsdWUsIHVzZSB0aGF0IGluc3RlYWQgb2YgdGhlIG9yaWdpbmFsIGNzcy5cclxuXHQgICAgXHQvLyBUaGlzIGFsbG93cyBydW5uaW5nIHJ1bnRpbWUgdHJhbnNmb3JtYXRpb25zIG9uIHRoZSBjc3MuXHJcblx0ICAgIFx0b2JqLmNzcyA9IHJlc3VsdDtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgXHQvLyBJZiB0aGUgdHJhbnNmb3JtIGZ1bmN0aW9uIHJldHVybnMgYSBmYWxzeSB2YWx1ZSwgZG9uJ3QgYWRkIHRoaXMgY3NzLlxyXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIGNvbmRpdGlvbmFsIGxvYWRpbmcgb2YgY3NzXHJcblx0ICAgIFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xyXG5cdCAgICBcdFx0Ly8gbm9vcFxyXG5cdCAgICBcdH07XHJcblx0ICAgIH1cclxuXHR9XHJcblxyXG5cdGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xyXG5cdFx0dmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XHJcblxyXG5cdFx0c3R5bGUgPSBzaW5nbGV0b24gfHwgKHNpbmdsZXRvbiA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSk7XHJcblxyXG5cdFx0dXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XHJcblx0XHRyZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIHRydWUpO1xyXG5cclxuXHR9IGVsc2UgaWYgKFxyXG5cdFx0b2JqLnNvdXJjZU1hcCAmJlxyXG5cdFx0dHlwZW9mIFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXHJcblx0XHR0eXBlb2YgVVJMLmNyZWF0ZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXHJcblx0XHR0eXBlb2YgVVJMLnJldm9rZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXHJcblx0XHR0eXBlb2YgQmxvYiA9PT0gXCJmdW5jdGlvblwiICYmXHJcblx0XHR0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiXHJcblx0KSB7XHJcblx0XHRzdHlsZSA9IGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpO1xyXG5cdFx0dXBkYXRlID0gdXBkYXRlTGluay5iaW5kKG51bGwsIHN0eWxlLCBvcHRpb25zKTtcclxuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcclxuXHJcblx0XHRcdGlmKHN0eWxlLmhyZWYpIFVSTC5yZXZva2VPYmplY3RVUkwoc3R5bGUuaHJlZik7XHJcblx0XHR9O1xyXG5cdH0gZWxzZSB7XHJcblx0XHRzdHlsZSA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKTtcclxuXHRcdHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZSk7XHJcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XHJcblx0XHR9O1xyXG5cdH1cclxuXHJcblx0dXBkYXRlKG9iaik7XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZSAobmV3T2JqKSB7XHJcblx0XHRpZiAobmV3T2JqKSB7XHJcblx0XHRcdGlmIChcclxuXHRcdFx0XHRuZXdPYmouY3NzID09PSBvYmouY3NzICYmXHJcblx0XHRcdFx0bmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiZcclxuXHRcdFx0XHRuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwXHJcblx0XHRcdCkge1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dXBkYXRlKG9iaiA9IG5ld09iaik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZW1vdmUoKTtcclxuXHRcdH1cclxuXHR9O1xyXG59XHJcblxyXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdHZhciB0ZXh0U3RvcmUgPSBbXTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcclxuXHRcdHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcclxuXHJcblx0XHRyZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcclxuXHR9O1xyXG59KSgpO1xyXG5cclxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyAoc3R5bGUsIGluZGV4LCByZW1vdmUsIG9iaikge1xyXG5cdHZhciBjc3MgPSByZW1vdmUgPyBcIlwiIDogb2JqLmNzcztcclxuXHJcblx0aWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcclxuXHRcdHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XHJcblx0XHR2YXIgY2hpbGROb2RlcyA9IHN0eWxlLmNoaWxkTm9kZXM7XHJcblxyXG5cdFx0aWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZS5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSk7XHJcblxyXG5cdFx0aWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XHJcblx0XHRcdHN0eWxlLmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRzdHlsZS5hcHBlbmRDaGlsZChjc3NOb2RlKTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFwcGx5VG9UYWcgKHN0eWxlLCBvYmopIHtcclxuXHR2YXIgY3NzID0gb2JqLmNzcztcclxuXHR2YXIgbWVkaWEgPSBvYmoubWVkaWE7XHJcblxyXG5cdGlmKG1lZGlhKSB7XHJcblx0XHRzdHlsZS5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSlcclxuXHR9XHJcblxyXG5cdGlmKHN0eWxlLnN0eWxlU2hlZXQpIHtcclxuXHRcdHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcclxuXHR9IGVsc2Uge1xyXG5cdFx0d2hpbGUoc3R5bGUuZmlyc3RDaGlsZCkge1xyXG5cdFx0XHRzdHlsZS5yZW1vdmVDaGlsZChzdHlsZS5maXJzdENoaWxkKTtcclxuXHRcdH1cclxuXHJcblx0XHRzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZUxpbmsgKGxpbmssIG9wdGlvbnMsIG9iaikge1xyXG5cdHZhciBjc3MgPSBvYmouY3NzO1xyXG5cdHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xyXG5cclxuXHQvKlxyXG5cdFx0SWYgY29udmVydFRvQWJzb2x1dGVVcmxzIGlzbid0IGRlZmluZWQsIGJ1dCBzb3VyY2VtYXBzIGFyZSBlbmFibGVkXHJcblx0XHRhbmQgdGhlcmUgaXMgbm8gcHVibGljUGF0aCBkZWZpbmVkIHRoZW4gbGV0cyB0dXJuIGNvbnZlcnRUb0Fic29sdXRlVXJsc1xyXG5cdFx0b24gYnkgZGVmYXVsdC4gIE90aGVyd2lzZSBkZWZhdWx0IHRvIHRoZSBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgb3B0aW9uXHJcblx0XHRkaXJlY3RseVxyXG5cdCovXHJcblx0dmFyIGF1dG9GaXhVcmxzID0gb3B0aW9ucy5jb252ZXJ0VG9BYnNvbHV0ZVVybHMgPT09IHVuZGVmaW5lZCAmJiBzb3VyY2VNYXA7XHJcblxyXG5cdGlmIChvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyB8fCBhdXRvRml4VXJscykge1xyXG5cdFx0Y3NzID0gZml4VXJscyhjc3MpO1xyXG5cdH1cclxuXHJcblx0aWYgKHNvdXJjZU1hcCkge1xyXG5cdFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcclxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcclxuXHR9XHJcblxyXG5cdHZhciBibG9iID0gbmV3IEJsb2IoW2Nzc10sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pO1xyXG5cclxuXHR2YXIgb2xkU3JjID0gbGluay5ocmVmO1xyXG5cclxuXHRsaW5rLmhyZWYgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xyXG5cclxuXHRpZihvbGRTcmMpIFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcclxufVxyXG4iXSwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///30\\n')},function(module,exports){eval('\\n/**\\r\\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\\r\\n * embed the css on the page. This breaks all relative urls because now they are relative to a\\r\\n * bundle instead of the current page.\\r\\n *\\r\\n * One solution is to only use full urls, but that may be impossible.\\r\\n *\\r\\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\\r\\n *\\r\\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\\r\\n *\\r\\n */\\n\\nmodule.exports = function (css) {\\n\\t// get current location\\n\\tvar location = typeof window !== \"undefined\" && window.location;\\n\\n\\tif (!location) {\\n\\t\\tthrow new Error(\"fixUrls requires window.location\");\\n\\t}\\n\\n\\t// blank or null?\\n\\tif (!css || typeof css !== \"string\") {\\n\\t\\treturn css;\\n\\t}\\n\\n\\tvar baseUrl = location.protocol + \"//\" + location.host;\\n\\tvar currentDir = baseUrl + location.pathname.replace(/\\\\/[^\\\\/]*$/, \"/\");\\n\\n\\t// convert each url(...)\\n\\t/*\\r\\n This regular expression is just a way to recursively match brackets within\\r\\n a string.\\r\\n \\n  /url\\\\s*\\\\(  = Match on the word \"url\" with any whitespace after it and then a parens\\r\\n    (  = Start a capturing group\\r\\n      (?:  = Start a non-capturing group\\r\\n          [^)(]  = Match anything that isn\\'t a parentheses\\r\\n          |  = OR\\r\\n          \\\\(  = Match a start parentheses\\r\\n              (?:  = Start another non-capturing groups\\r\\n                  [^)(]+  = Match anything that isn\\'t a parentheses\\r\\n                  |  = OR\\r\\n                  \\\\(  = Match a start parentheses\\r\\n                      [^)(]*  = Match anything that isn\\'t a parentheses\\r\\n                  \\\\)  = Match a end parentheses\\r\\n              )  = End Group\\r\\n              *\\\\) = Match anything and then a close parens\\r\\n          )  = Close non-capturing group\\r\\n          *  = Match anything\\r\\n       )  = Close capturing group\\r\\n  \\\\)  = Match a close parens\\r\\n \\n  /gi  = Get all matches, not the first.  Be case insensitive.\\r\\n  */\\n\\tvar fixedCss = css.replace(/url\\\\s*\\\\(((?:[^)(]|\\\\((?:[^)(]+|\\\\([^)(]*\\\\))*\\\\))*)\\\\)/gi, function (fullMatch, origUrl) {\\n\\t\\t// strip quotes (if they exist)\\n\\t\\tvar unquotedOrigUrl = origUrl.trim().replace(/^\"(.*)\"$/, function (o, $1) {\\n\\t\\t\\treturn $1;\\n\\t\\t}).replace(/^\\'(.*)\\'$/, function (o, $1) {\\n\\t\\t\\treturn $1;\\n\\t\\t});\\n\\n\\t\\t// already a full url? no change\\n\\t\\tif (/^(#|data:|http:\\\\/\\\\/|https:\\\\/\\\\/|file:\\\\/\\\\/\\\\/|\\\\s*$)/i.test(unquotedOrigUrl)) {\\n\\t\\t\\treturn fullMatch;\\n\\t\\t}\\n\\n\\t\\t// convert the url to a full url\\n\\t\\tvar newUrl;\\n\\n\\t\\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\\n\\t\\t\\t//TODO: should we add protocol?\\n\\t\\t\\tnewUrl = unquotedOrigUrl;\\n\\t\\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\\n\\t\\t\\t// path should be relative to the base url\\n\\t\\t\\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with \\'/\\'\\n\\t\\t} else {\\n\\t\\t\\t// path should be relative to current directory\\n\\t\\t\\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\\\.\\\\//, \"\"); // Strip leading \\'./\\'\\n\\t\\t}\\n\\n\\t\\t// send back the fixed url(...)\\n\\t\\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\\n\\t});\\n\\n\\t// send back the fixed css\\n\\treturn fixedCss;\\n};//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi91cmxzLmpzP2Y2ZDMiXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsImNzcyIsImxvY2F0aW9uIiwid2luZG93IiwiRXJyb3IiLCJiYXNlVXJsIiwicHJvdG9jb2wiLCJob3N0IiwiY3VycmVudERpciIsInBhdGhuYW1lIiwicmVwbGFjZSIsImZpeGVkQ3NzIiwiZnVsbE1hdGNoIiwib3JpZ1VybCIsInVucXVvdGVkT3JpZ1VybCIsInRyaW0iLCJvIiwiJDEiLCJ0ZXN0IiwibmV3VXJsIiwiaW5kZXhPZiIsIkpTT04iLCJzdHJpbmdpZnkiXSwibWFwcGluZ3MiOiI7QUFDQTs7Ozs7Ozs7Ozs7OztBQWFBQSxPQUFPQyxPQUFQLEdBQWlCLFVBQVVDLEdBQVYsRUFBZTtBQUM5QjtBQUNBLEtBQUlDLFdBQVcsT0FBT0MsTUFBUCxLQUFrQixXQUFsQixJQUFpQ0EsT0FBT0QsUUFBdkQ7O0FBRUEsS0FBSSxDQUFDQSxRQUFMLEVBQWU7QUFDYixRQUFNLElBQUlFLEtBQUosQ0FBVSxrQ0FBVixDQUFOO0FBQ0Q7O0FBRUY7QUFDQSxLQUFJLENBQUNILEdBQUQsSUFBUSxPQUFPQSxHQUFQLEtBQWUsUUFBM0IsRUFBcUM7QUFDbkMsU0FBT0EsR0FBUDtBQUNBOztBQUVELEtBQUlJLFVBQVVILFNBQVNJLFFBQVQsR0FBb0IsSUFBcEIsR0FBMkJKLFNBQVNLLElBQWxEO0FBQ0EsS0FBSUMsYUFBYUgsVUFBVUgsU0FBU08sUUFBVCxDQUFrQkMsT0FBbEIsQ0FBMEIsV0FBMUIsRUFBdUMsR0FBdkMsQ0FBM0I7O0FBRUQ7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXlCQSxLQUFJQyxXQUFXVixJQUFJUyxPQUFKLENBQVkscURBQVosRUFBbUUsVUFBU0UsU0FBVCxFQUFvQkMsT0FBcEIsRUFBNkI7QUFDOUc7QUFDQSxNQUFJQyxrQkFBa0JELFFBQ3BCRSxJQURvQixHQUVwQkwsT0FGb0IsQ0FFWixVQUZZLEVBRUEsVUFBU00sQ0FBVCxFQUFZQyxFQUFaLEVBQWU7QUFBRSxVQUFPQSxFQUFQO0FBQVksR0FGN0IsRUFHcEJQLE9BSG9CLENBR1osVUFIWSxFQUdBLFVBQVNNLENBQVQsRUFBWUMsRUFBWixFQUFlO0FBQUUsVUFBT0EsRUFBUDtBQUFZLEdBSDdCLENBQXRCOztBQUtBO0FBQ0EsTUFBSSxvREFBb0RDLElBQXBELENBQXlESixlQUF6RCxDQUFKLEVBQStFO0FBQzdFLFVBQU9GLFNBQVA7QUFDRDs7QUFFRDtBQUNBLE1BQUlPLE1BQUo7O0FBRUEsTUFBSUwsZ0JBQWdCTSxPQUFoQixDQUF3QixJQUF4QixNQUFrQyxDQUF0QyxFQUF5QztBQUN0QztBQUNGRCxZQUFTTCxlQUFUO0FBQ0EsR0FIRCxNQUdPLElBQUlBLGdCQUFnQk0sT0FBaEIsQ0FBd0IsR0FBeEIsTUFBaUMsQ0FBckMsRUFBd0M7QUFDOUM7QUFDQUQsWUFBU2QsVUFBVVMsZUFBbkIsQ0FGOEMsQ0FFVjtBQUNwQyxHQUhNLE1BR0E7QUFDTjtBQUNBSyxZQUFTWCxhQUFhTSxnQkFBZ0JKLE9BQWhCLENBQXdCLE9BQXhCLEVBQWlDLEVBQWpDLENBQXRCLENBRk0sQ0FFc0Q7QUFDNUQ7O0FBRUQ7QUFDQSxTQUFPLFNBQVNXLEtBQUtDLFNBQUwsQ0FBZUgsTUFBZixDQUFULEdBQWtDLEdBQXpDO0FBQ0EsRUE1QmMsQ0FBZjs7QUE4QkE7QUFDQSxRQUFPUixRQUFQO0FBQ0EsQ0ExRUQiLCJmaWxlIjoiMzEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcclxuLyoqXHJcbiAqIFdoZW4gc291cmNlIG1hcHMgYXJlIGVuYWJsZWQsIGBzdHlsZS1sb2FkZXJgIHVzZXMgYSBsaW5rIGVsZW1lbnQgd2l0aCBhIGRhdGEtdXJpIHRvXHJcbiAqIGVtYmVkIHRoZSBjc3Mgb24gdGhlIHBhZ2UuIFRoaXMgYnJlYWtzIGFsbCByZWxhdGl2ZSB1cmxzIGJlY2F1c2Ugbm93IHRoZXkgYXJlIHJlbGF0aXZlIHRvIGFcclxuICogYnVuZGxlIGluc3RlYWQgb2YgdGhlIGN1cnJlbnQgcGFnZS5cclxuICpcclxuICogT25lIHNvbHV0aW9uIGlzIHRvIG9ubHkgdXNlIGZ1bGwgdXJscywgYnV0IHRoYXQgbWF5IGJlIGltcG9zc2libGUuXHJcbiAqXHJcbiAqIEluc3RlYWQsIHRoaXMgZnVuY3Rpb24gXCJmaXhlc1wiIHRoZSByZWxhdGl2ZSB1cmxzIHRvIGJlIGFic29sdXRlIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBwYWdlIGxvY2F0aW9uLlxyXG4gKlxyXG4gKiBBIHJ1ZGltZW50YXJ5IHRlc3Qgc3VpdGUgaXMgbG9jYXRlZCBhdCBgdGVzdC9maXhVcmxzLmpzYCBhbmQgY2FuIGJlIHJ1biB2aWEgdGhlIGBucG0gdGVzdGAgY29tbWFuZC5cclxuICpcclxuICovXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjc3MpIHtcclxuICAvLyBnZXQgY3VycmVudCBsb2NhdGlvblxyXG4gIHZhciBsb2NhdGlvbiA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LmxvY2F0aW9uO1xyXG5cclxuICBpZiAoIWxvY2F0aW9uKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJmaXhVcmxzIHJlcXVpcmVzIHdpbmRvdy5sb2NhdGlvblwiKTtcclxuICB9XHJcblxyXG5cdC8vIGJsYW5rIG9yIG51bGw/XHJcblx0aWYgKCFjc3MgfHwgdHlwZW9mIGNzcyAhPT0gXCJzdHJpbmdcIikge1xyXG5cdCAgcmV0dXJuIGNzcztcclxuICB9XHJcblxyXG4gIHZhciBiYXNlVXJsID0gbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKyBsb2NhdGlvbi5ob3N0O1xyXG4gIHZhciBjdXJyZW50RGlyID0gYmFzZVVybCArIGxvY2F0aW9uLnBhdGhuYW1lLnJlcGxhY2UoL1xcL1teXFwvXSokLywgXCIvXCIpO1xyXG5cclxuXHQvLyBjb252ZXJ0IGVhY2ggdXJsKC4uLilcclxuXHQvKlxyXG5cdFRoaXMgcmVndWxhciBleHByZXNzaW9uIGlzIGp1c3QgYSB3YXkgdG8gcmVjdXJzaXZlbHkgbWF0Y2ggYnJhY2tldHMgd2l0aGluXHJcblx0YSBzdHJpbmcuXHJcblxyXG5cdCAvdXJsXFxzKlxcKCAgPSBNYXRjaCBvbiB0aGUgd29yZCBcInVybFwiIHdpdGggYW55IHdoaXRlc3BhY2UgYWZ0ZXIgaXQgYW5kIHRoZW4gYSBwYXJlbnNcclxuXHQgICAoICA9IFN0YXJ0IGEgY2FwdHVyaW5nIGdyb3VwXHJcblx0ICAgICAoPzogID0gU3RhcnQgYSBub24tY2FwdHVyaW5nIGdyb3VwXHJcblx0ICAgICAgICAgW14pKF0gID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXHJcblx0ICAgICAgICAgfCAgPSBPUlxyXG5cdCAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXHJcblx0ICAgICAgICAgICAgICg/OiAgPSBTdGFydCBhbm90aGVyIG5vbi1jYXB0dXJpbmcgZ3JvdXBzXHJcblx0ICAgICAgICAgICAgICAgICBbXikoXSsgID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXHJcblx0ICAgICAgICAgICAgICAgICB8ICA9IE9SXHJcblx0ICAgICAgICAgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgIFteKShdKiAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcclxuXHQgICAgICAgICAgICAgICAgIFxcKSAgPSBNYXRjaCBhIGVuZCBwYXJlbnRoZXNlc1xyXG5cdCAgICAgICAgICAgICApICA9IEVuZCBHcm91cFxyXG4gICAgICAgICAgICAgICpcXCkgPSBNYXRjaCBhbnl0aGluZyBhbmQgdGhlbiBhIGNsb3NlIHBhcmVuc1xyXG4gICAgICAgICAgKSAgPSBDbG9zZSBub24tY2FwdHVyaW5nIGdyb3VwXHJcbiAgICAgICAgICAqICA9IE1hdGNoIGFueXRoaW5nXHJcbiAgICAgICApICA9IENsb3NlIGNhcHR1cmluZyBncm91cFxyXG5cdCBcXCkgID0gTWF0Y2ggYSBjbG9zZSBwYXJlbnNcclxuXHJcblx0IC9naSAgPSBHZXQgYWxsIG1hdGNoZXMsIG5vdCB0aGUgZmlyc3QuICBCZSBjYXNlIGluc2Vuc2l0aXZlLlxyXG5cdCAqL1xyXG5cdHZhciBmaXhlZENzcyA9IGNzcy5yZXBsYWNlKC91cmxcXHMqXFwoKCg/OlteKShdfFxcKCg/OlteKShdK3xcXChbXikoXSpcXCkpKlxcKSkqKVxcKS9naSwgZnVuY3Rpb24oZnVsbE1hdGNoLCBvcmlnVXJsKSB7XHJcblx0XHQvLyBzdHJpcCBxdW90ZXMgKGlmIHRoZXkgZXhpc3QpXHJcblx0XHR2YXIgdW5xdW90ZWRPcmlnVXJsID0gb3JpZ1VybFxyXG5cdFx0XHQudHJpbSgpXHJcblx0XHRcdC5yZXBsYWNlKC9eXCIoLiopXCIkLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pXHJcblx0XHRcdC5yZXBsYWNlKC9eJyguKiknJC8sIGZ1bmN0aW9uKG8sICQxKXsgcmV0dXJuICQxOyB9KTtcclxuXHJcblx0XHQvLyBhbHJlYWR5IGEgZnVsbCB1cmw/IG5vIGNoYW5nZVxyXG5cdFx0aWYgKC9eKCN8ZGF0YTp8aHR0cDpcXC9cXC98aHR0cHM6XFwvXFwvfGZpbGU6XFwvXFwvXFwvfFxccyokKS9pLnRlc3QodW5xdW90ZWRPcmlnVXJsKSkge1xyXG5cdFx0ICByZXR1cm4gZnVsbE1hdGNoO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGNvbnZlcnQgdGhlIHVybCB0byBhIGZ1bGwgdXJsXHJcblx0XHR2YXIgbmV3VXJsO1xyXG5cclxuXHRcdGlmICh1bnF1b3RlZE9yaWdVcmwuaW5kZXhPZihcIi8vXCIpID09PSAwKSB7XHJcblx0XHQgIFx0Ly9UT0RPOiBzaG91bGQgd2UgYWRkIHByb3RvY29sP1xyXG5cdFx0XHRuZXdVcmwgPSB1bnF1b3RlZE9yaWdVcmw7XHJcblx0XHR9IGVsc2UgaWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiL1wiKSA9PT0gMCkge1xyXG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYmFzZSB1cmxcclxuXHRcdFx0bmV3VXJsID0gYmFzZVVybCArIHVucXVvdGVkT3JpZ1VybDsgLy8gYWxyZWFkeSBzdGFydHMgd2l0aCAnLydcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIGN1cnJlbnQgZGlyZWN0b3J5XHJcblx0XHRcdG5ld1VybCA9IGN1cnJlbnREaXIgKyB1bnF1b3RlZE9yaWdVcmwucmVwbGFjZSgvXlxcLlxcLy8sIFwiXCIpOyAvLyBTdHJpcCBsZWFkaW5nICcuLydcclxuXHRcdH1cclxuXHJcblx0XHQvLyBzZW5kIGJhY2sgdGhlIGZpeGVkIHVybCguLi4pXHJcblx0XHRyZXR1cm4gXCJ1cmwoXCIgKyBKU09OLnN0cmluZ2lmeShuZXdVcmwpICsgXCIpXCI7XHJcblx0fSk7XHJcblxyXG5cdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgY3NzXHJcblx0cmV0dXJuIGZpeGVkQ3NzO1xyXG59O1xyXG4iXSwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///31\\n')}]);","extractedComments":[]}